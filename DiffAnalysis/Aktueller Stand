Was bereits existiert:
Python - Framework:
	1. Einlesen zweier Java Dateien
	2. Erzeugen von DOOP Fakten (& Jimple)
	3. Kopieren aller DOOP Fakten in Zielverzeichnis
	4. Programmanalyse: als Engine entweder Souffle (extern) oder Nemo
		- Nemo: PointerAnalyse, ConstantPropagation
		- Souffle: PointerAnalyse
	5. Merge & Auswertung der Aehnlichkeiten 
	zweier Datenbanken zu 1 DB
		- Merge der Fakten
		- Merge der Separaten Analyseergebnisse (Auch möglich Souffle Analyse mit Nemo Analyse zu vergleichen, insofern beide 			Dateien im gleichen Format vorliegen)
	6. Programmanalyse auf den gemergten Fakten
		- PointerAnalyse_merged.rls (NEMO)

Verbesserungsmöglichkeiten:
	- Spezifizierung der Relationen, die verglichen / gemergt werden sollen -> dadurch lassen sich Hilfsrelationen ausschliessen die kein Einfluss auf das Ergbnis haben, aber das Ergebnis verzerren ausgeschlossen werden
	

Efficient Program analysis in datalog 
Exploiting similarities in databases for more efficient datalog program analysis.

Effizientere Programmanalyse in Datalog für ähnliche Datenbanken.



Diskussion mit Markus:
- Titel: 
- Effizientere Programmanalysen in Datalog durch die kompakte Darstellung ähnlicher Datenbanken. 
- Speicherreduktion für Datalog-basierte Programmanalysen durch das Komprimieren ähnlicher Java-Programmenversionen auf Datenbankebene.
- Ausnutzung syntaktischer und struktureller Aehnlichkeiten von Java-Programmen für effizientere Datalog-Programmanalyse.

- Kompaktere datalog Programmanalyse bei ähnlichen Java-Programmenversionen durch eine 
- Effizientere Datalog Programmanalysen durch die emeinsame Darstellung ähnlicher Datenbanken 
- Datenbankkompression für Datalog-Programmanalyse ähnlicher Java-Programmenversionen.
-  

Monotone aggregate aweren gut 


Weiteres Vorgehen:
Es existiert ein Python-Framework, welches Doop Fakten generiert, NEMO oder Souffle Analysen ausführt und die Ergebnisse zugreifbar macht.
Zudem können die Dateien zweier Ordner anhand einer Relation compareRelation() zeilenweise verglichen und gemerged werden. Hierbei bietet sich die Möglichkeit andere Bijektionen auszuprobieren.
Für die PointerAnalyse in NEMO besteht die Möglichkeit die Analyse separat (für Java-file1 / Java-file2) auszuführen und die Ergebnisse zu vergleichen, oder eine GEMEINSAME Analyse auf Grundlage der gemergten DOOP Fakten durchzuführen.
Diese gemeinsame Analyse liefert die gleichen Ergebnisse wie eine Zusammenfassung der beiden separaten Analysen.
Hinsichtlich Berechnungszeit ist die gemeinsame Berechnung nur 10%-20% schneller, was vorallem auf die geringeren Ladezeiten zurückfürbar ist.

Mögliches praktisches Vorgehen:
Anpassungen an den Analysen: Nemo 5.0, Reduktion der Output Dateien.
Erweiterung durch eine zweite Analyse (ConstantPropagation)
Untersuchung von grösseren Beispielen. D.h. realistischere Fälle, mit z.b. 500 - 1000 Zeilen Code, Untersuchung auf Schwachstellen: 
	- Welchen Einfluss hat die Umbenennung von Methoden & Klassen
	- Wie gross sind die Auswirkungen bei einer gelöschten Zeile, die am Anfang des Skriptes steht?
	- Gibt es Vergleiche zu related Work / Code Clone Propagation? z.B. Vergleich der Verschiedenheiten auf JAVA-Ebene vs Verschiedenheiten auf DB-Ebene.
	- Umkehrfrage: gibt es Veränderungen, die keine/kaum Einfluss auf die DB und Analyseergebnisse haben?
- Nachverfolgen/ Tracen von gemeinsamen Ergebnissen -> hin zu gemeinsamen Zielen
	


Theoretisches Vorgehen:
- Erklären der Verwendeten Programmanalysen & Vergleich der Separaten & gemeinsamen Version
- Andere Mergeverfahren sind ggf. von der Analyse abängig: 
	syntaktische Aenderungen: Entfernen der Zeilennummern, 
	Strukturell: 


- Theorie: Ontologie Matching, Code Clone Detection, Pointer Assignment Graph, Variable Assignment Graphs -> bringen eigentlich eher ähnliche Strukturen zum Vorschein
aber abspeicherung in Tabellenform ggf. schwierig
	- eventuell ist die Wahl der Bijektion auch von der Analyse abängig?
	- Wie sollen Einträge, die nicht mehr identisch sind, gemeinsam abgespeichert werden?
	- Strukturell, aber was bringt es bzw. wie kann es umgesetzt werden:
	- related work: 
	
	1. Datenbankkompression -- dynamik in DB, Versionierung bei Queries, Versionierungsbaueme, Vtree
	2. PA auf gemeinsamer Base, Clone Erzeugen, Kontext-sensitiv führt zu subize,
	4. theoretischer Speicherbedarf, Tupel & Spalte, Anzahl der Terme, Hauptspeicher während Nemo, 
	5. MiniBeispiel Db1,Db2 50% Uebereinstimmung, PA1(60%), PA2(50%), IDB -> Base Caw
	6. Stratgie: IDB ergebnis
	7. Base-line: maximale Bijektion, random bijektion zw. Resten, 0 vergeben
	8. gesamt Bijektion
	9. Mapping, Heuristik anhand von Regeln, ungleiche Tupel zusammenbringen 	& gleiche Ergebnisse inferieren, PA in Mapping einbeziehen
	10. Mapping != Merge, man kann mehr mapping machen,
	11. IDB Prädikate minimieren, erstmal Domänenspezifisch, statt PA spezifisch
	12. Backtracking mit Diff von Source Code, source code , andere Mappings?  z.B. mit Diff, Syntaktisch, Gleichheit bis auf Nummer,
	oder Semantisch, gleiche Fakten im EDB Bereich
	
Die Bijektion vergleich

	
	
	Voranalyse, wo Terme vorkommen?
	Auftrennen von Relationen, je nach PA
	
Ontology Mapping: Paare Finden, String-Edit-Distance, Byte-Code, Semantisch, 
Mapping A + f(B), extra tabelle für Flag, keine, 
Bijektion als Tabelle  




Fragen:
fuer Markus ist das Mapping A-> f(B) wichtig. Dabei werden Tupel von A auf Tupel von B gemappt, obwohl diese nicht unbedingt gleich sein müssen. A,B müssen auch nicht notwendiger weise gemergt werden, es reicht eine Extra tabelle, die jeder Zeile in A ein Mapping auf B gibt (bzw. wofür es gilt). D.h. ich gehe davon aus, dass ein Fakt der für A berechnet wurde auch für B gilt.
z.b. VA(1,"var/x") -> VB(2,"var/y"). Regel: A(?id2,?a),A(?id1,?a):- VA(?id1,?a), MapA(?id1,?id2).  A(?id2,?a):- VB(?id2,?a),MapB(?id2,2). 




	
SHK:
- VarActive Untersuchen, da kommen komische Ergebnisse raus
- Geringe Unterschiede der CFG versionen, Split CFG hat verdoppelte Einträge
- allerdings überträgt es korrekt information für 1 seite (rechts)
- generelles Problem: Uberdenken von CFG & Seite, falls 1 seite neuen BB aufmacht ...
- Fall 1: linke Seite eröffnet neuen BB (if x {x=1;y=1;} vs. if x {y=1;}): kein Problem, da der neue BB von target eröffnet wird (Block,List,Opt etc.)

