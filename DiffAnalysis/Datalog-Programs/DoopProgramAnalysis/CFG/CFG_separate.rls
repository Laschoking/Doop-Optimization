@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
true("true"^^xsd:boolean).

@import MainClass :- tsv{resource="MainClass.tsv",format=(string)}. 

% "<sun.misc.ProxyGenerator: byte[] generateClassFile()>"
% "abstract"

@import A_ArrayType :-tsv{resource="ArrayType.tsv",format=(string)} .
@import A_ActualParam :-tsv{resource="ActualParam.tsv",format=(int,string,string)} .
@import A_Var_Type :-tsv{resource="Var-Type.tsv",format=(string,string )} .
@import A_Var_DeclaringMethod :-tsv{resource="Var-DeclaringMethod.tsv",format=(string,string)} .
@import A_Var_SimpleName :-tsv{resource="Var-SimpleName.tsv",format=(string,string)} .
@import A_ApplicationClass :-tsv{resource="ApplicationClass.tsv",format=(string )} .
@import A_ApplicationPackage :-tsv{resource="ApplicationPackage.tsv",format=(string)} .
@import A_ThisVar :-tsv{resource="ThisVar.tsv",format=(string,string)} .
@import A_ExceptionHandler_Previous :-tsv{resource="ExceptionHandler-Previous.tsv",format=(string,string)} .
@import A_ArrayAllocation :-tsv{resource="ArrayAllocation.tsv",format=(string,int,string)} .
@import A_ArrayInsnIndex :-tsv{resource="ArrayInsnIndex.tsv",format=(string,string)} .
@import A_Type_Annotation :-tsv{resource="Type-Annotation.tsv",format=(string,string)} .
@import A_Method_Annotation :-tsv{resource="Method-Annotation.tsv",format=(string,string)} .
@import A_Field_Annotation :-tsv{resource="Field-Annotation.tsv",format=(string,string)} .
@import A_Param_Annotation :-tsv{resource="Param-Annotation.tsv",format=(string,int,string)} .
@import A_AssignBinop :- tsv{resource="AssignBinop.tsv", format=(string, int, string, string)} .
@import A_AssignCast :- tsv{resource="AssignCast.tsv", format=(string, int, string, string, string, string)} .
@import A_AssignCastNull :- tsv{resource="AssignCastNull.tsv", format=(string, int, string, string, string)} .
@import A_AssignCastNumConstant :- tsv{resource="AssignCastNumConstant.tsv", format=(string, int, string, string, string, string)} .
@import A_AssignHeapAllocation :- tsv{resource="AssignHeapAllocation.tsv", format=(string, int, string, string, string, int)} .
@import A_AssignInstanceOf :- tsv{resource="AssignInstanceOf.tsv", format=(string, int, string, string, string, string)} .
@import A_AssignLocal :- tsv{resource="AssignLocal.tsv", format=(string, int, string, string, string)} .
@import A_AssignNull :- tsv{resource="AssignNull.tsv", format=(string, int, string, string)} .
@import A_AssignNumConstant :- tsv{resource="AssignNumConstant.tsv", format=(string, int, string, string, string)} .
@import A_AssignOperFrom :- tsv{resource="AssignOperFrom.tsv", format=(string, int, string)} .
@import A_AssignOperFromConstant :- tsv{resource="AssignOperFromConstant.tsv", format=(string, int, double)} .
@import A_AssignPhantomInvoke :- tsv{resource="AssignPhantomInvoke.tsv", format=(string, int, string)} .
@import A_AssignReturnValue :- tsv{resource="AssignReturnValue.tsv", format=(string, string)} .
@import A_AssignUnop :- tsv{resource="AssignUnop.tsv", format=(string, int, string, string)} .
@import A_BootstrapParam :- tsv{resource="BootstrapParam.tsv", format=(int, string, string)} .
@import A_BreakpointStmt :- tsv{resource="BreakpointStmt.tsv", format=(string, int, string)} .
@import A_ClassArtifact :- tsv{resource="Class-Artifact.tsv", format=(string, string, string, int)} .
@import A_ClassHeap :- tsv{resource="ClassHeap.tsv", format=(string, string)} .
@import A_ClassModifier :- tsv{resource="ClassModifier.tsv", format=(string, string)} .
@import A_ClassType :- tsv{resource="ClassType.tsv", format=(string)} .
@import A_ComponentType :- tsv{resource="ComponentType.tsv", format=(string, string)} .
@import A_DirectSuperclass :- tsv{resource="DirectSuperclass.tsv", format=(string, string)} .
@import A_DirectSuperinterface :- tsv{resource="DirectSuperinterface.tsv", format=(string, string)} .
@import A_DummyIfVar :- tsv{resource="DummyIfVar.tsv", format=(string, string)} .
@import A_DynamicMethodInvocation :- tsv{resource="DynamicMethodInvocation.tsv", format=(string, int, string, string, string, int, string,int, string)} .
@import A_EmptyArray :- tsv{resource="EmptyArray.tsv", format=(string)} .
@import A_EnterMonitor :- tsv{resource="EnterMonitor.tsv", format=(string, int, string, string)} .
@import A_ExceptionHandler :- tsv{resource="ExceptionHandler.tsv", format=(string, string, int, string, int, int)} .
@import A_ExitMonitor :- tsv{resource="ExitMonitor.tsv", format=(string, int, string, string)} .
@import A_Field :- tsv{resource="Field.tsv", format=(string, string, string, string)} .
@import A_Field_Modifier :- tsv{resource="Field-Modifier.tsv", format=(string, string)} .
@import A_FormalParam :- tsv{resource="FormalParam.tsv", format=(int, string, string)} .
@import A_Goto :- tsv{resource="Goto.tsv", format=(string, int, int, string)} .
@import A_If :- tsv{resource="If.tsv", format=(string, int, int, string)} .
@import A_IfConstant :- tsv{resource="IfConstant.tsv", format=(string, int, string)} .
@import A_IfVar :- tsv{resource="IfVar.tsv", format=(string, int, string)} .
@import A_InterfaceType :- tsv{resource="InterfaceType.tsv", format=(string)} .
@import A_LoadArrayIndex :- tsv{resource="LoadArrayIndex.tsv", format=(string, int, string, string, string)} .
@import A_LoadInstanceField :- tsv{resource="LoadInstanceField.tsv", format=(string, int, string, string, string, string)} .
@import A_LoadStaticField :- tsv{resource="LoadStaticField.tsv", format=(string, int, string, string, string)} .
@import A_LookupSwitch :- tsv{resource="LookupSwitch.tsv", format=(string, int, string, string)} .
@import A_LookupSwitch_Default :- tsv{resource="LookupSwitch-Default.tsv", format=(string, int)} .
@import A_LookupSwitch_Target :- tsv{resource="LookupSwitch-Target.tsv", format=(string, int, int)} .
@import A_Method :- tsv{resource="Method.tsv", format=(string, string, string, string, string, string, int)} .
@import A_MethodHandleConstant :- tsv{resource="MethodHandleConstant.tsv", format=(string, string, string, string, int)} .
@import A_MethodInvocation_Line :- tsv{resource="MethodInvocation-Line.tsv", format=(string, int)} .
@import A_MethodTypeConstant :- tsv{resource="MethodTypeConstant.tsv", format=(string, int, string, string)} .
@import A_MethodTypeConstantParam :- tsv{resource="MethodTypeConstantParam.tsv", format=(string, int, string)} .
@import A_Method_DeclaresException :- tsv{resource="Method-DeclaresException.tsv", format=(string, string)} .
@import A_Method_Modifier :- tsv{resource="Method-Modifier.tsv", format=(string, string)} .
@import A_NativeLibEntryPoint :- tsv{resource="NativeLibEntryPoint.tsv", format=(string, string, string)} .
@import A_NativeMethodId :- tsv{resource="NativeMethodId.tsv", format=(string, string)} .
@import A_NativeMethodTypeCandidate :- tsv{resource="NativeMethodTypeCandidate.tsv", format=(string, string, string, int)} .
@import A_NativeNameCandidate :- tsv{resource="NativeNameCandidate.tsv", format=(string, string, string, int)} .
@import A_NativeReturnVar :- tsv{resource="NativeReturnVar.tsv", format=(string, string)} .
@import A_NativeXRef :- tsv{resource="NativeXRef.tsv", format=(string, string, string, int)} .
@import A_NormalHeap :- tsv{resource="NormalHeap.tsv", format=(string, string)} .
@import A_OperatorAt :- tsv{resource="OperatorAt.tsv", format=(string, string)} .
@import A_PolymorphicInvocation :- tsv{resource="PolymorphicInvocation.tsv", format=(string, string)} .
@import A_Return :- tsv{resource="Return.tsv", format=(string, int, string, string)} .
@import A_ReturnVoid :- tsv{resource="ReturnVoid.tsv", format=(string, int, string)} .
@import A_SpecialMethodInvocation :- tsv{resource="SpecialMethodInvocation.tsv", format=(string, int, string, string, string)} .
@import A_StaticMethodInvocation :- tsv{resource="StaticMethodInvocation.tsv", format=(string, int, string, string)} .
@import A_StoreArrayIndex :- tsv{resource="StoreArrayIndex.tsv", format=(string, int, string, string, string)} .
@import A_StoreInstanceField :- tsv{resource="StoreInstanceField.tsv", format=(string, int, string, string, string, string)} .
@import A_StoreStaticField :- tsv{resource="StoreStaticField.tsv", format=(string, int, string, string, string)} .
@import A_StringConstant :- tsv{resource="StringConstant.tsv", format=(string)} .
@import A_StringRaw :- tsv{resource="StringRaw.tsv", format=(string, string)} .
@import A_SuperMethodInvocation :- tsv{resource="SuperMethodInvocation.tsv", format=(string, int, string, string, string)} .
@import A_TableSwitch :- tsv{resource="TableSwitch.tsv", format=(string, int, string, string)} .
@import A_TableSwitch_Default :- tsv{resource="TableSwitch-Default.tsv", format=(string, int)} .
@import A_TableSwitch_Target :- tsv{resource="TableSwitch-Target.tsv", format=(string, int, int)} .
@import A_ThisVar :- tsv{resource="ThisVar.tsv", format=(string, string)} .
@import A_Throw :- tsv{resource="Throw.tsv", format=(string, int, string, string)} .
@import A_ThrowNull :- tsv{resource="ThrowNull.tsv", format=(string, int, string)} .
@import A_UnsupportedInstruction :- tsv{resource="UnsupportedInstruction.tsv",format=(string,int,string)}.
@import A_VirtualMethodInvocation :- tsv{resource="VirtualMethodInvocation.tsv",format=(string,int,string,string,string)}.




% extended Facts:

Throw(?insn, ?var) :-
	isThrow_Insn(?insn),
	Throw_Var(?insn, ?var).

LoadInstanceField(?base, ?sig, ?to, ?inmethod) :-
	isLoadInstanceField_Insn(?insn),
	Instruction_Method(?insn, ?inmethod),
	LoadInstanceField_Base(?insn, ?base),
	FieldInstruction_Signature(?insn, ?sig),
	LoadInstanceField_To(?insn, ?to).

StoreInstanceField(?from, ?base, ?sig, ?inmethod) :-
	isStoreInstanceField_Insn(?insn),
	Instruction_Method(?insn, ?inmethod),
	StoreInstanceField_From(?insn, ?from),
	StoreInstanceField_Base(?insn, ?base),
	FieldInstruction_Signature(?insn, ?sig).

LoadStaticField(?sig, ?to, ?inmethod) :-
	isLoadStaticField_Insn(?insn),
	Instruction_Method(?insn, ?inmethod),
	FieldInstruction_Signature(?insn, ?sig),
	LoadStaticField_To(?insn, ?to).

StoreStaticField(?from, ?sig, ?inmethod) :-
	isStoreStaticField_Insn(?insn),
	Instruction_Method(?insn, ?inmethod),
	StoreStaticField_From(?insn, ?from),
	FieldInstruction_Signature(?insn, ?sig).

LoadArrayIndex(?base, ?to, ?inmethod) :-
	isLoadArrayIndex_Insn(?insn),
	Instruction_Method(?insn, ?inmethod),
	LoadArrayIndex_Base(?insn, ?base),
	LoadArrayIndex_To(?insn, ?to).

StoreArrayIndex(?from, ?base, ?inmethod) :-
	isStoreArrayIndex_Insn(?insn),
	Instruction_Method(?insn, ?inmethod),
	StoreArrayIndex_From(?insn, ?from),
	StoreArrayIndex_Base(?insn, ?base).


AssignNull(?to, ?inmethod) :-
	isAssignNull_Insn(?insn),
	AssignInstruction_To(?insn, ?to),
	Instruction_Method(?insn, ?inmethod).


ReturnVar(?var, ?method) :-
	isReturnNonvoid_Insn(?insn),
	Instruction_Method(?insn, ?method),
	ReturnNonvoid_Var(?insn, ?var).

ReturnVar(?var, ?method) :-
	NativeReturnVar(?var, ?method).

VirtualMethodInvocation(?invocation, ?signature, ?inmethod) :-
	isVirtualMethodInvocation_Insn(?invocation),
	Instruction_Method(?invocation, ?inmethod),
	MethodInvocation_Method(?invocation, ?signature).

StaticMethodInvocation(?invocation, ?signature, ?inmethod) :-
	isStaticMethodInvocation_Insn(?invocation),
	Instruction_Method(?invocation, ?inmethod),
	MethodInvocation_Method(?invocation, ?signature).

SuperMethodInvocation(?invocation, ?signature, ?inmethod) :-
	isSuperMethodInvocation_Insn(?invocation),
	Instruction_Method(?invocation, ?inmethod),
	MethodInvocation_Method(?invocation, ?signature).

VirtualMethodInvocation_SimpleName(?invocation, ?simplename),
VirtualMethodInvocation_Descriptor(?invocation, ?descriptor) :-
	isVirtualMethodInvocation_Insn(?invocation),
	MethodInvocation_Method(?invocation, ?signature),
	Method_SimpleName(?signature, ?simplename),
	Method_Descriptor(?signature, ?descriptor).

StaticMethodInvocation_SimpleName(?invocation, ?simplename),
StaticMethodInvocation_Descriptor(?invocation, ?descriptor) :-
	isStaticMethodInvocation_Insn(?invocation),
	MethodInvocation_Method(?invocation, ?signature),
	Method_SimpleName(?signature, ?simplename),
	Method_Descriptor(?signature, ?descriptor).

SpecialMethodInvocation_SimpleName(?invocation, ?simplename),
SpecialMethodInvocation_Descriptor(?invocation, ?descriptor) :-
	isSpecialMethodInvocation_Insn(?invocation),
	MethodInvocation_Method(?invocation, ?signature),
	Method_SimpleName(?signature, ?simplename),
	Method_Descriptor(?signature, ?descriptor).

SuperMethodInvocation_SimpleName(?invocation, ?simplename),
SuperMethodInvocation_Descriptor(?invocation, ?descriptor) :-
	isSuperMethodInvocation_Insn(?invocation),
	MethodInvocation_Method(?invocation, ?signature),
	Method_SimpleName(?signature, ?simplename),
	Method_Descriptor(?signature, ?descriptor).


MethodInvocation_SimpleName(?invocation, ?simplename) :-
	VirtualMethodInvocation_SimpleName(?invocation, ?simplename).
MethodInvocation_SimpleName(?invocation, ?simplename) :-
	SpecialMethodInvocation_SimpleName(?invocation, ?simplename).
MethodInvocation_SimpleName(?invocation, ?simplename) :-
	StaticMethodInvocation_SimpleName(?invocation, ?simplename).
MethodInvocation_SimpleName(?invocation, ?simplename) :-
	SuperMethodInvocation_SimpleName(?invocation, ?simplename).

isOpaqueInstruction(?instruction) :-
   A_StaticMethodInvocation(?instruction, _, ?signature, _),
   isOpaqueMethod(?signature).
isOpaqueInstruction(?instruction) :-
   A_SpecialMethodInvocation(?instruction, _, ?signature, _, _),
   isOpaqueMethod(?signature).
isOpaqueInstruction(?instruction) :-
   A_VirtualMethodInvocation(?instruction, _, ?signature, _, _),
   isOpaqueMethod(?signature).
isOpaqueMethod(?m) :- isMethod(?m), ?m = "<sun.misc.ProxyGenerator: byte[] generateClassFile()>" .
isType(?t) :- isPrimitiveType(?t).
isType(?t) :- isReferenceType(?t).

isReferenceType(?t) :- isNullType(?t).
isReferenceType(?t) :- isArrayType(?t).
isReferenceType(?t) :- isClassType(?t).
isReferenceType(?t) :- isInterfaceType(?t).
isReferenceType(?t) :- isAnnotation(?t).

isHeapAllocation(?h) :-   isNormalHeap(?h).
isHeapAllocation(?h) :- isStringConstant(?h).
isHeapAllocation(?h) :- isClassHeap(?h).
isHeapAllocation(?h) :- isMethodHandleConstant(?h).
isHeapAllocation(?h) :- isMethodTypeConstant(?h).


isInstruction(?i) :-  isThrow_Insn(?i). 
isInstruction(?i) :- isGoto_Insn(?i).
isInstruction(?i) :- isIf_Insn(?i).
isInstruction(?i) :- isSwitch_Insn(?i).
isInstruction(?i) :- isMonitorInstruction(?i).
isInstruction(?i) :-  isFieldInstruction(?i) .
isInstruction(?i) :- isArrayInstruction(?i).
isInstruction(?i) :- isAssignInstruction(?i).
isInstruction(?i) :-  isReturnInstruction(?i) .
isInstruction(?i) :- isMethodInvocation(?i).
isInstruction(?i) :- isUnsupportedInstruction(?i).

isThrowNull_Insn(?i) :- isThrow_Insn(?i).

isSwitch_Insn(?i) :- isTableSwitch_Insn(?i) .
isSwitch_Insn(?i):- isLookupSwitch_Insn(?i).

isMonitorInstruction(?i) :- isEnterMonitor_Insn(?i) .
isMonitorInstruction(?i) :- isExitMonitor_Insn(?i).

isFieldInstruction(?i) :-   isLoadInstanceField_Insn(?i) .
isFieldInstruction(?i) :- isStoreInstanceField_Insn(?i).
isFieldInstruction(?i) :-  isLoadStaticField_Insn(?i) .
isFieldInstruction(?i) :- isStoreStaticField_Insn(?i).

isArrayInstruction(?i) :- isLoadArrayIndex_Insn(?i) .
isArrayInstruction(?i)  :- isStoreArrayIndex_Insn(?i).

isAssignInstruction(?i) :- isAssignOper_Insn(?i) .
isAssignInstruction(?i) :- isAssignInstanceOf_Insn(?i).
isAssignInstruction(?i) :- isAssignNull_Insn(?i).
isAssignInstruction(?i) :- isAssignNumConstant_Insn(?i) .
isAssignInstruction(?i) :- isAssignCast_Insn(?i).
isAssignInstruction(?i) :- isAssignHeapAllocation_Insn(?i).

isAssignOper_Insn(?i) :-   isAssignBinop_Insn(?i) .
isAssignOper_Insn(?i) :- isAssignUnop_Insn(?i).
isAssignOper_Insn(?i) :- isAssignLocal_Insn(?i).
isAssignCast_Insn(?i) :- isAssignCastNumConstant_Insn(?i). 
isAssignOper_Insn(?i) :- isAssignCastNull_Insn(?i).

isReturnInstruction(?i) :- isReturnVoid_Insn(?i) .
isReturnInstruction(?i) :- isReturnNonvoid_Insn(?i).

isMethodInvocation(?i) :-   isVirtualMethodInvocation_Insn(?i) .
isMethodInvocation(?i) :- isSpecialMethodInvocation_Insn(?i).
isMethodInvocation(?i) :- isStaticMethodInvocation_Insn(?i).
isMethodInvocation(?i) :- isSuperMethodInvocation_Insn(?i).
isMethodInvocation(?i) :- isDynamicMethodInvocation_Insn(?i).

isUnsupportedInstruction(?i) :- isAssignPhantomInvoke(?i) .
isUnsupportedInstruction(?i):- isBreakpointStmt(?i).


isClassType(?class) :- A_ClassType(?class).

isArrayType(?arrayType) :- A_ArrayType(?arrayType).

isInterfaceType(?interface) :- A_InterfaceType(?interface).

isArrayType(?arrayType),
isType(?componentType),
ComponentType(?arrayType, ?componentType) :-
  A_ComponentType(?arrayType, ?componentType).

isMethodInvocation(?invocation),
isVar(?var),
ActualParam(?index, ?invocation, ?var) :-
  A_ActualParam(?index, ?invocation, ?var).


isDynamicMethodInvocation_Insn(?invocation),
isVar(?var),
BootstrapParam(?index, ?invocation, ?var) :-
  A_BootstrapParam(?index, ?invocation, ?var).


isReferenceType(?class),
isInterfaceType(?interface),
DirectSuperinterface(?class, ?interface) :-
  A_DirectSuperinterface(?class, ?interface).

isClassType(?class),
isClassType(?superclass),
DirectSuperclass(?class, ?superclass) :-
  A_DirectSuperclass(?class, ?superclass).

isModifier(?modifier),
isField(?field),
Field_Modifier(?modifier, ?field) :-
  A_Field_Modifier(?modifier, ?field).

ClassModifier(?modifier, ?class) :-
  A_ClassModifier(?modifier, ?class).

isMethod(?method),
isVar(?var),
FormalParam(?index, ?method, ?var) :-
  A_FormalParam(?index, ?method, ?var).

isReferenceType(?exceptionType),
isMethod(?method),
Method_DeclaresException(?exceptionType, ?method) :-
  A_Method_DeclaresException(?exceptionType, ?method).

isModifier(?mod),
isMethod(?method),
Method_Modifier(?mod, ?method) :-
  A_Method_Modifier(?mod, ?method).

isVar(?var),
isMethod(?method),
NativeReturnVar(?var, ?method) :-
  A_NativeReturnVar(?var, ?method).

isVar(?var),
isType(?type),
Var_Type(?var, ?type) :-
  A_Var_Type(?var, ?type).

isVar(?var),
isMethod(?method),
Var_DeclaringMethod(?var, ?method) :-
  A_Var_DeclaringMethod(?var, ?method).

isVar(?var),
Var_SimpleName(?var, ?simplename) :-
  A_Var_SimpleName(?var, ?simplename).

isReferenceType(?type),
ApplicationClass(?type) :-
  A_ApplicationClass(?type).
  


isMethod(?method),
isVar(?var),
ThisVar(?method, ?var) :-
  A_ThisVar(?method, ?var).

isExceptionHandler(?handler),
isExceptionHandler(?previous),
ExceptionHandler_Previous(?handler, ?previous) :-
  A_ExceptionHandler_Previous(?handler, ?previous).

isMethodInvocation(?invocation),
isVar(?to),
AssignReturnValue(?invocation, ?to) :-
  A_AssignReturnValue(?invocation, ?to).
  

MainClass(?b):-
  A_ClassModifier(_,?b),
  MainClass(?a),
  true(CONTAINS(?a,?b)).



isType(?type),
isNormalHeap(?id),
OriginalHeapAllocation_Type(?id, ?type),
HeapAllocation_Type(?id, ?type) :-
  A_NormalHeap(?id, ?type).

isClassType("java.lang.String").

isStringConstant(?id),
OriginalHeapAllocation_Type(?id, "java.lang.String"),
HeapAllocation_Type(?id, "java.lang.String") :-
  A_StringConstant(?id).


isStringRaw(?id),
String_toRaw(?id, ?rawId) :-
  A_StringRaw(?id, ?rawId).

isType(?instanceType),
isClassHeap(?id),
ClassHeap_InstanceType(?id, ?instanceType),
OriginalHeapAllocation_Type(?id, "java.lang.Class"),
HeapAllocation_Type(?id, "java.lang.Class") :-
  A_ClassHeap(?id, ?instanceType).


isType("java.lang.invoke.MethodHandle").
isReferenceType("java.lang.invoke.MethodHandle").
isClassType("java.lang.invoke.MethodHandle").

isMethodHandleConstant(?id),
OriginalHeapAllocation_Type(?id, "java.lang.invoke.MethodHandle"),
MethodHandleConstant_Method(?id, ?method),
MethodHandleConstant_Arity(?id, ?arity),
MethodHandleConstant_ReturnType(?id, ?retType),
MethodHandleConstant_ParamTypes(?id, ?paramTypes),
HeapAllocation_Type(?id, "java.lang.invoke.MethodHandle") :-
  A_MethodHandleConstant(?id, ?method, ?retType, ?paramTypes, ?arity).


isMethodTypeConstant(?id),
HeapAllocation_Type(?id, "java.lang.invoke.MethodType"),
MethodTypeConstant_Arity(?id, ?arity),
MethodTypeConstant_ReturnType(?id, ?retType),
MethodTypeConstant_ParamTypes(?id, ?paramTypes),
OriginalHeapAllocation_Type(?id, "java.lang.invoke.MethodType") :-
  A_MethodTypeConstant(?id, ?arity, ?retType, ?paramTypes).



HeapAllocation_EmptyArray(?id) :-
  A_EmptyArray(?id).


ArrayAllocation(?insn, ?pos, ?sizeVar) :-
  A_ArrayAllocation(?insn, ?pos, ?sizeVar).

isAssignHeapAllocation_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Line(?instruction, ?linenumber),
Instruction_Method(?instruction, ?method),
AssignInstruction_To(?instruction, ?to),
AssignHeapAllocation_Heap(?instruction, ?heap) :-
  A_AssignHeapAllocation(?instruction, ?index, ?heap, ?to, ?method, ?linenumber).

isAssignLocal_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
AssignLocal_From(?instruction, ?from),
AssignInstruction_To(?instruction, ?to) :-
  A_AssignLocal(?instruction, ?index, ?from, ?to, ?method).

isAssignBinop_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
AssignInstruction_To(?instruction, ?to) :-
  A_AssignBinop(?instruction, ?index, ?to, ?method).

isAssignUnop_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
AssignInstruction_To(?instruction, ?to) :-
  A_AssignUnop(?instruction, ?index, ?to, ?method).

AssignOper_From(?instruction, ?pos, ?from) :-
  A_AssignOperFrom(?instruction, ?pos, ?from).


AssignOper_FromConstant(?instruction, ?pos, ?from) :-
  A_AssignOperFromConstant(?instruction, ?pos, ?from).


If_Constant(?instruction, ?pos, ?cons) :-
  A_IfConstant(?instruction, ?pos, ?cons).

If_Var(?instruction, ?pos, ?var) :-
  A_IfVar(?instruction, ?pos, ?var).


DummyIf_Var(?instruction, ?var) :-
  A_DummyIfVar(?instruction, ?var).


isAssignCast_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
AssignCast_Type(?instruction, ?type),
AssignCast_From(?instruction, ?from),
AssignInstruction_To(?instruction, ?to) :-
  A_AssignCast(?instruction, ?index, ?from, ?to, ?type, ?method).

isAssignCastNumConstant_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
AssignCast_Type(?instruction, ?type),
AssignCastNumConstant_Id(?instruction, ?const),
AssignInstruction_To(?instruction, ?to) :-
  A_AssignCastNumConstant(?instruction, ?index, ?const, ?to, ?type, ?method).

isAssignCastNull_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
AssignCast_Type(?instruction, ?type),
AssignInstruction_To(?instruction, ?to) :-
  A_AssignCastNull(?instruction, ?index, ?to, ?type, ?method).

isNumConstant(?const),
isAssignNumConstant_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
AssignNumConstant_Id(?instruction, ?const),
AssignInstruction_To(?instruction, ?to) :-
  A_AssignNumConstant(?instruction, ?index, ?const, ?to, ?method).

isAssignNull_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
AssignInstruction_To(?instruction, ?to) :-
  A_AssignNull(?instruction, ?index, ?to, ?method).

isAssignInstanceOf_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
AssignInstanceOf_From(?instruction, ?from),
AssignInstanceOf_Type(?instruction, ?type),
AssignInstruction_To(?instruction, ?to) :-
  A_AssignInstanceOf(?instruction, ?index, ?from, ?to, ?type, ?method).

isField(?signature),
Field_DeclaringType(?signature, ?declaringType),
Field_SimpleName(?signature, ?simplename),
Field_Type(?signature, ?type) :-
  A_Field(?signature, ?declaringType, ?simplename, ?type).


isEnterMonitor_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
EnterMonitor_Var(?instruction, ?var) :-
  A_EnterMonitor(?instruction, ?index, ?var, ?method).

isExitMonitor_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
ExitMonitor_Var(?instruction, ?var) :-
  A_ExitMonitor(?instruction, ?index, ?var, ?method).

isMethodInvocation(?instruction),
MethodInvocation_Line(?instruction, ?line) :-
  A_MethodInvocation_Line(?instruction, ?line).

MethodInvocation_Base(?invocation, ?base) :-
  VirtualMethodInvocation_Base(?invocation, ?base).
MethodInvocation_Base(?invocation, ?base) :-
  SpecialMethodInvocation_Base(?invocation, ?base).

isMethod(?signature),
isMethodInvocation(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
MethodInvocation_Method(?instruction, ?signature) :-
  A_StaticMethodInvocation(?instruction, ?index, ?signature, ?method).

isStaticMethodInvocation_Insn(?instruction) :-
  A_StaticMethodInvocation(?instruction, _, ?signature, _),
  ~isOpaqueMethod(?signature).


isMethod(?signature),
isMethodInvocation(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
MethodInvocation_Method(?instruction, ?signature) :-
  A_SpecialMethodInvocation(?instruction, ?index, ?signature, _, ?method).

isSpecialMethodInvocation_Insn(?instruction),
SpecialMethodInvocation_Base(?instruction, ?base) :-
  A_SpecialMethodInvocation(?instruction, _, ?signature, ?base, _),
  ~isOpaqueMethod(?signature).


isMethod(?signature),
isMethodInvocation(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
MethodInvocation_Method(?instruction, ?signature) :-
  A_VirtualMethodInvocation(?instruction, ?index, ?signature, _, ?method).

isVirtualMethodInvocation_Insn(?instruction),
VirtualMethodInvocation_Base(?instruction, ?base) :-
  A_VirtualMethodInvocation(?instruction, _, ?signature, ?base, _),
  ~isOpaqueMethod(?signature).


isMethod(?signature),
isMethodInvocation(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
MethodInvocation_Method(?instruction, ?signature),
isSuperMethodInvocation_Insn(?instruction),
SuperMethodInvocation_Base(?instruction, ?base) :-
  A_SuperMethodInvocation(?instruction, ?index, ?signature, ?base, ?method).


isDynamicMethodInvocation_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
DynamicMethodInvocation_Bootstrap(?instruction, ?bootSignature),
DynamicMethodInvocation_DynName(?instruction, ?dynName),
DynamicMethodInvocation_DynReturnType(?instruction, ?dynRetType),
DynamicMethodInvocation_DynParamTypes(?instruction, ?dynParamTypes),
DynamicMethodInvocation_HandleTag(?instruction, ?tag),
DynamicMethodInvocation_DynArity(?instruction, ?dynArity) :-
  A_DynamicMethodInvocation(?instruction, ?index, ?bootSignature, ?dynName, ?dynRetType, ?dynArity, ?dynParamTypes, ?tag, ?method).
  


isThrow_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
Throw(?instruction, ?var),
Throw_Var(?instruction, ?var) :-
  A_Throw(?instruction, ?index, ?var, ?method).

isThrowNull_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method) :-
  A_ThrowNull(?instruction, ?index, ?method).

isExceptionHandler(?handler),
isInstruction(?handler),
Instruction_Index(?handler, ?index),
Instruction_Method(?handler, ?method),
ExceptionHandler_Method(?handler, ?method),
ExceptionHandler_Index(?handler, ?index),
ExceptionHandler_Type(?handler, ?type),
ExceptionHandler_Begin(?handler, ?begin),
ExceptionHandler_End(?handler, ?end) :-
  A_ExceptionHandler(?handler, ?method, ?index, ?type, ?begin, ?end).

isMethod(?method),
isJVMDescriptor(?jvmDescriptor),
Method_SimpleName(?method, ?simplename),
Method_ParamTypes(?method, ?params),
Method_DeclaringType(?method, ?declaringType),
Method_JVMDescriptor(?method, ?jvmDescriptor),
Method_Arity(?method, ?arity),
Method_ReturnType(?method, ?returnType) :-
  A_Method(?method, ?simplename, ?params, ?declaringType, ?returnType, ?jvmDescriptor, ?arity).

%Method_Descriptor(?method, ?descriptor) :-
%  Method_ReturnType(?method, ?returnType),
%  Method_ParamTypes(?method, ?params),
%  ?descriptor = CONCAT(?returnType, "(", ?params, ")").


isStoreInstanceField_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
FieldInstruction_Signature(?instruction, ?signature),
StoreInstanceField_Base(?instruction, ?base),
StoreInstanceField_From(?instruction, ?from) :-
  A_StoreInstanceField(?instruction, ?index, ?from, ?base, ?signature, ?method).

isLoadInstanceField_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
FieldInstruction_Signature(?instruction, ?signature),
LoadInstanceField_Base(?instruction, ?base),
LoadInstanceField_To(?instruction, ?to) :-
  A_LoadInstanceField(?instruction, ?index, ?to, ?base, ?signature, ?method).

isStoreStaticField_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
FieldInstruction_Signature(?instruction, ?signature),
StoreStaticField_From(?instruction, ?from) :-
  A_StoreStaticField(?instruction, ?index, ?from, ?signature, ?method).

isLoadStaticField_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
FieldInstruction_Signature(?instruction, ?signature),
LoadStaticField_To(?instruction, ?to) :-
  A_LoadStaticField(?instruction, ?index, ?to, ?signature, ?method).

isStoreArrayIndex_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
StoreArrayIndex_Base(?instruction, ?base),
StoreArrayIndex_From(?instruction, ?from) :-
  A_StoreArrayIndex(?instruction, ?index, ?from, ?base, ?method).

isLoadArrayIndex_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
LoadArrayIndex_Base(?instruction, ?base),
LoadArrayIndex_To(?instruction, ?to) :-
  A_LoadArrayIndex(?instruction, ?index, ?to, ?base, ?method).

ArrayInsnIndex(?instruction, ?index) :-
  A_ArrayInsnIndex(?instruction, ?index).

ArrayNumIndex(?instruction, ?index) :-
  A_ArrayNumIndex(?instruction, ?index).

isGoto_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
Goto_Target(?instruction, ?to) :-
  A_Goto(?instruction, ?index, ?to, ?method).

isIf_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
If_Target(?instruction, ?to) :-
  A_If(?instruction, ?index, ?to, ?method).

isTableSwitch_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
Switch_Key(?instruction, ?key) :-
  A_TableSwitch(?instruction, ?index, ?key, ?method).

isLookupSwitch_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
Switch_Key(?instruction, ?key) :-
  A_LookupSwitch(?instruction, ?index, ?key, ?method).

Switch_Target(?instruction, ?value, ?target) :-
  A_TableSwitch_Target(?instruction, ?value, ?target).

Switch_Target(?instruction, ?value, ?target) :-
  A_LookupSwitch_Target(?instruction, ?value, ?target).


Switch_DefaultTarget(?instruction, ?target) :-
  A_TableSwitch_Default(?instruction, ?target).

Switch_DefaultTarget(?instruction, ?target) :-
  A_LookupSwitch_Default(?instruction, ?target).

isReturnNonvoid_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method),
ReturnNonvoid_Var(?instruction, ?var) :-
  A_Return(?instruction, ?index, ?var, ?method).

isReturnVoid_Insn(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method) :-
  A_ReturnVoid(?instruction, ?index, ?method).

isAssignPhantomInvoke(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method) :-
  A_AssignPhantomInvoke(?instruction, ?index, ?method).

isBreakpointStmt(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method) :-
  A_BreakpointStmt(?instruction, ?index, ?method).

isUnsupportedInstruction(?instruction),
Instruction_Index(?instruction, ?index),
Instruction_Method(?instruction, ?method) :-
  A_UnsupportedInstruction(?instruction, ?index, ?method).


isModifier(?x), Modifier_abstract(?x) :- ?x = "abstract".
isModifier(?x), Modifier_public(?x) :- ?x = "public".
isModifier(?x), Modifier_private(?x) :- ?x = "private".
isModifier(?x), Modifier_final(?x) :- ?x = "final".
isModifier(?x), Modifier_static(?x) :- ?x = "static".


isPrimitiveType(?t), Type_boolean(?t) :- ?t = "boolean".
isPrimitiveType(?t), Type_byte(?t) :- ?t = "byte".
isPrimitiveType(?t), Type_char(?t) :- ?t = "char".
isPrimitiveType(?t), Type_short(?t) :- ?t = "short".
isPrimitiveType(?t), Type_int(?t) :- ?t = "int".
isPrimitiveType(?t), Type_long(?t) :- ?t = "long".
isPrimitiveType(?t), Type_float(?t) :- ?t = "float".
isPrimitiveType(?t), Type_double(?t) :- ?t = "double".
isPrimitiveType(?t), Type_void(?t) :- ?t = "void".

isNullType(?t), Type_null(?t) :- ?t = "null_type".

isClassType(?t), Type_object(?t) :- ?t = "java.lang.Object".


isAnnotation(?annotation) :- isReferenceType(?annotation), A_Type_Annotation(_, ?annotation).
isAnnotation(?annotation) :- isReferenceType(?annotation), A_Method_Annotation(_, ?annotation).
isAnnotation(?annotation) :- isReferenceType(?annotation), A_Field_Annotation(_, ?annotation).
isAnnotation(?annotation) :- isReferenceType(?annotation), A_Param_Annotation(_, _, ?annotation).


isHeapAllocation(?heap), isMethodHandleConstant(?heap), MethodHandleConstant_Method(?heap, ?method), HeapAllocation_Type(?heap, "java.lang.invoke.MethodHandle")  :-
  MethodHandleConstant_Method(?heap, ?method).

isHeapAllocation(?null), HeapAllocation_Type(?null, ?type) ,
HeapAllocation_Null(?null) :-
  ?null = "<<null pseudo heap>>",
  Type_null(?type).

isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type) ,
MainMethodArgArray(?heap) :-
  ?heap = "<<main method array>>",
  ?type = "java.lang.String[]".

isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type) ,
MainMethodArgArrayContent(?heap) :-
  ?heap = "<<main method array content>>",
  ?type = "java.lang.String".

ApplicationField(?field) :-
  Field_DeclaringType(?field, ?type),
  ApplicationClass(?type).

ApplicationMethod(?method) :-
  Method_DeclaringType(?method, ?class),
  ApplicationClass(?class).

ApplicationVar(?var) :-
  Var_DeclaringMethod(?var, ?method),
  ApplicationMethod(?method).

ApplicationInvocation(?invocation) :-
  isMethodInvocation(?invocation),
  Instruction_Method(?invocation, ?method),
  ApplicationMethod(?method).

ApplicationAllocation(?heap) :-
  isAssignHeapAllocation_Insn(?insn),
  Instruction_Method(?insn, ?method),
  ApplicationMethod(?method),
  AssignHeapAllocation_Heap(?insn, ?heap).

ConcreteClass(?class) :-
  isClassType(?class),
  ~ClassModifier("abstract", ?class).

isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type)  :-
  ?heap = "<java.io.UnixFileSystem: java.lang.String[] list(java.io.File)>/new java.lang.String[]/0",
  ?type = "java.lang.String[]".

isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type)  :-
  ?heap = "<java.io.UnixFileSystem: java.lang.String[] list(java.io.File)>/new java.lang.String/0",
  ?type = "java.lang.String".

isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type)  :-
  ?heap = "<sun.misc.Perf: java.nio.ByteBuffer createLong(java.lang.String,int,int,long)>/new java.nio.DirectByteBuffer/0",
  ?type = "java.nio.DirectByteBuffer".


isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type)  :-
  ?heap = "<<string-constant>>",
  ?type = "java.lang.String".

isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type)  :-
  ?heap = "<<reflection-string-constant>>",
  ?type = "java.lang.String".

isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type)  :-
  ?heap = "<<string-buffer>>",
  ?type = "java.lang.StringBuffer".

isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type)  :-
  ?heap = "<<string-builder>>",
  ?type = "java.lang.StringBuilder".

isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type)  :-
  ?heap = "<<system-thread-group>>",
  ?type = "java.lang.ThreadGroup".

isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type)  :-
  ?heap = "<<main-thread-group>>",
  ?type = "java.lang.ThreadGroup".

isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type)  :-
  ?heap = "<<main-thread>>",
  ?type = "java.lang.Thread".

isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type)  :-
  ?heap = "<<initial-context>>",
  ?type = "java.lang.Object".

isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type)  :-
  ?heap = "<<jvm-startup-context>>",
  ?type = "java.lang.Object".

isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type)  :-
  ?heap = "<<jvm-startup-hcontext>>",
  ?type = "java.lang.Object".

isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type)  :-
  ?heap = "<<clinit-context>>",
  ?type = "java.lang.Object".

isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type)  :-
  ?heap = "<<immutable-context>>",
  ?type = "java.lang.Object".

isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type)  :-
  ?heap = "<<immutable-hcontext>>",
  ?type = "java.lang.Object".

isHeapAllocation(?heap), HeapAllocation_Type(?heap, ?type)  :-
  ?heap = "<<immutable>>",
  ?type = "java.lang.Object".


% CFG

Method_FirstInstruction(?method, ?insn) :-
   Instruction_Method(?insn, ?method),
   ~Instruction_Prev(?insn, _),
   ~IsJumpTarget(?insn),
   ~A_Throw(?insn, _, _, ?method).

OptInstructionFromMethodIndex(?method, ?index, ?insn) :-
   Instruction_Method(?insn, ?method),
   Instruction_Index(?insn, ?index).

Instruction_Next(?insn, ?next) :-
   Instruction_Method(?insn, ?inMethod),
   Instruction_Index(?insn, ?i),
   OptInstructionFromMethodIndex(?inMethod, ?i + 1, ?next).

Instruction_Prev(?insn, ?prev) :-
   Instruction_Method(?insn, ?inMethod),
   Instruction_Index(?insn, ?i),
   OptInstructionFromMethodIndex(?inMethod, ?i - 1, ?prev).

JumpTarget(?insn, ?goto) :-
   Goto_Target(?goto, ?targetIndex),
   Instruction_Method(?goto, ?gotoMethod),
   OptInstructionFromMethodIndex(?gotoMethod, ?targetIndex, ?insn).
JumpTarget(?insn, ?if) :-
   If_Target(?if, ?targetIndex),
   Instruction_Method(?if, ?method),
   OptInstructionFromMethodIndex(?method, ?targetIndex, ?insn).

JumpTarget(?insn, ?sw) :-
   Switch_Target(?sw, _, ?targetIndex),
   Instruction_Method(?sw, ?method),
   OptInstructionFromMethodIndex(?method, ?targetIndex, ?insn).

JumpTarget(?insn, ?sw) :-
   Switch_DefaultTarget(?sw, ?targetIndex),
   Instruction_Method(?sw, ?method),
   OptInstructionFromMethodIndex(?method, ?targetIndex, ?insn).

IsJumpTarget(?insn) :-
   JumpTarget(?insn, _).

ExceptionHandlerFirstInstruction(?insn) :-
   ExceptionHandler_Index(?handler, ?index),
   ExceptionHandler_Method(?handler, ?method),
   OptInstructionFromMethodIndex(?method, ?index, ?insn).

FallThrough(?insn) :-
   isIf_Insn(?if),
   Instruction_Next(?if, ?insn).
% REVIEW: The next two shouldn't matter much since without a label the
% fallthrough instruction would be dead code OR the beginning of an
% exception handler. The latter is handled specially. For the former, we
% consider such dead code to start a new BB, so that it doesn't accidentally
% get considered a continuation of the previous BB.
FallThrough(?insn) :-
   isReturnInstruction(?ret),
   Instruction_Next(?ret, ?insn).
FallThrough(?insn) :-
   isThrow_Insn(?throw),
   Instruction_Next(?throw, ?insn).


% First instruction of a method is a basic block beginning
BasicBlockBegin(?insn) :-
   OptInstructionFromMethodIndex(_, 1, ?insn).
BasicBlockBegin(?insn) :-
   ExceptionHandlerFirstInstruction(?insn).
BasicBlockBegin(?insn) :-
   JumpTarget(?insn, _).
BasicBlockBegin(?insn) :-
   FallThrough(?insn).

NextInSameBasicBlock(?insn, ?next) :-
   Instruction_Next(?insn, ?next),
   ~BasicBlockBegin(?next).

PrevInSameBasicBlock(?insn, ?prev) :-
   NextInSameBasicBlock(?prev, ?insn).

BasicBlockHead(?insn, ?insn) :-
   BasicBlockBegin(?insn).
BasicBlockHead(?insn, ?headInsn) :-
   BasicBlockHead(?prev, ?headInsn),
   NextInSameBasicBlock(?prev, ?insn).

BasicBlockTail(?headInsn, ?tailInsn) :-
   BasicBlockHead(?tailInsn, ?headInsn),
   ~NextInSameBasicBlock(?tailInsn, _).

BasicBlockEnd(?insn) :- BasicBlockTail(_, ?insn).

UnconditionalControlTransfer(?insn) :-
   isGoto_Insn(?insn).

UnconditionalControlTransfer(?insn) :-
   isSwitch_Insn(?insn).
UnconditionalControlTransfer(?insn) :-
   isReturnInstruction(?insn).
UnconditionalControlTransfer(?insn) :-
   isThrow_Insn(?insn).

MaySuccessorModuloThrow(?next, ?prev) :-
   JumpTarget(?next, ?prev).
MaySuccessorModuloThrow(?next, ?insn) :-
   Instruction_Next(?insn, ?next),
   ~UnconditionalControlTransfer(?insn).

MayPredecessorModuloThrow(?prev, ?next) :-
   MaySuccessorModuloThrow(?next, ?prev).

MaySuccessorBBModuloThrow(?next, ?prev) :-
   MaySuccessorModuloThrow(?next, ?prevEnd),
   BasicBlockEnd(?prevEnd),
   BasicBlockBegin(?next),
   BasicBlockHead(?prevEnd, ?prev).

MayPredecessorBBModuloThrow(?prev, ?next) :-
   MaySuccessorBBModuloThrow(?next, ?prev).

% The Dominates relation is defined on basic blocks,
% represented by their first instruction (head). Defining
% a dense quadratic relation, like Dominates, on individual
% instructions was hugely expensive.

% Dominates(?dominator, ?insn): To get to ?insn, we need to have gone
% through ?dominator
Dominates(?dominator, ?insn) :-
   SameMethodBBHeads(?dominator, ?insn),
   ~DoesNotDominate(?dominator, ?insn).

% Either the first instruction...
CFGRoot(?insn, ?method) :-
   OptInstructionFromMethodIndex(?method, 1, ?insn).

% or... could also be beginning of exception handler
CFGRoot(?insn, ?method) :-
   BBHeadInMethod(?insn, ?method),
   ~MayPredecessorBBModuloThrow(_, ?insn).

ExistsMayPredecessorBBModuloThrow(?insn) :-
   MayPredecessorBBModuloThrow(_, ?insn).

% DoesNotDominate(?dominatorCandidate, ?insn): ?insn (which is a
% basic block head) is NOT dominated by ?dominatorCandidate
DoesNotDominate(?dominatorCandidate, ?insn) :-
   BBHeadInMethod(?dominatorCandidate, ?method),
   CFGRoot(?insn, ?method),
   ?dominatorCandidate != ?insn.

DoesNotDominate(?dominatorCandidate, ?insn) :-
   DoesNotDominate(?dominatorCandidate, ?otherInsn),
   MaySuccessorBBModuloThrow(?insn, ?otherInsn),
   ?insn != ?dominatorCandidate.


% ?insn dominates its predecessor. ?insn must be the head of a basic
% block (head of a loop).
DominatesItsPredecessorInstruction(?prevInsn, ?insn) :-
   JumpTarget(?insn, ?prevInsn),
   BasicBlockHead(?prevInsn, ?prevInsnHead),
   ?insn = ?prevInsnHead.

DominatesItsPredecessorInstruction(?prevInsn, ?insn) :-
   JumpTarget(?insn, ?prevInsn),
   BasicBlockHead(?prevInsn, ?prevInsnHead),
    Dominates(?insn, ?prevInsnHead).

% KF: Currently this rules is not being used at all.
% % Includes the case of both being in the same basic block.
% DominatesItsSuccessorInstruction(?insn, ?prevInsn) :-
%    MaySuccessorModuloThrow(?insn, ?prevInsn),
%    BasicBlockHead[?prevInsn] = ?prevInsnHead,
%    BasicBlockHead[?insn] = ?insnHead,
%    (?insnHead = ?prevInsnHead;
%     Dominates(?prevInsnHead, ?insnHead)).


NextInSamePhiNode(?insn, ?nextInsn) :-
   isAssignLocal_Insn(?insn),
   AssignInstruction_To(?insn, ?var),
   Instruction_Next(?insn, ?nextInsn),
   isAssignLocal_Insn(?nextInsn),
   AssignInstruction_To(?nextInsn, ?var).

PhiNodeHead(?nextInsn, ?insn),
PhiNodeHead(?insn, ?insn) :-
   NextInSamePhiNode(?insn, ?nextInsn),
   Instruction_Prev(?insn, ?prevInsn),
   ~NextInSamePhiNode(?prevInsn, ?insn).

PhiNodeHead(?nextInsn, ?insn),
PhiNodeHead(?insn, ?insn) :-
   NextInSamePhiNode(?insn, ?nextInsn),
   ~Instruction_Prev(?insn, _).

PhiNodeHead(?nextInsn, ?headInsn) :-
   PhiNodeHead(?phiInsn, ?headInsn),
   NextInSamePhiNode(?phiInsn, ?nextInsn).

% Just inverting for efficiency.
InstructionInPhiNode(?insn, ?headInsn) :-
   PhiNodeHead(?insn, ?headInsn).


%/ auxiliary quick-and-dirty predicates
OptReturnInsn(?insn, ?method) :-
   isReturnInstruction(?insn),
   Instruction_Method(?insn, ?method).

HigherReturnIndex(?insn, ?indexHigher) :-
   OptReturnInsn(?insn, ?method),
   OptReturnInsn(?insnHigher, ?method),
   Instruction_Index(?insnHigher, ?indexHigher),
   Instruction_Index(?insn, ?index).
%  ?index < ?indexHigher.


NextReturnIndex(?returnInsn, #min(?index)) :-
   isInstruction(?returnInsn), 
   HigherReturnIndex(?returnInsn, ?index).

NextReturn(?returnInsn, ?nextReturnInsn) :-
   NextReturnIndex(?returnInsn, ?nextReturnIndex),
   Instruction_Method(?returnInsn, ?meth),
   OptInstructionFromMethodIndex(?meth, ?nextReturnIndex, ?nextReturnInsn).

ExistsPreviousReturn(?insn) :-
   NextReturn(_, ?insn).

BBHeadInMethod(?insn, ?method) :-
   BasicBlockBegin(?insn),
   Instruction_Method(?insn, ?method).

SameMethodBBHeads(?insn1, ?insn2) :-
   BBHeadInMethod(?insn1, ?method),
   BBHeadInMethod(?insn2, ?method).

% Auxiliaries...

% Quadratic, but doesn't matter, since it's so local and only
% defined on basic blocks.
PredecessorBBsToSameBB(?insn, ?prev1, ?prev2) :-
   MayPredecessorBBModuloThrow(?prev1, ?insn),
   MayPredecessorBBModuloThrow(?prev2, ?insn),
   ?prev1 != ?prev2.

LargerPredecessorIndexToSameBB(?insn, ?indexLarge, ?prevSmall) :-
   PredecessorBBsToSameBB(?insn, ?prevLarge, ?prevSmall),
   Instruction_Index(?prevLarge, ?indexLarge),
   Instruction_Index(?prevSmall, ?indexSmall).
%   ?indexLarge > ?indexSmall.

%NextPredecessorIndexToSameBB(?insn, ?prev, ?indexNext) :-
%   LargerPredecessorIndexToSameBB(?insn, _, ?prev),
%   ?indexNext = min ?index : LargerPredecessorIndexToSameBB(?insn, ?index, ?prev).

% may not return same result 
NextPredecessorIndexToSameBB(?insn, ?prev, #min(?index)) :-
   LargerPredecessorIndexToSameBB(?insn, _, ?prev),
   LargerPredecessorIndexToSameBB(?insn, ?index, ?prev).


NextPredecessorToSameBB(?insn, ?pred, ?nextPred) :-
   NextPredecessorIndexToSameBB(?insn, ?pred, ?indexNext),
   Instruction_Method(?insn, ?method),
   OptInstructionFromMethodIndex(?method, ?indexNext, ?nextPred).

PreviousPredecessorToSameB(?insn, ?nextPred, ?prevPred) :-
   NextPredecessorToSameBB(?insn, ?prevPred, ?nextPred).

ExistsPreviousPredecessorToSameBB(?pred, ?insn) :-
   NextPredecessorToSameBB(?insn, _, ?pred).


% Same concepts as above, but for non-dominated (shortened to "NonDom")
% predecessors
NonDomPredecessorBBsToSameBB(?insn, ?prev1, ?prev2) :-   
   MayPredecessorBBModuloThrow(?prev1, ?insn),
   MayPredecessorBBModuloThrow(?prev2, ?insn),
   BasicBlockTail(?prev1, ?prevTail1),
   BasicBlockTail(?prev2, ?prevTail2),
   ~DominatesItsPredecessorInstruction(?prevTail1, ?insn),
   ~DominatesItsPredecessorInstruction(?prevTail2, ?insn),
   ?prev1 != ?prev2.

LargerNonDomPredecessorIndexToSameBB(?insn, ?indexLarge, ?prevSmall) :-
   NonDomPredecessorBBsToSameBB(?insn, ?prevLarge, ?prevSmall),
   Instruction_Index(?prevLarge, ?indexLarge),
   Instruction_Index(?prevSmall, ?indexSmall).
%   ?indexLarge > ?indexSmall.

NextNonDomPredecessorIndexToSameBB(?insn, ?prev, #min(?index)) :-
   LargerNonDomPredecessorIndexToSameBB(?insn, _, ?prev),
   LargerNonDomPredecessorIndexToSameBB(?insn, ?index, ?prev).

NextNonDomPredecessorToSameBB(?insn, ?pred, ?nextPred) :-
   NextNonDomPredecessorIndexToSameBB(?insn, ?pred, ?indexNext),
   Instruction_Method(?insn, ?method),
   OptInstructionFromMethodIndex(?method, ?indexNext, ?nextPred).

PreviousNonDomPredecessorToSameBB(?insn, ?nextPred, ?prevPred) :-
   NextNonDomPredecessorToSameBB(?insn, ?prevPred, ?nextPred).

ExistsPreviousNonDomPredecessorToSameBB(?pred, ?insn) :-
   NextNonDomPredecessorToSameBB(?insn, _, ?pred).

@export Method_ReturnType :-tsv{resource="Method_ReturnType.tsv",format=(string,string)}.
@export Method_ParamTypes :-tsv{resource="Method_ParamTypes.tsv",format=(string,string)}.
@export Method_Descriptor :- tsv{resource="Method_Descriptor.csv",format=(string,string)}.
@export Instruction_Method :- tsv{resource="Instruction_Method.csv",format=(string, string)} .
@export Instruction_Index :- tsv{resource="Instruction_Index.csv",format=(string, int)} .
@export isReturnInstruction :- tsv{resource="isReturnInstruction.csv",format=(string)} .
@export isAssignLocal_Insn :- tsv{resource="isAssignLocal_Insn.csv",format=(string)} .
@export isThrow_Insn :- tsv{resource="isThrow_Insn.csv",format=(string)} .
@export isSwitch_Insn :- tsv{resource="isSwitch_Insn.csv",format=(string)} .
@export isGoto_Insn :- tsv{resource="isGoto_Insn.csv",format=(string)} .
@export ExceptionHandler_Method :- tsv{resource="ExceptionHandler_Method.csv",format=(string, string)} .
@export ExceptionHandler_Index :- tsv{resource="ExceptionHandler_Index.csv",format=(string, int)} .
@export Switch_Target :- tsv{resource="Switch_Target.csv",format=(string, int, int)} .
@export If_Target :- tsv{resource="If_Target.csv",format=(string, int)} .
@export Goto_Target :- tsv{resource="Goto_Target.csv",format=(string, int)} .
@export isInstruction :- tsv{resource="isInstruction.csv",format=(string)} .
@export isIf_Insn :- tsv{resource="isIf_Insn.csv",format=(string)} .
@export Switch_DefaultTarget :- tsv{resource="Switch_DefaultTarget.csv",format=(string, int)} .
@export AssignInstruction_To :- tsv{resource="AssignInstruction_To.csv",format=(string, string)} .
@export A_ArrayType :-tsv{resource="ArrayType.tsv",format=(string)} .
@export A_ActualParam :-tsv{resource="ActualParam.tsv",format=(int,string,string)} .
@export A_Var_Type :-tsv{resource="Var-Type.tsv",format=(string,string )} .
@export A_Var_DeclaringMethod :-tsv{resource="Var-DeclaringMethod.tsv",format=(string,string)} .
@export A_Var_SimpleName :-tsv{resource="Var-SimpleName.tsv",format=(string,string)} .
@export A_ApplicationClass :-tsv{resource="ApplicationClass.tsv",format=(string )} .
@export A_ApplicationPackage :-tsv{resource="ApplicationPackage.tsv",format=(string)} .
@export A_ExceptionHandler_Previous :-tsv{resource="ExceptionHandler-Previous.tsv",format=(string,string)} .
@export A_ArrayAllocation :-tsv{resource="ArrayAllocation.tsv",format=(string,int,string)} .
@export A_ArrayInsnIndex :-tsv{resource="ArrayInsnIndex.tsv",format=(string,string)} .
@export A_Type_Annotation :-tsv{resource="Type-Annotation.tsv",format=(string,string)} .
@export A_Method_Annotation :-tsv{resource="Method-Annotation.tsv",format=(string,string)} .
@export A_Field_Annotation :-tsv{resource="Field-Annotation.tsv",format=(string,string)} .
@export A_Param_Annotation :-tsv{resource="Param-Annotation.tsv",format=(string,int,string)} .
@export A_AssignBinop :- tsv{resource="AssignBinop.tsv", format=(string, int, string, string)} .
@export A_AssignCast :- tsv{resource="AssignCast.tsv", format=(string, int, string, string, string, string)} .
@export A_AssignCastNull :- tsv{resource="AssignCastNull.tsv", format=(string, int, string, string, string)} .
@export A_AssignCastNumConstant :- tsv{resource="AssignCastNumConstant.tsv", format=(string, int, string, string, string, string)} .
@export A_AssignHeapAllocation :- tsv{resource="AssignHeapAllocation.tsv", format=(string, int, string, string, string, int)} .
@export A_AssignInstanceOf :- tsv{resource="AssignInstanceOf.tsv", format=(string, int, string, string, string, string)} .
@export A_AssignLocal :- tsv{resource="AssignLocal.tsv", format=(string, int, string, string, string)} .
@export A_AssignNull :- tsv{resource="AssignNull.tsv", format=(string, int, string, string)} .
@export A_AssignNumConstant :- tsv{resource="AssignNumConstant.tsv", format=(string, int, string, string, string)} .
@export A_AssignOperFrom :- tsv{resource="AssignOperFrom.tsv", format=(string, int, string)} .
@export A_AssignOperFromConstant :- tsv{resource="AssignOperFromConstant.tsv", format=(string, int, any)} .
@export A_AssignPhantomInvoke :- tsv{resource="AssignPhantomInvoke.tsv", format=(string, int, string)} .
@export A_AssignReturnValue :- tsv{resource="AssignReturnValue.tsv", format=(string, string)} .
@export A_AssignUnop :- tsv{resource="AssignUnop.tsv", format=(string, int, string, string)} .
@export A_BootstrapParam :- tsv{resource="BootstrapParam.tsv", format=(int, string, string)} .
@export A_BreakpointStmt :- tsv{resource="BreakpointStmt.tsv", format=(string, int, string)} .
@export A_ClassArtifact :- tsv{resource="Class-Artifact.tsv", format=(string, string, string, int)} .
@export A_ClassHeap :- tsv{resource="ClassHeap.tsv", format=(string, string)} .
@export A_ClassModifier :- tsv{resource="ClassModifier.tsv", format=(string, string)} .
@export A_ClassType :- tsv{resource="ClassType.tsv", format=(string)} .
@export A_ComponentType :- tsv{resource="ComponentType.tsv", format=(string, string)} .
@export A_DirectSuperclass :- tsv{resource="DirectSuperclass.tsv", format=(string, string)} .
@export A_DirectSuperinterface :- tsv{resource="DirectSuperinterface.tsv", format=(string, string)} .
@export A_DummyIfVar :- tsv{resource="DummyIfVar.tsv", format=(string, string)} .
@export A_DynamicMethodInvocation :- tsv{resource="DynamicMethodInvocation.tsv", format=(string, int, string, string, string, int, string,int, string)} .
@export A_EmptyArray :- tsv{resource="EmptyArray.tsv", format=(string)} .
@export A_EnterMonitor :- tsv{resource="EnterMonitor.tsv", format=(string, int, string, string)} .
@export A_ExceptionHandler :- tsv{resource="ExceptionHandler.tsv", format=(string, string, int, string, int, int)} .
@export A_ExitMonitor :- tsv{resource="ExitMonitor.tsv", format=(string, int, string, string)} .
@export A_Field :- tsv{resource="Field.tsv", format=(string, string, string, string)} .
@export A_Field_Modifier :- tsv{resource="Field-Modifier.tsv", format=(string, string)} .
@export A_FormalParam :- tsv{resource="FormalParam.tsv", format=(int, string, string)} .
@export A_Goto :- tsv{resource="Goto.tsv", format=(string, int, int, string)} .
@export A_If :- tsv{resource="If.tsv", format=(string, int, int, string)} .
@export A_IfConstant :- tsv{resource="IfConstant.tsv", format=(string, int, string)} .
@export A_IfVar :- tsv{resource="IfVar.tsv", format=(string, int, string)} .
@export A_InterfaceType :- tsv{resource="InterfaceType.tsv", format=(string)} .
@export A_LoadArrayIndex :- tsv{resource="LoadArrayIndex.tsv", format=(string, int, string, string, string)} .
@export A_LoadInstanceField :- tsv{resource="LoadInstanceField.tsv", format=(string, int, string, string, string, string)} .
@export A_LoadStaticField :- tsv{resource="LoadStaticField.tsv", format=(string, int, string, string, string)} .
@export A_LookupSwitch :- tsv{resource="LookupSwitch.tsv", format=(string, int, string, string)} .
@export A_LookupSwitch_Default :- tsv{resource="LookupSwitch-Default.tsv", format=(string, int)} .
@export A_LookupSwitch_Target :- tsv{resource="LookupSwitch-Target.tsv", format=(string, int, int)} .
@export A_Method :- tsv{resource="Method.tsv", format=(string, string, string, string, string, string, int)} .
@export A_MethodHandleConstant :- tsv{resource="MethodHandleConstant.tsv", format=(string, string, string, string, int)} .
@export A_MethodInvocation_Line :- tsv{resource="MethodInvocation-Line.tsv", format=(string, int)} .
@export A_MethodTypeConstant :- tsv{resource="MethodTypeConstant.tsv", format=(string, int, string, string)} .
@export A_MethodTypeConstantParam :- tsv{resource="MethodTypeConstantParam.tsv", format=(string, int, string)} .
@export A_Method_DeclaresException :- tsv{resource="Method-DeclaresException.tsv", format=(string, string)} .
@export A_Method_Modifier :- tsv{resource="Method-Modifier.tsv", format=(string, string)} .
@export A_NativeLibEntryPoint :- tsv{resource="NativeLibEntryPoint.tsv", format=(string, string, string)} .
@export A_NativeMethodId :- tsv{resource="NativeMethodId.tsv", format=(string, string)} .
@export A_NativeMethodTypeCandidate :- tsv{resource="NativeMethodTypeCandidate.tsv", format=(string, string, string, int)} .
@export A_NativeNameCandidate :- tsv{resource="NativeNameCandidate.tsv", format=(string, string, string, int)} .
@export A_NativeReturnVar :- tsv{resource="NativeReturnVar.tsv", format=(string, string)} .
@export A_NativeXRef :- tsv{resource="NativeXRef.tsv", format=(string, string, string, int)} .
@export A_NormalHeap :- tsv{resource="NormalHeap.tsv", format=(string, string)} .
@export A_OperatorAt :- tsv{resource="OperatorAt.tsv", format=(string, string)} .
@export A_Return :- tsv{resource="Return.tsv", format=(string, int, string, string)} .
@export A_ReturnVoid :- tsv{resource="ReturnVoid.tsv", format=(string, int, string)} .
@export A_SpecialMethodInvocation :- tsv{resource="SpecialMethodInvocation.tsv", format=(string, int, string, string, string)} .
@export A_StaticMethodInvocation :- tsv{resource="StaticMethodInvocation.tsv", format=(string, int, string, string)} .
@export A_StoreArrayIndex :- tsv{resource="StoreArrayIndex.tsv", format=(string, int, string, string, string)} .
@export A_StoreInstanceField :- tsv{resource="StoreInstanceField.tsv", format=(string, int, string, string, string, string)} .
@export A_StoreStaticField :- tsv{resource="StoreStaticField.tsv", format=(string, int, string, string, string)} .
@export A_StringConstant :- tsv{resource="StringConstant.tsv", format=(string)} .
@export A_StringRaw :- tsv{resource="StringRaw.tsv", format=(string, string)} .
@export A_SuperMethodInvocation :- tsv{resource="SuperMethodInvocation.tsv", format=(string, int, string, string, string)} .
@export A_TableSwitch :- tsv{resource="TableSwitch.tsv", format=(string, int, string, string)} .
@export A_TableSwitch_Default :- tsv{resource="TableSwitch-Default.tsv", format=(string, int)} .
@export A_TableSwitch_Target :- tsv{resource="TableSwitch-Target.tsv", format=(string, int, int)} .
@export A_ThisVar :- tsv{resource="ThisVar.tsv", format=(string, string)} .
@export A_Throw :- tsv{resource="Throw.tsv", format=(string, int, string, string)} .
@export A_ThrowNull :- tsv{resource="ThrowNull.tsv", format=(string, int, string)} .
@export A_UnsupportedInstruction :- tsv{resource="UnsupportedInstruction.tsv",format=(string,int,string)}.
@export A_VirtualMethodInvocation :- tsv{resource="VirtualMethodInvocation.tsv",format=(string,int,string,string,string)}.

%@export OptInstructionFromMethodIndex :- tsv{resource="OptInstructionFromMethodIndex.tsv",format=(string, int, string)} .
%@export Instruction_Next :- tsv{resource="Instruction_Next.tsv",format=(string, string)} .
%@export Instruction_Prev :- tsv{resource="Instruction_Prev.tsv",format=(string, string)} .
%@export JumpTarget :- tsv{resource="JumpTarget.tsv",format=(string, string)} .
%@export IsJumpTarget :- tsv{resource="IsJumpTarget.tsv",format=(string)} .
%@export ExceptionHandlerFirstInstruction :- tsv{resource="ExceptionHandlerFirstInstruction.tsv",format=(string)} .
%@export FallThrough :- tsv{resource="FallThrough.tsv",format=(string)} .
%@export BasicBlockBegin :- tsv{resource="BasicBlockBegin.tsv",format=(string)} .
%@export BasicBlockHead :- tsv{resource="BasicBlockHead.tsv",format=(string, string)} .
%@export BasicBlockTail :- tsv{resource="BasicBlockTail.tsv",format=(string, string)} .
%@export BasicBlockEnd :- tsv{resource="BasicBlockEnd.tsv",format=(string)} .
%@export UnconditionalControlTransfer :- tsv{resource="UnconditionalControlTransfer.tsv",format=(string)} .
%@export MaySuccessorModuloThrow :- tsv{resource="MaySuccessorModuloThrow.tsv",format=(string, string)} .
%@export MayPredecessorModuloThrow :- tsv{resource="MayPredecessorModuloThrow.tsv",format=(string, string)} .
%@export MaySuccessorBBModuloThrow :- tsv{resource="MaySuccessorBBModuloThrow.tsv",format=(string, string)} .
%@export MayPredecessorBBModuloThrow :- tsv{resource="MayPredecessorBBModuloThrow.tsv",format=(string, string)} .
%@export Dominates :- tsv{resource="Dominates.tsv",format=(string, string)} .
%@export DominatesItsPredecessorInstruction :- tsv{resource="DominatesItsPredecessorInstruction.tsv",format=(string, string)} .
%@export DominatesItsSuccessorInstruction :- tsv{resource="DominatesItsSuccessorInstruction.tsv",format=(string, string)} .
%@export NextInSamePhiNode :- tsv{resource="NextInSamePhiNode.tsv",format=(string, string)} .
%@export PhiNodeHead :- tsv{resource="PhiNodeHead.tsv",format=(string, string)} .
%@export InstructionInPhiNode :- tsv{resource="InstructionInPhiNode.tsv",format=(string, string)} .
%@export NextReturn :- tsv{resource="NextReturn.tsv",format=(string, string)} .
%@export NextInSameBasicBlock :- tsv{resource="NextInSameBasicBlock.tsv",format=(string, string)} .
%@export PrevInSameBasicBlock :- tsv{resource="PrevInSameBasicBlock.tsv",format=(string, string)} .
%@export CFGRoot :- tsv{resource="CFGRoot.tsv",format=(string, string)} .
%@export ExistsMayPredecessorBBModuloThrow :- tsv{resource="ExistsMayPredecessorBBModuloThrow.tsv",format=(string)} .
%@export DoesNotDominate :- tsv{resource="DoesNotDominate.tsv",format=(string, string)} .
%@export OptReturnInsn :- tsv{resource="OptReturnInsn.tsv",format=(string, string)} .
%@export HigherReturnIndex :- tsv{resource="HigherReturnIndex.tsv",format=(string, int)} .
%@export NextReturnIndex :- tsv{resource="NextReturnIndex.tsv",format=(string, int)} .
%@export ExistsPreviousReturn :- tsv{resource="ExistsPreviousReturn.tsv",format=(string)} .
%@export BBHeadInMethod :- tsv{resource="BBHeadInMethod.tsv",format=(string, string)} .
%@export SameMethodBBHeads :- tsv{resource="SameMethodBBHeads.tsv",format=(string, string)} .
%@export PredecessorBBsToSameBB :- tsv{resource="PredecessorBBsToSameBB.tsv",format=(string, string, string)} .
%@export LargerPredecessorIndexToSameBB :- tsv{resource="LargerPredecessorIndexToSameBB.tsv",format=(string, int, string)} .
%@export NextPredecessorIndexToSameBB :- tsv{resource="NextPredecessorIndexToSameBB.tsv",format=(string, string, int)} .
%@export NextPredecessorToSameBB :- tsv{resource="NextPredecessorToSameBB.tsv",format=(string, string, string)} .
%@export PreviousPredecessorToSameB :- tsv{resource="PreviousPredecessorToSameB.tsv",format=(string, string, string)} .
%@export ExistsPreviousPredecessorToSameBB :- tsv{resource="ExistsPreviousPredecessorToSameBB.tsv",format=(string, string)} .
%@export NonDomPredecessorBBsToSameBB :- tsv{resource="NonDomPredecessorBBsToSameBB.tsv",format=(string, string, string) } .
%@export LargerNonDomPredecessorIndexToSameBB :- tsv{resource="LargerNonDomPredecessorIndexToSameBB.tsv",format=(string, int, string)} .
%@export NextNonDomPredecessorIndexToSameBB :- tsv{resource="NextNonDomPredecessorIndexToSameBB.tsv",format=(string, string, int)} .
%@export NextNonDomPredecessorToSameBB :- tsv{resource="NextNonDomPredecessorToSameBB.tsv",format=(string, string, string)} .
%@export PreviousNonDomPredecessorToSameBB :- tsv{resource="PreviousNonDomPredecessorToSameBB.tsv",format=(string, string, string) } .
%@export ExistsPreviousNonDomPredecessorToSameBB :- tsv{resource="ExistsPreviousNonDomPredecessorToSameBB.tsv",format=(string, string)} .
%@export Method_FirstInstruction :- tsv{resource="Method_FirstInstruction.tsv",format=(string,string)}.