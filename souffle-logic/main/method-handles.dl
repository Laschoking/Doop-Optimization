/*************************************************************
 * Method Types
 *************************************************************/

.type MethodType = mainAnalysis.Value
.type ParamTypes = symbol
.decl MethodType_ParamType(?mt:MethodType, ?index:number, ?pType:Type)
.decl MethodType_ParamTypes(?mt:MethodType, ?paramTypes:ParamTypes)
.decl MethodType_ReturnType(?mt:MethodType, ?retType:Type)
.decl MethodType_Arity(?mt:MethodType, ?arity:number)
.decl Method_MethodType(?method:Method, ?mt:MethodType)

// Relation to mark all method types created initially.
.decl isInitialMethodType(?mt:MethodType)

// For every method type constant in the constant pool, create a method type.
MethodType_ParamType(?mt, ?idx, ?type)  :- _MethodTypeConstantParam(?mt, ?idx, ?type).
MethodType_Arity(?mt, ?arity)           :- MethodTypeConstant_Arity(?mt, ?arity).
MethodType_ReturnType(?mt, ?retType)    :- MethodTypeConstant_ReturnType(?mt, ?retType).
MethodType_ParamTypes(?mt, ?paramTypes) :- MethodTypeConstant_ParamTypes(?mt, ?paramTypes).

#define METHOD_TYPE(paramTypes, retType) \
  cat("method type ", cat(paramTypes, retType))

#ifdef REFLECTION_METHOD_HANDLES
#ifdef REFLECTION

// For every method, create a method type.
MockValueConsMacro(?mt, "java.lang.invoke.MethodType"),
isInitialMethodType(?mt),
Method_MethodType(?method, ?mt),
MethodType_ParamTypes(?mt, ?paramTypes),
MethodType_Arity(?mt, ?arity),
MethodType_ReturnType(?mt, ?retType) :-
  Method_ReturnType(?method, ?retType),
  Method_ParamTypes(?method, ?paramTypes),
  ?mt = METHOD_TYPE(?paramTypes, ?retType),
  Method_Arity(?method, ?arity).
MethodType_ParamType(?mt, ?index, ?pType) :-
  Method_MethodType(?method, ?mt),
  FormalParam(?index, ?method, ?var),
  _Var_Type(?var, ?pType).

// Model of MethodType.returnType().
VarPointsTo(?hctx, ?classValue, ?ctx, ?ret) :-
  _VirtualMethodInvocation(?invo, _, "<java.lang.invoke.MethodType: java.lang.Class returnType()>", ?base, ?method),
  ReachableContext(?ctx, ?method),
  VarPointsTo(?hctx, ?mt, ?ctx, ?base),
  MethodType_ReturnType(?mt, ?retType),
  ReifiedClass(?retType, ?classValue),
  AssignReturnValue(?invo, ?ret).

// Imprecise model of MethodType.parameterType(), since we do not track
// primitive values (for its argument).
VarPointsTo(?hctx, ?classValue, ?ctx, ?ret) :-
  _VirtualMethodInvocation(?invo, _, "<java.lang.invoke.MethodType: java.lang.Class parameterType(int)>", ?base, ?method),
  ReachableContext(?ctx, ?method),
  VarPointsTo(?hctx, ?mt, ?ctx, ?base),
  MethodType_ParamType(?mt, _, ?pType),
  ReifiedClass(?pType, ?classValue),
  AssignReturnValue(?invo, ?ret).

// MethodType API entry points. The actual logic: every methodType()
// invocation picks all descriptors that match.

.decl ReachableMethodTypeN(?id:number, ?invo:MethodInvocation, ?ctx:configuration.Context)
ReachableMethodTypeN(?id, ?invo, ?ctx) :-
  MTEntryPoint(?id, ?invo, _),
  Instruction_Method(?invo, ?method),
  ReachableContext(?ctx, ?method).

.decl MT_ReturnType(?invo:MethodInvocation, ?hctx:configuration.HContext, ?ctx:configuration.Context, ?type:Type)
.decl MT_ParamValue(?invo:MethodInvocation, ?index:number, ?classValue:Value)

// The first argument to methodType() is always the return type.
MT_ReturnType(?invo, ?hctx, ?ctx, ?type) :-
  ReachableMethodTypeN(_, ?invo, ?ctx),
  ActualParam(0, ?invo, ?param),
  VarPointsTo(?hctx, ?classValue, ?ctx, ?param),
  ReifiedClass(?type, ?classValue).

// MethodType2, MethodType4: second parameter.
MT_ParamValue(?invo, 0, ?classValue) :-
  ReachableMethodTypeN(?id, ?invo, ?ctx),
  (?id = 2 ; ?id = 4),
  ActualParam(1, ?invo, ?param),
  VarPointsTo(_, ?classValue, ?ctx, ?param).

// MethodType1 lacks a parameter, so we use a dummy value instead.
#define MT_NOARGS_VALUE "<mock dummy methodType() class for first argument>"
MockValueConsMacro(MT_NOARGS_VALUE, "java.lang.Class"),
MT_ParamValue(?invo, 0, MT_NOARGS_VALUE) :-
  MTEntryPoint(1, ?invo, _).

// Helper relation to treat 'void' and 'java.lang.Void' as the same
// type in descriptors.
.decl InvoReturnTypeMatch(?invo:MethodInvocation, ?hctx:configuration.HContext, ?ctx:configuration.Context, ?retType:Type)

InvoReturnTypeMatch(?invo, ?hctx, ?ctx, "void") :-
  MT_ReturnType(?invo, ?hctx, ?ctx, "java.lang.Void").
InvoReturnTypeMatch(?invo, ?hctx, ?ctx, ?retType) :-
  MT_ReturnType(?invo, ?hctx, ?ctx, ?retType).

.decl MTCallMatch(?invo:MethodInvocation, ?hctx:configuration.HContext, ?ctx:configuration.Context, ?paramTypes:ParamTypes, ?retType:Type, ?arity:number)

// MethodType1.
MTCallMatch(?invo, ?hctx, ?ctx, "()", ?retType, 0) :-
  MTEntryPoint(1, ?invo, _),
  InvoReturnTypeMatch(?invo, ?hctx, ?ctx, ?retType),
  MT_ParamValue(?invo, 0, MT_NOARGS_VALUE).

// MethodType2.
MTCallMatch(?invo, ?hctx, ?ctx, ?paramTypes, ?retType, 1) :-
  MTEntryPoint(2, ?invo, _),
  InvoReturnTypeMatch(?invo, ?hctx, ?ctx, ?retType),
  MT_ParamValue(?invo, 0, ?classValue0),
  ReifiedClass(?pType0, ?classValue0),
  ?paramTypes = cat("(", cat(?pType0, ")")).

// MethodType5.
MTCallMatch(?invo, ?hctx, ?ctx, ?argParamTypes, ?retType, ?arity) :-
  ReachableMethodTypeN(5, ?invo, ?ctx),
  InvoReturnTypeMatch(?invo, ?hctx, ?ctx, ?retType),
  ActualParam(1, ?invo, ?param),
  VarPointsTo(_, ?mtArg, ?ctx, ?param),
  MethodType_ParamTypes(?mtArg, ?argParamTypes),
  MethodType_Arity(?mtArg, ?arity).

// MethodType3/MethodType4/MethodType6. Here we do not try to reason about the
// parameter types but return a wildcard; this will be attached to the mock
// method type and trigger imprecise matching in the method finder.
#define WILDCARD_PARAM_TYPES "(--all-types--)"
MTCallMatch(?invo, ?hctx, ?ctx, WILDCARD_PARAM_TYPES, ?retType, 0) :-
  MTEntryPoint(?id, ?invo, _),
  (?id = 3 ; ?id = 4 ; ?id = 6),
  InvoReturnTypeMatch(?invo, ?hctx, ?ctx, ?retType).

// Make methodType() invocations return values.
.decl AssignMethodType(?hctx:configuration.HContext, ?mt:MethodType, ?ctx:configuration.Context, ?ret:Var, ?paramTypes:ParamTypes, ?retType:Type, ?arity:number)

AssignMethodType(?hctx, ?mt, ?ctx, ?ret, ?paramTypes, ?retType, ?arity) :-
  MTCallMatch(?invo, ?hctx, ?ctx, ?paramTypes, ?retType, ?arity),
  AssignReturnValue(?invo, ?ret),
  ?mt = METHOD_TYPE(?paramTypes, ?retType).

// If the method type has been created during the preprocessing
// initial phase, reuse it.
VarPointsTo(?hctx, ?mt, ?ctx, ?ret) :-
  AssignMethodType(?hctx, ?mt, ?ctx, ?ret, _, _, _),
  isInitialMethodType(?mt).

// Invent new method types if we are not sure they already exist from
// the preprocessing initial phase.
MockValueConsMacro(?mt, "java.lang.invoke.MethodType"),
MethodType_Arity(?mt, ?arity),
MethodType_ParamTypes(?mt, ?paramTypes),
MethodType_ReturnType(?mt, ?retType),
VarPointsTo(?hctx, ?mt, ?ctx, ?ret) :-
  AssignMethodType(?hctx, ?mt, ?ctx, ?ret, ?paramTypes, ?retType, ?arity),
  !isInitialMethodType(?mt),
  Var_DeclaringMethod(?ret, ?method),
  Method_DeclaringType(?method, ?type),
  ApplicationClass(?type).


#endif // REFLECTION
#endif // REFLECTION_METHOD_HANDLES

/*************************************************************
 * Method Handles
 *************************************************************/

HeapAllocation_ContextInsensitive(?heap) :-
  isMethodHandleConstant(?heap).

.type MethodHandle = mainAnalysis.Value
.decl MethodHandle_Method(?methodHandle:MethodHandle, ?method:Method)
.decl MethodHandle_MethodType(?mh:MethodHandle, ?mt:MethodType)

// For every method handle constant, create a method type.
MockValueConsMacro(?mt, "java.lang.invoke.MethodType"),
isInitialMethodType(?mt),
MethodHandle_Method(?methodHandle, ?method),
MethodHandle_MethodType(?methodHandle, ?mt),
MethodType_Arity(?mt, ?arity),
MethodType_ParamTypes(?mt, ?paramTypes),
MethodType_ReturnType(?mt, ?retType) :-
  MethodHandleConstant_Method(?methodHandle, ?method),
  MethodHandleConstant_ParamTypes(?methodHandle, ?paramTypes),
  MethodHandleConstant_ReturnType(?methodHandle, ?retType),
  MethodHandleConstant_Arity(?methodHandle, ?arity),
  ?mt = METHOD_TYPE(?paramTypes, ?retType).

// Invocations of a MethodHandle. These can either be explicit calls to
// MethodHandle.invoke()/invokeExact() or implicit calls via invokedynamic.
.decl MethodHandleCallGraphEdge(?callerCtx:configuration.Context, ?i:MethodInvocation, ?calleeCtx:configuration.Context, ?m:Method, ?mh:MethodHandle, ?name:symbol)

MethodHandleCallGraphEdge(?callerCtx, ?invo, ?calleeCtx, ?method, ?mh, ?name) :-
  // Permit treatment of invoke methods as opaque.
  (_VirtualMethodInvocation(?invo, _, _, ?base, ?containingMethod) ;
   _SpecialMethodInvocation(?invo, _, _, ?base, ?containingMethod)),
  _MethodHandleInvocation(?invo, ?name),
  ReachableContext(?callerCtx, ?containingMethod),
  VarPointsTo(_, ?mh, ?callerCtx, ?base),
  MethodHandle_Method(?mh, ?method),
  // REVIEW: context sensitivity in the callee.
  isImmutableContext(?calleeCtx).
ReachableContext(?calleeCtx, ?method) :-
  MethodHandleCallGraphEdge(_, _, ?calleeCtx, ?method, _, _).

// A boxing/unboxing conversion of types including the null type.
.decl BoxTypeConversion(?original:Type, ?new:Type)
// Create a new allocation in the case of boxing.
.decl BoxAllocation(?value:Value, ?type:Type)
#define BOX_ALLOC(t) cat("mock box allocation for type ", t)

BoxTypeConversion(?t1, ?t2),
MockValueConsMacro(?mockAlloc, ?t2),
BoxAllocation(?mockAlloc, ?t2) :-
  PrimitiveType_Boxed(?t1, ?wrapperT),
  basic.SubtypeOf(?wrapperT, ?t2),
  ?mockAlloc = BOX_ALLOC(?t2).
BoxTypeConversion(?t1, ?t2) :- PrimitiveType_Boxed(?t1, _), isNullType(?t2).
BoxTypeConversion(?t1, ?t2) :- PrimitiveType_Boxed(_, ?t2), isNullType(?t1).
BoxTypeConversion(?t1, ?t2) :- BoxTypeConversion(?t2, ?t1).

.decl CompatibleTypes(?t:Type, ?tConv:Type)
CompatibleTypes(?t, ?tConv) :- basic.SubtypeOf(?tConv, ?t).
CompatibleTypes(?t, ?tConv) :- BoxTypeConversion(?t, ?tConv).

// Record parameter passing, to be used for conversions (e.g., auto-boxing).
.decl MethodHandleCGE_Arg(?callerCtx:configuration.Context, ?calleeCtx:configuration.Context, ?actual:Var, ?formal:Var, ?actualType:Type, ?formalType:Type, ?name:symbol)
// Pass arguments to instance methods (first argument becomes the receiver).
MethodHandleCGE_Arg(?callerCtx, ?calleeCtx, ?actual, ?formal, ?actualType, ?formalType, ?name) :-
  MethodHandleCallGraphEdge(?callerCtx, ?invo, ?calleeCtx, ?method, _, ?name),
  !Method_Modifier("static", ?method),
  ActualParam(?idx, ?invo, ?actual),
  ?idx > 0,
  FormalParam(?idx - 1, ?method, ?formal),
  Var_Type(?actual, ?actualType),
  Var_Type(?formal, ?formalType).
// Pass arguments to static methods.
MethodHandleCGE_Arg(?callerCtx, ?calleeCtx, ?actual, ?formal, ?actualType, ?formalType, ?name) :-
  MethodHandleCallGraphEdge(?callerCtx, ?invo, ?calleeCtx, ?method, _, ?name),
  Method_Modifier("static", ?method),
  ActualParam(?idx, ?invo, ?actual),
  FormalParam(?idx, ?method, ?formal),
  Var_Type(?actual, ?actualType),
  Var_Type(?formal, ?formalType).

// This rule covers exact matching of argument types.
VarPointsTo(?hctx, ?val, ?calleeCtx, ?formal) :-
  MethodHandleCGE_Arg(?callerCtx, ?calleeCtx, ?actual, ?formal, ?actualType, ?formalType, _),
  VarPointsTo(?hctx, ?val, ?callerCtx, ?actual),
  basic.SubtypeOf(?actualType, ?formalType).

#ifdef REFLECTION_METHOD_HANDLES
// This rule covers boxing of arguments for MethodHandle.invoke(). Since the
// original arguments are primitive values, VarPointsTo may not be available.
// This is an expensive rule and is thus guarded for the full reflective case.
VarPointsTo(?immHctx, ?val, ?calleeCtx, ?formal) :-
  MethodHandleCGE_Arg(_, ?calleeCtx, _, ?formal, ?actualType, ?formalType, "invoke"),
  BoxTypeConversion(?actualType, ?formalType),
  BoxAllocation(?val, ?formalType),
  isImmutableHContext(?immHctx).
#endif // REFLECTION_METHOD_HANDLES

// Pass receiver to instance methods.
VarPointsTo(?hctx, ?val, ?calleeCtx, ?this) :-
  MethodHandleCallGraphEdge(?callerCtx, ?invo, ?calleeCtx, ?method, _, _),
  !Method_Modifier("static", ?method),
  ActualParam(0, ?invo, ?actual),
  VarPointsTo(?hctx, ?val, ?callerCtx, ?actual),
  ThisVar(?method, ?this),
  Var_Type(?actual, ?actualType),
  Var_Type(?this, ?thisType),
  CompatibleTypes(?actualType, ?thisType).

// Get return value.
VarPointsTo(?hctx, ?val, ?callerCtx, ?var) :-
  MethodHandleCallGraphEdge(?callerCtx, ?invo, ?calleeCtx, ?method, _, _),
  ReturnVar(?ret, ?method),
  VarPointsTo(?hctx, ?val, ?calleeCtx, ?ret),
  AssignReturnValue(?invo, ?var),
  Var_Type(?ret, ?retType),
  Var_Type(?var, ?varType),
  CompatibleTypes(?retType, ?varType).

// Model MethodHandle.asType().
MockValueConsMacro(?adapterMH, "java.lang.invoke.MethodHandle"),
MethodHandle_Method(?adapterMH, ?mhMethod),
MethodHandle_MethodType(?adapterMH, ?mt),
VarPointsTo(?hctx, ?adapterMH, ?ctx, ?ret) :-
  _VirtualMethodInvocation(?invo, _, ?sig, ?base, ?method),
  ReachableContext(?ctx, ?method),
  ?sig = "<java.lang.invoke.MethodHandle: java.lang.invoke.MethodHandle asType(java.lang.invoke.MethodType)>",
  VarPointsTo(?hctx, ?mh, ?ctx, ?base),
  ActualParam(0, ?invo, ?arg),
  VarPointsTo(_, ?mt, ?ctx, ?arg),
  AssignReturnValue(?invo, ?ret),
  MethodHandle_Method(?mh, ?mhMethod),
  Method_ParamTypes(?mhMethod, ?paramTypes),
  ?adapterMH = cat("<adapter for ", cat(?mh, cat(" as ", ?mt))).

/*************************************************************
 * Method Handles Lookup
 *************************************************************/

.decl MHLookup_Type(?value:Value, ?type:Type)
#define MOCK_MH_LOOKUP(t) cat("mock method handles lookup object for type ", t)

#ifdef REFLECTION_METHOD_HANDLES
#ifdef REFLECTION

// Model of MethodHandles.lookup().
MockValueConsMacro(?mockMHLookup, "java.lang.invoke.MethodHandles$Lookup"),
MHLookup_Type(?mockMHLookup, ?type),
VarPointsTo(?immHctx, ?mockMHLookup, ?immCtx, ?ret) :-
  _StaticMethodInvocation(?invo, _, "<java.lang.invoke.MethodHandles: java.lang.invoke.MethodHandles$Lookup lookup()>", ?method),
  ReachableContext(?ctx, ?method),
  Method_DeclaringType(?method, ?type),
  AssignReturnValue(?invo, ?ret),
  isImmutableContext(?immCtx),
  isImmutableHContext(?immHctx),
  ?mockMHLookup = MOCK_MH_LOOKUP(?type).

// Model of MethodHandles.Lookup.lookupClass().
VarPointsTo(?hctx, ?classValue, ?ctx, ?ret) :-
  _VirtualMethodInvocation(?invo, _, "<java.lang.invoke.MethodHandles$Lookup: java.lang.Class lookupClass()>", ?base, ?method),
  ReachableContext(?ctx, ?method),
  VarPointsTo(?hctx, ?mhLookup, ?ctx, ?base),
  MHLookup_Type(?mhLookup, ?type),
  ReifiedClass(?type, ?classValue),
  AssignReturnValue(?invo, ?ret).

// Helper relation to only create direct method handles when no constant method
// handles are found. Used when computing the handle to store in a variable.
.decl AssignMethodHandleToVarRequest(?method:Method, ?paramTypes:ParamTypes, ?retType:Type, ?hctx:configuration.HContext, ?ctx:configuration.Context, ?ret:Var)
// Case 1: method handle constant exists.
VarPointsTo(?hctx, ?mh, ?ctx, ?var) :-
  AssignMethodHandleToVarRequest(?method, ?paramTypes, ?retType, ?hctx, ?ctx, ?var),
  MethodHandleConstant_Method(?mh, ?method),
  MethodHandleConstant_ParamTypes(?mh, ?paramTypes),
  MethodHandleConstant_ReturnType(?mh, ?retType).
// Case 2: method handle constant not found, invent a mock object.
MockValueConsMacro(?dmh, "java.lang.invoke.MethodHandle"),
MethodHandle_Method(?dmh, ?method),
MethodHandle_MethodType(?dmh, ?mt),
VarPointsTo(?hctx, ?dmh, ?ctx, ?var) :-
  AssignMethodHandleToVarRequest(?method, ?paramTypes, ?retType, ?hctx, ?ctx, ?var),
  !MethodHandleConstant_Method(_, ?method),
  Method_MethodType(?method, ?mt),
  ?dmh = cat("<computed direct method handle for ", cat(?method, ">")).

// Model conversions from reflection Method to method handle.
AssignMethodHandleToVarRequest(?method, ?paramTypes, ?retType, ?hctx, ?ctx, ?ret) :-
  ( MethodInvocation_Method(?invo, "<java.lang.invoke.MethodHandles$Lookup: java.lang.invoke.MethodHandle unreflect(java.lang.reflect.Method)>") ;
  MethodInvocation_Method(?invo, "<java.lang.invoke.MethodHandles$Lookup: java.lang.invoke.MethodHandle unreflectSpecial(java.lang.reflect.Method,java.lang.Class)>")),
  Instruction_Method(?invo, ?caller),
  ReachableContext(?ctx, ?caller),
  ActualParam(0, ?invo, ?arg),
  VarPointsTo(?hctx, ?methodValue, ?ctx, ?arg),
  ReifiedMethod(?method, ?methodValue),
  Method_ParamTypes(?method, ?paramTypes),
  Method_ReturnType(?method, ?retType),
  AssignReturnValue(?invo, ?ret).
AssignMethodHandleToVarRequest(?method, ?paramTypes, ?retType, ?hctx, ?ctx, ?ret) :-
  MethodInvocation_Method(?invo, "<java.lang.invoke.MethodHandles$Lookup: java.lang.invoke.MethodHandle unreflectConstructor(java.lang.reflect.Constructor)>"),
  Instruction_Method(?invo, ?caller),
  ReachableContext(?ctx, ?caller),
  ActualParam(0, ?invo, ?arg),
  VarPointsTo(?hctx, ?constructor, ?ctx, ?arg),
  ReifiedConstructor(?method, ?constructor),
  Method_ParamTypes(?method, ?paramTypes),
  Method_ReturnType(?method, ?retType),
  AssignReturnValue(?invo, ?ret).

// Method lookup methods.

.decl FindVirtual(?invo:MethodInvocation)
FindVirtual(?invo) :-
  MethodInvocation_Method(?invo, "<java.lang.invoke.MethodHandles$Lookup: java.lang.invoke.MethodHandle findVirtual(java.lang.Class,java.lang.String,java.lang.invoke.MethodType)>"),
  Instruction_Method(?invo, ?caller),
  ReachableContext(_, ?caller).

.decl FindStatic(?invo:MethodInvocation)
FindStatic(?invo) :-
  MethodInvocation_Method(?invo, "<java.lang.invoke.MethodHandles$Lookup: java.lang.invoke.MethodHandle findStatic(java.lang.Class,java.lang.String,java.lang.invoke.MethodType)>"),
  Instruction_Method(?invo, ?caller),
  ReachableContext(_, ?caller).

.decl MethodFinder(?invo:MethodInvocation, ?ret:Var)
MethodFinder(?invo, ?ret) :-
  ( FindStatic(?invo) ; FindVirtual(?invo) ),
  VirtualMethodInvocation_Base(?invo, ?lookup),
  VarPointsTo(_, ?baseVal, _, ?lookup),
  !Value_Null(?baseVal),
  AssignReturnValue(?invo, ?ret).

// Direct method handle lookup.
.decl DMHLookup(?type:Type, ?id:symbol, ?mt:Value, ?method:Method, ?retType:Type, ?paramTypes:ParamTypes)
// Look up method handle with a normal method type.
DMHLookup(?type, ?id, ?mt, ?method, ?retType, ?paramTypes) :-
  Method_DeclaringType(?method, ?type),
  Method_SimpleName(?method, ?id),
  Method_ReturnType(?method, ?retType),
  Method_ParamTypes(?method, ?paramTypes),
  MethodType_ReturnType(?mt, ?retType),
  MethodType_ParamTypes(?mt, ?paramTypes),
  ?mt = METHOD_TYPE(?paramTypes, ?retType).
// Look up method handle with a return-type-only method type.
DMHLookup(?type, ?id, ?mt, ?method, ?retType, ?paramTypes) :-
  Method_DeclaringType(?method, ?type),
  Method_SimpleName(?method, ?id),
  Method_ReturnType(?method, ?retType),
  Method_ParamTypes(?method, ?paramTypes),
  MethodType_ReturnType(?mt, ?retType),
  MethodType_ParamTypes(?mt, WILDCARD_PARAM_TYPES),
  ?mt = METHOD_TYPE(WILDCARD_PARAM_TYPES, ?retType).

// Create VarPointsTo for return values of method finders.
AssignMethodHandleToVarRequest(?method, ?paramTypes, ?retType, ?hctx, ?ctx, ?ret) :-
  MethodFinder(?invo, ?ret),
  ActualParam(0, ?invo, ?classParam),
  VarPointsTo(?hctx, ?classValue, ?ctx, ?classParam),
  ReifiedClass(?type, ?classValue),
  ActualParam(1, ?invo, ?stringParam),
  VarPointsTo(_, ?id, _, ?stringParam),
  ActualParam(2, ?invo, ?mtParam),
  VarPointsTo(_, ?mt, _, ?mtParam),
  DMHLookup(?type, ?id, ?mt, ?method, ?retType, ?paramTypes).

#endif // REFLECTION
#endif // REFLECTION_METHOD_HANDLES

// Create a receiver object when calling constructors.
MockValueConsMacro(?value, ?type),
VarPointsTo(?hctx, ?value, ?calleeCtx, ?thisVar),
VarPointsTo(?hctx, ?value, ?callerCtx, ?ret) :-
  MethodHandleCallGraphEdge(?callerCtx, ?invo, ?calleeCtx, ?method, ?mh, _),
  Method_SimpleName(?method, "<init>"),
  ThisVar(?method, ?thisVar),
  Method_DeclaringType(?method, ?type),
  isImmutableHContext(?hctx),
  ?value = cat(?type, cat(" value constructed by method handle ", ?mh)),
  AssignReturnValue(?invo, ?ret).

/*************************************************************
 * Generic invokedynamic
 *************************************************************/

.decl ReachableInvokedynamic(?invokedynamic:DynamicMethodInvocation_Insn, ?dynName:symbol, ?dynRetType:Type, ?ctx:configuration.Context)
ReachableInvokedynamic(?invokedynamic, ?dynName, ?dynRetType, ?ctx) :-
  isDynamicMethodInvocation_Insn(?invokedynamic),
  Instruction_Method(?invokedynamic, ?inMethod),
  DynamicMethodInvocation_DynName(?invokedynamic, ?dynName),
  DynamicMethodInvocation_DynReturnType(?invokedynamic, ?dynRetType),
  ReachableContext(?ctx, ?inMethod).

// Helper relation to make bootstrap method context configurable.
.decl isBootstrapMethodContext(?ctx:configuration.Context)
isBootstrapMethodContext(?ctx) :- isImmutableContext(?ctx).

// Call-graph edge: invokedynamic instruction -> boot method.
.decl InvokedynamicBootCallGraphEdge(?callerCtx:configuration.Context, ?invokedynamic:DynamicMethodInvocation_Insn, ?calleeCtx:configuration.Context, ?bootMethod:Method)
InvokedynamicBootCallGraphEdge(?callerCtx, ?invokedynamic, ?calleeCtx, ?bootMethod) :-
  ReachableInvokedynamic(?invokedynamic, _, _, ?callerCtx),
  DynamicMethodInvocation_Bootstrap(?invokedynamic, ?bootMethod),
  isBootstrapMethodContext(?calleeCtx).

ReachableContext(?calleeCtx, ?bootMethod) :-
  InvokedynamicBootCallGraphEdge(_, _, ?calleeCtx, ?bootMethod).

.decl Invokedynamic_MethodType(?invokedynamic:DynamicMethodInvocation_Insn, ?mt:MethodType)
#define MOCK_MT(retType, paramTypes) cat("mock method type ", cat(retType, paramTypes))
.decl PopulateMTParamTypes(?mt:Value, ?invokedynamic:DynamicMethodInvocation_Insn)

// For every reachable invokedynamic, create a mock method type.
MockValueConsMacro(?mockMethodType, "java.lang.invoke.MethodType"),
MethodType_ReturnType(?mockMethodType, ?dynRetType),
PopulateMTParamTypes(?mockMethodType, ?invokedynamic),
Invokedynamic_MethodType(?invokedynamic, ?mockMethodType) :-
  InvokedynamicBootCallGraphEdge(_, ?invokedynamic, _, _),
  DynamicMethodInvocation_DynReturnType(?invokedynamic, ?dynRetType),
  DynamicMethodInvocation_DynParamTypes(?invokedynamic, ?dynParamTypes),
  ?mockMethodType = MOCK_MT(?dynRetType, ?dynParamTypes).
MethodType_ParamType(?mt, ?index, ?pType) :-
  PopulateMTParamTypes(?mt, ?invokedynamic),
  _DynamicMethodInvocation_DynParamType(?invokedynamic, ?index, ?pType).

// Pass arguments to bootstrap methods. First three arguments are
// filled in by the JVM, so we fill them with mock objects.
MockValueConsMacro(?mockMHLookup, "java.lang.invoke.MethodHandles$Lookup"),
MHLookup_Type(?mockMHLookup, ?callerClass),
VarPointsTo(?immHctx, ?mockMHLookup, ?calleeCtx, ?caller),
VarPointsTo(?immHctx, ?mockMethodType, ?calleeCtx, ?invokedTypeParam) :-
  InvokedynamicBootCallGraphEdge(_, ?invokedynamic, ?calleeCtx, ?bootMethod),
  FormalParam(0, ?bootMethod, ?caller),
  FormalParam(2, ?bootMethod, ?invokedTypeParam),
  DynamicMethodInvocation_DynReturnType(?invokedynamic, ?dynRetType),
  DynamicMethodInvocation_DynParamTypes(?invokedynamic, ?dynParamTypes),
  Invokedynamic_MethodType(?invokedynamic, ?mockMethodType),
  isImmutableHContext(?immHctx),
  Instruction_Method(?invokedynamic, ?method),
  Method_DeclaringType(?method, ?callerClass),
  ?mockMHLookup = MOCK_MH_LOOKUP(?callerClass).

// The second-arg rule should only be enabled when strings are not merged.
#if defined(DISTINGUISH_REFLECTION_ONLY_STRING_CONSTANTS) || defined(DISTINGUISH_ALL_STRING_CONSTANTS) || defined(NO_MERGES)
VarPointsTo(?immHctx, ?invokedName, ?calleeCtx, ?invokedNameParam) :-
  InvokedynamicBootCallGraphEdge(_, ?invokedynamic, ?calleeCtx, ?bootMethod),
  isStringConstant(?invokedName),
  FormalParam(1, ?bootMethod, ?invokedNameParam),
  DynamicMethodInvocation_DynName(?invokedynamic, ?invokedName),
  isImmutableHContext(?immHctx).
#endif // DISTINGUISH_REFLECTION_ONLY_STRING_CONSTANTS || DISTINGUISH_ALL_STRING_CONSTANTS || NO_MERGES

// Helper method to compute the varargs accumulator formal of a method.
.decl MethodVarArgs(?method:Method, ?idx:number, ?formal:Var, ?type:ArrayType)
MethodVarArgs(?method, ?idx, ?formal, ?type) :-
  Method_Modifier("varargs", ?method),
  Method_Arity(?method, ?arity),
  ?idx = ?arity - 1,
  FormalParam(?idx, ?method, ?formal),
  Var_Type(?formal, ?type),
  isArrayType(?type).

// Use a mock array to fix calls to a bootstrap method accepting varargs.
#define MOCK_ARRAY(invokedynamic) cat("bootstrap varargs array for ", invokedynamic)

ArrayIndexPointsTo(?immHctx, ?val, ?immHctx, ?mockArray),
MockValueConsMacro(?mockArray, ?varArgsType),
VarPointsTo(?immHctx, ?mockArray, ?calleeCtx, ?formalVarArgs) :-
  InvokedynamicBootCallGraphEdge(?callerCtx, ?invokedynamic, ?calleeCtx, ?bootMethod),
  MethodVarArgs(?bootMethod, ?bootIdx, ?formalVarArgs, ?varArgsType),
  BootstrapParam(?idx, ?invokedynamic, ?actual),
  ?idx > ?bootIdx - 3,
  VarPointsTo(_, ?val, _, ?actual),
  isImmutableHContext(?immHctx),
  ?mockArray = MOCK_ARRAY(?invokedynamic).

// Normal handling for the last three arguments of the bootstrap method, shifted.
VarPointsTo(?hctx, ?val, ?calleeCtx, ?formal) :-
  InvokedynamicBootCallGraphEdge(_, ?invokedynamic, ?calleeCtx, ?bootMethod),
  !Method_Modifier("varargs", ?bootMethod),
  FormalParam(?idx + 3, ?bootMethod, ?formal),
  BootstrapParam(?idx, ?invokedynamic, ?actual),
  VarPointsTo(?hctx, ?val, _, ?actual).

.type CallSite = mainAnalysis.Value
.decl InvokedynamicCallSite(?callsite:CallSite, ?invokedynamic:DynamicMethodInvocation_Insn, ?dynName:symbol, ?K:number, ?ctx:configuration.Context)

// Record CallSite metadata.
InvokedynamicCallSite(?callsite, ?invokedynamic, ?dynName, ?K, ?callerCtx) :-
  ReachableInvokedynamic(?invokedynamic, ?dynName, _, ?callerCtx),
  DynamicMethodInvocation_DynArity(?invokedynamic, ?K),
  DynamicMethodInvocation_Bootstrap(?invokedynamic, ?bootMethod),
  ReturnVar(?bootRetVar, ?bootMethod),
  isBootstrapMethodContext(?calleeCtx),
  VarPointsTo(_, ?callsite, ?calleeCtx, ?bootRetVar).

.decl CallSiteContents(?callsite:CallSite, ?methodHandle:MethodHandle, ?method:Method)
CallSiteContents(?callsite, ?methodHandle, ?method) :-
  InvokedynamicCallSite(?callsite, _, _, _, _),
  InstanceFieldPointsTo(_, ?methodHandle, "<java.lang.invoke.CallSite: java.lang.invoke.MethodHandle target>", _, ?callsite),
  MethodHandle_Method(?methodHandle, ?method).

.decl InvokedynamicMatchesMethodHandleType(?invokedynamic:DynamicMethodInvocation_Insn, ?mh:MethodHandle)
InvokedynamicMatchesMethodHandleType(?invokedynamic, ?mh) :-
  DynamicMethodInvocation_DynParamTypes(?invokedynamic, ?dynParamTypes),
  DynamicMethodInvocation_DynReturnType(?invokedynamic, ?dynRetType),
  MethodHandle_MethodType(?mh, METHOD_TYPE(?dynParamTypes, ?dynRetType)).
// Method handle for C.<init> has dynamic return type C instead of "void".
InvokedynamicMatchesMethodHandleType(?invokedynamic, ?mh) :-
  DynamicMethodInvocation_DynParamTypes(?invokedynamic, ?dynParamTypes),
  DynamicMethodInvocation_DynReturnType(?invokedynamic, ?dynRetType),
  MethodHandle_Method(?mh, ?method),
  Method_SimpleName(?method, "<init>"),
  MethodHandle_MethodType(?mh, METHOD_TYPE(?dynParamTypes, ?dynRetType)).

// After a method handle is resolved, invokedynamic calls it, as if
// "invokeExact" was invoked on it. This is a call-graph edge from an
// invokedynamic instruction to the method invoked by the call site.

configuration.StaticContextRequest(?callerCtx, ?invokedynamic) :-
  InvokedynamicCallSite(?callsite, ?invokedynamic, _, _, ?callerCtx),
  CallSiteContents(?callsite, ?mh, ?method),
  Method_Modifier("static", ?method),
  InvokedynamicMatchesMethodHandleType(?invokedynamic, ?mh).
MethodHandleCallGraphEdge(?callerCtx, ?invokedynamic, ?calleeCtx, ?method, ?mh, "invokeExact") :-
  InvokedynamicCallSite(?callsite, ?invokedynamic, _, _, ?callerCtx),
  CallSiteContents(?callsite, ?mh, ?method),
  InvokedynamicMatchesMethodHandleType(?invokedynamic, ?mh),
  configuration.StaticContextResponse(?callerCtx, ?invokedynamic, ?calleeCtx).

// General rule for non-static methods resolved by invokedynamic. This rule
// does not use the Request/Response schema, since we do not have a "value"
// for the receiver (call site resolution happens at load time).
MethodHandleCallGraphEdge(?callerCtx, ?invokedynamic, ?calleeCtx, ?method, ?mh, "invokeExact") :-
  InvokedynamicCallSite(?callsite, ?invokedynamic, _, _, ?callerCtx),
  CallSiteContents(?callsite, ?mh, ?method),
  !Method_Modifier("static", ?method),
  InvokedynamicMatchesMethodHandleType(?invokedynamic, ?mh),
  isImmutableContext(?calleeCtx).

ReachableContext(?calleeCtx, ?callee) :-
  MethodHandleCallGraphEdge(_, _, ?calleeCtx, ?callee, _, _).

/*************************************************************
 * Lambda-specific invokedynamic
 *************************************************************/

/** Phase 1: Linkage (creating a lambda CallSite) **/

#define LAMBDA_METAFACTORY "<java.lang.invoke.LambdaMetafactory: java.lang.invoke.CallSite metafactory(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.invoke.MethodType,java.lang.invoke.MethodHandle,java.lang.invoke.MethodType)>"

#define LAMBDA_ALTMETAFACTORY "<java.lang.invoke.LambdaMetafactory: java.lang.invoke.CallSite altMetafactory(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.Object[])>"

// Find invocations to the lambda metafactories.
.decl LambdaMetafactoryInvoke(?invokedynamic:DynamicMethodInvocation_Insn)
LambdaMetafactoryInvoke(?invokedynamic) :-
  DynamicMethodInvocation_Bootstrap(?invokedynamic, ?method),
  (?method = LAMBDA_METAFACTORY ; ?method = LAMBDA_ALTMETAFACTORY).

.decl ReachableLambdaMetafactoryInvoke(?invokedynamic:DynamicMethodInvocation_Insn, ?dynName:symbol, ?dynRetType:Type, ?ctx:configuration.Context)
ReachableLambdaMetafactoryInvoke(?invokedynamic, ?dynName, ?dynRetType, ?ctx) :-
  LambdaMetafactoryInvoke(?invokedynamic),
  ReachableInvokedynamic(?invokedynamic, ?dynName, ?dynRetType, ?ctx).

// Record invokedynamic invocations whose bootstrap methods are not
// handled at all. Used for statistics.
.decl UnhandledInvokedynamic(?invokedynamic:DynamicMethodInvocation_Insn, ?bootMethodId:symbol)

UnhandledInvokedynamic(?invokedynamic, ?bootMethodId) :-
  DynamicMethodInvocation_Bootstrap(?invokedynamic, ?bootMethodId),
  !LambdaMetafactoryInvoke(?invokedynamic).

#define LAMBDA_ALT_VAL(invo, ret, type, method, real, name) \
  cat(invo, cat("::: ", cat(ret, cat("::: (Mock)::: ", cat("reference ", cat(type, cat ("::", cat(method, cat(" from ", cat(real, cat(" wrapped as ", cat(ret, cat(".", name)))))))))))))

.type Lambda = mainAnalysis.Value
.decl LambdaObject(?invokedynamic:DynamicMethodInvocation_Insn, ?lambda:Lambda, ?dynName:symbol, ?K:number, ?implMethod:Method, ?desc:symbol, ?ctx:configuration.Context)

#define LAMBDA(invokedynamic, type) \
  cat(invokedynamic, cat("::: ", cat(type, cat("::: (Mock)::: ", cat("lambda object of type ", type)))))

// Record more information about the call site to model the metafactory result
// and return the mock lambda object.
MockValueConsMacro(?lambda, ?dynRetType),
VarPointsTo(?hctx, ?lambda, ?callerCtx, ?ret),
LambdaObject(?invokedynamic, ?lambda, ?dynName, ?K, ?implMethod, ?desc, ?callerCtx) :-
  ReachableLambdaMetafactoryInvoke(?invokedynamic, ?dynName, ?dynRetType, ?callerCtx),
  DynamicMethodInvocation_DynArity(?invokedynamic, ?K),
  BootstrapParam(1, ?invokedynamic, ?handleVar),
  VarPointsTo(?hctx, ?handleVal, ?callerCtx, ?handleVar),
  MethodHandleConstant_Method(?handleVal, ?implMethod),
  // Used to generate friendly description for the lambda.
  Method_SimpleName(?implMethod, ?handleMeth),
  Method_DeclaringType(?implMethod, ?handleType),
  ?desc = LAMBDA_ALT_VAL(?invokedynamic, ?dynRetType, ?handleType, ?handleMeth, ?implMethod, ?dynName),
  ?lambda = LAMBDA(?invokedynamic, ?dynRetType),
  AssignReturnValue(?invokedynamic, ?ret).

/** Phase 2: Capture (invoke CallSite, return functional object) **/

// Capture values of the enclosing environment.
.decl LambdaCaptured(?invokedynamic:DynamicMethodInvocation_Insn, ?val:Value, ?idx:number, ?hctx:configuration.HContext)
LambdaCaptured(?invokedynamic, ?val, ?idx, ?hctx) :-
  ReachableLambdaMetafactoryInvoke(?invokedynamic, _, _, ?callerCtx),
  DynamicMethodInvocation_DynArity(?invokedynamic, ?K),
  ?K > 0,
  ActualParam(?idx, ?invokedynamic, ?actual),
  VarPointsTo(?hctx, ?val, ?callerCtx, ?actual).

/** Phase 3: Invocation (call method on the functional object) **/

// When a method is called on a lambda object constructed by a
// constant method handle, the real method is called. This can wrap a
// static method call as an instance method call.

// Call-graph edge: method invocation on lambda object -> implementing method.
.decl LambdaCallGraphEdge(?callerCtx:configuration.Context, ?i:MethodInvocation, ?calleeCtx:configuration.Context, ?m:Method, ?lambda:Lambda)

// Call-graph edge: method call on lambda object -> implementing
// method.  For simplicity, the callee context is trivial. For proper
// context sensitivity, we must model all combinations of calling
// contexts with implementing-method staticness.
LambdaCallGraphEdge(?callerCtx, ?i, ?calleeCtx, ?implMethod, ?lambda) :-
  LambdaObject(_, ?lambda, ?dynName, _, ?implMethod, _, _),
  VarPointsTo(_, ?lambda, ?callerCtx, ?var),
  VirtualMethodInvocation_Base(?i, ?var),
  VirtualMethodInvocation_SimpleName(?i, ?dynName),
  isImmutableContext(?calleeCtx).

ReachableContext(?calleeCtx, ?callee) :-
  LambdaCallGraphEdge(_, _, ?calleeCtx, ?callee, _).

// Handle return values for lambda call-graph edges.
VarPointsTo(?hctx, ?retVal, ?callerCtx, ?ret) :-
  LambdaCallGraphEdge(?callerCtx, ?i, ?calleeCtx, ?method, _),
  ReturnVar(?realReturnVar, ?method),
  VarPointsTo(?hctx, ?retVal, ?calleeCtx, ?realReturnVar),
  AssignReturnValue(?i, ?ret).

// Helper relation: implementing method is an instance method.
.decl CalledInstanceImplMethod(?invokedynamic:DynamicMethodInvocation_Insn, ?implMethod:Method, ?this:Var, ?thisType:Type, ?calleeCtx:configuration.Context, ?lambda:Lambda)
CalledInstanceImplMethod(?invokedynamic, ?implMethod, ?this, ?thisType, ?calleeCtx, ?lambda) :-
  LambdaCallGraphEdge(_, _, ?calleeCtx, ?implMethod, ?lambda),
  !Method_Modifier("static", ?implMethod),
  LambdaObject(?invokedynamic, ?lambda, _, _, ?implMethod, _, _),
  ThisVar(?implMethod, ?this),
  Var_Type(?this, ?thisType).

// Helper relation: instance methods may implicitly consume one of the
// K or N arguments for the receiver (shifting them by 1), while
// static methods take all K arguments before N ones.
.decl Params_ReceiverShiftRight(?lambda:Lambda, ?implMethod:Method, ?shiftK:number, ?shiftN:number)
Params_ReceiverShiftRight(?lambda, ?implMethod, 0, 0) :-
  LambdaObject(_, ?lambda, _, _, ?implMethod, _, _),
  Method_Modifier("static", ?implMethod).
// No bootstrap arguments = an actual argument will be used for 'this'.
Params_ReceiverShiftRight(?lambda, ?implMethod, 0, 1) :-
  CalledInstanceImplMethod(?invokedynamic, ?implMethod, _, _, _, ?lambda),
  DynamicMethodInvocation_DynArity(?invokedynamic, 0).
// First bootstrap argument exists, will be used for 'this'.
Params_ReceiverShiftRight(?lambda, ?implMethod, 1, 0) :-
  CalledInstanceImplMethod(?invokedynamic, ?implMethod, _, _, _, ?lambda),
  LambdaCaptured(?invokedynamic, _, 0, _).

// Pass invocation arguments to the implementing method.
VarPointsTo(?hctx, ?val, ?calleeCtx, ?formal) :-
  LambdaCallGraphEdge(_, ?i, ?calleeCtx, ?implMethod, ?lambda),
  Params_ReceiverShiftRight(?lambda, ?implMethod, ?shiftK, ?shiftN),
  LambdaObject(_, ?lambda, _, ?K, ?implMethod, _, _),
  ActualParam(?idx, ?i, ?actual),
  FormalParam(?K - ?shiftK + ?idx - ?shiftN, ?implMethod, ?formal),
  VarPointsTo(?hctx, ?val, _, ?actual),
  Value_Type(?val, ?valType),
  Var_Type(?actual, ?actualType),
  Var_Type(?formal, ?formalType),
  // Check type compatibility (including (un)boxing).
  basic.SubtypeOf(?valType, ?formalType).

// Pass captured arguments to the implementing method.
VarPointsTo(?hctx, ?val, ?calleeCtx, ?formal) :-
  LambdaCallGraphEdge(_, _, ?calleeCtx, ?implMethod, ?lambda),
  Params_ReceiverShiftRight(?lambda, ?implMethod, ?shiftK, _),
  LambdaObject(?invokedynamic, ?lambda, _, ?K, ?implMethod, _, _),
  LambdaCaptured(?invokedynamic, ?val, ?idx, ?hctx),
  ?idx + ?shiftK <= ?K,
  FormalParam(?idx - ?shiftK, ?implMethod, ?formal),
  Value_Type(?val, ?valType),
  Var_Type(?formal, ?formalType),
  basic.SubtypeOf(?valType, ?formalType).

// Special handling for captured "this" parameters.
VarPointsTo(?hctx, ?thisValue, ?calleeCtx, ?this) :-
  Params_ReceiverShiftRight(?lambda, ?implMethod, 1, 0),
  CalledInstanceImplMethod(?invokedynamic, ?implMethod, ?this, ?thisType, ?calleeCtx, ?lambda),
  LambdaCaptured(?invokedynamic, ?thisValue, 0, ?hctx),
  Value_Type(?thisValue, ?thisValueType),
  basic.SubtypeOf(?thisValueType, ?thisType).

// Special handling for "this" parameters to method references that do
// not capture a receiver.
VarPointsTo(?hctx, ?argValue, ?calleeCtx, ?this) :-
  LambdaCallGraphEdge(?callerCtx, ?i, ?calleeCtx, ?implMethod, ?lambda),
  Params_ReceiverShiftRight(?lambda, ?implMethod, 0, 1),
  ActualParam(0, ?i, ?actual),
  VarPointsTo(?hctx, ?argValue, ?callerCtx, ?actual),
  Value_Type(?argValue, ?argType),
  ThisVar(?implMethod, ?this),
  Var_Type(?this, ?thisType),
  basic.SubtypeOf(?argType, ?thisType).

// Applications of constructor references construct values. However,
// these values do not come from a 'new' instruction in the code but
// are created here as mock values, one per type/invocation.
MockValueConsMacro(?mockObj, ?type),
VarPointsTo(?hctx, ?mockObj, ?callerCtx, ?var),
VarPointsTo(?hctx, ?mockObj, ?calleeCtx, ?thisVar) :-
  LambdaCallGraphEdge(?callerCtx, ?i, ?calleeCtx, ?implMethod, _),
  Method_SimpleName(?implMethod, "<init>"),
  Method_DeclaringType(?implMethod, ?type),
  AssignReturnValue(?i, ?var),
  ThisVar(?implMethod, ?thisVar),
  ?mockObj = cat("mock ", cat(?type, cat(" constructed by constructor reference at ", ?i))),
  isImmutableHContext(?hctx).

#ifdef REFLECTION_METHOD_HANDLES
#ifdef REFLECTION

/**
 * Naive model of Class.getDeclaredConstructors() without back-propagation of
 * special values. Needed since the invokedynamic handling does not propagate
 * these special values up to their uses.
 */

.decl FillConstructorsFromClass(?hctx:configuration.HContext, ?mockConstructors:Value, ?class:Type)

#define GET_DECLARED_METHODS "<java.lang.Class: java.lang.reflect.Method[] getDeclaredMethods()>"
#define GET_DECLARED_CONSRUCTORS "<java.lang.Class: java.lang.reflect.Constructor[] getDeclaredConstructors()>"
.decl Class_getMembers(?sig:Method, ?hctx:configuration.HContext, ?ctx:configuration.Context, ?ret:Var, ?class:Type)

Class_getMembers(?sig, ?hctx, ?ctx, ?ret, ?class) :-
  _VirtualMethodInvocation(?invo, _, ?sig, ?base, ?method),
  (?sig = GET_DECLARED_CONSTRUCTORS ; ?sig = GET_DECLARED_METHODS),
  ReachableContext(?ctx, ?method),
  VarPointsTo(?hctx, ?classValue, ?ctx, ?base),
  ReifiedClass(?class, ?classValue),
  ApplicationClass(?class),
  AssignReturnValue(?invo, ?ret).

MockValueConsMacro(?mockConstructors, "java.lang.reflect.Constructor[]"),
VarPointsTo(?hctx, ?mockConstructors, ?ctx, ?ret),
FillConstructorsFromClass(?hctx, ?mockConstructors, ?class) :-
  Class_getMembers(GET_DECLARED_CONSTRUCTORS, ?hctx, ?ctx, ?ret, ?class),
  ?mockConstructors = cat("mock constructors array for ", ?class).

ArrayIndexPointsTo(?immHctx, ?constructor, ?hctx, ?mockConstructors) :-
  FillConstructorsFromClass(?hctx, ?mockConstructors, ?class),
  Method_DeclaringType(?method, ?class),
  Method_SimpleName(?method, "<init>"),
  ReifiedConstructor(?method, ?constructor),
  isImmutableHContext(?immHctx).

MockValueConsMacro(?mockMethods, "java.lang.reflect.Method[]"),
VarPointsTo(?hctx, ?mockMethods, ?ctx, ?ret),
FillConstructorsFromClass(?hctx, ?mockMethods, ?class) :-
  Class_getMembers(GET_DECLARED_METHODS, ?hctx, ?ctx, ?ret, ?class),
  ?mockMethods = cat("mock methods array for ", ?class).

ArrayIndexPointsTo(?immHctx, ?methodValue, ?hctx, ?mockMethods) :-
  FillConstructorsFromClass(?hctx, ?mockMethods, ?class),
  Method_DeclaringType(?method, ?class),
  ReifiedMethod(?method, ?methodValue),
  isImmutableHContext(?immHctx).

#endif // REFLECTION
#endif // REFLECTION_METHOD_HANDLES
