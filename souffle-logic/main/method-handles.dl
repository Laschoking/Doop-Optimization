/*************************************************************
 * Method Types
 *************************************************************/

.type MethodType = mainAnalysis.Value
.decl MethodType_ParamType(?mt:MethodType, ?index:number, ?pType:Type)
.decl MethodType_ParamTypes(?mt:MethodType, ?paramTypes:symbol)
.decl MethodType_ReturnType(?mt:MethodType, ?retType:Type)
.decl MethodType_Arity(?mt:MethodType, ?arity:number)

MethodType_ParamType(?mt, ?idx, ?type)  :- _MethodTypeConstantParam(?mt, ?idx, ?type).
MethodType_Arity(?mt, ?arity)           :- MethodTypeConstant_Arity(?mt, ?arity).
MethodType_ReturnType(?mt, ?retType)    :- MethodTypeConstant_ReturnType(?mt, ?retType).
MethodType_ParamTypes(?mt, ?paramTypes) :- MethodTypeConstant_ParamTypes(?mt, ?paramTypes).

// Convert method descriptors to method types.
MethodType_ParamType(?descriptor, ?index, ?pType) :-
  Method_Descriptor(?method, ?descriptor),
  FormalParam(?index, ?method, ?var),
  _Var_Type(?var, ?pType).
MethodType_Arity(?descriptor, ?arity),
MethodType_ReturnType(?descriptor, ?retType) :-
  Method_Descriptor(?method, ?descriptor),
  Method_ReturnType(?method, ?retType),
  Method_Arity(?method, ?arity).

#ifdef REFLECTION_METHOD_HANDLES
#ifdef REFLECTION

// Model of MethodType.returnType().
VarPointsTo(?hctx, ?classValue, ?ctx, ?ret) :-
  _VirtualMethodInvocation(?invo, _, "<java.lang.invoke.MethodType: java.lang.Class returnType()>", ?base, ?method),
  ReachableContext(?ctx, ?method),
  VarPointsTo(?hctx, ?mt, ?ctx, ?base),
  MethodType_ReturnType(?mt, ?retType),
  ReifiedClass(?retType, ?classValue),
  AssignReturnValue(?invo, ?ret).

// Imprecise model of MethodType.parameterType(), since we do not track
// primitive values (for its argument).
VarPointsTo(?hctx, ?classValue, ?ctx, ?ret) :-
  _VirtualMethodInvocation(?invo, _, "<java.lang.invoke.MethodType: java.lang.Class parameterType(int)>", ?base, ?method),
  ReachableContext(?ctx, ?method),
  VarPointsTo(?hctx, ?mt, ?ctx, ?base),
  MethodType_ParamType(?mt, _, ?pType),
  ReifiedClass(?pType, ?classValue),
  AssignReturnValue(?invo, ?ret).

// MethodType API entry points. The actual logic: every methodType()
// invocation picks all descriptors that match.

.decl ReachableMethodTypeN(?invo:MethodInvocation, ?caller:Method, ?callerCtx:configuration.Context)
ReachableMethodTypeN(?invo, ?caller, ?callerCtx) :-
  MTEntryPoint(_, ?invo, _),
  Instruction_Method(?invo, ?caller),
  ReachableContext(?callerCtx, ?caller).

.decl MT_ReturnType(?invo:MethodInvocation, ?type:Type)
.decl MT_ParamValue(?invo:MethodInvocation, ?index:number, ?classValue:Value)

// The first argument to methodType() is always the return type.
MT_ReturnType(?invo, ?type) :-
  ReachableMethodTypeN(?invo, _, _),
  ActualParam(0, ?invo, ?param),
  VarPointsTo(_, ?classValue, _, ?param),
  ReifiedClass(?type, ?classValue).

// MethodType2, MethodType4: second parameter.
MT_ParamValue(?invo, 0, ?classValue) :-
  ( MTEntryPoint(2, ?invo, _) ; MTEntryPoint(4, ?invo, _) ),
  Instruction_Method(?invo, ?caller),
  ReachableContext(_, ?caller),
  ActualParam(1, ?invo, ?param),
  VarPointsTo(_, ?classValue, _, ?param).

// MethodType1 lacks a parameter, so we use a dummy value instead.
#define MT_NOARGS_VALUE "<mock dummy methodType() class for first argument>"
MockValueConsMacro(MT_NOARGS_VALUE, "java.lang.Class"),
MT_ParamValue(?invo, 0, MT_NOARGS_VALUE) :-
  MTEntryPoint(1, ?invo, _).

// Helper relation to treat 'void' and 'java.lang.Void' as the same
// type in descriptors.
.decl MTReturnTypeMatchesDescriptor(?invo:MethodInvocation, ?descriptor:symbol)

MTReturnTypeMatchesDescriptor(?invo, ?descriptor) :-
  MT_ReturnType(?invo, "java.lang.Void"),
  MethodType_ReturnType(?descriptor, "void").
MTReturnTypeMatchesDescriptor(?invo, ?descriptor) :-
  MT_ReturnType(?invo, ?rType),
  MethodType_ReturnType(?descriptor, ?rType).

.decl MTCallMatchesDescriptor(?invo:MethodInvocation, ?descriptor:symbol)

// MethodType1.
MTCallMatchesDescriptor(?invo, ?descriptor) :-
  MTEntryPoint(1, ?invo, _),
  MTReturnTypeMatchesDescriptor(?invo, ?descriptor),
  MT_ParamValue(?invo, 0, MT_NOARGS_VALUE),
  MethodType_Arity(?descriptor, 0).

// MethodType2.
MTCallMatchesDescriptor(?invo, ?descriptor) :-
  MTEntryPoint(2, ?invo, _),
  MTReturnTypeMatchesDescriptor(?invo, ?descriptor),
  MT_ParamValue(?invo, 0, ?classValue0),
  ReifiedClass(?pType0, ?classValue0),
  MethodType_ParamType(?descriptor, 0, ?pType0),
  MethodType_Arity(?descriptor, 1).

.decl MTValue_Descriptor(?mt:Value, ?descriptor:symbol)

#define MT_VALUE(desc) cat("<mock MethodType ", cat(desc, ">"))

// Make methodType() return special descriptors.
MockValueConsMacro(MT_VALUE(?descriptor), "java.lang.invoke.MethodType"),
MTValue_Descriptor(MT_VALUE(?descriptor), ?descriptor),
VarPointsTo(?hctx, MT_VALUE(?descriptor), ?callerCtx, ?ret) :-
  ReachableMethodTypeN(?invo, ?caller, ?callerCtx),
  MTCallMatchesDescriptor(?invo, ?descriptor),
  AssignReturnValue(?invo, ?ret),
  isImmutableHContext(?hctx).

#endif // REFLECTION
#endif // REFLECTION_METHOD_HANDLES

/*************************************************************
 * Method Handles
 *************************************************************/

HeapAllocation_ContextInsensitive(?heap) :-
  isMethodHandleConstant(?heap).

.type MethodHandle = mainAnalysis.Value
.decl MethodHandle_Method(?methodHandle:MethodHandle, ?method:Method)
.decl MethodHandle_ParamTypes(?heap:MethodHandleConstant, ?paramTypes:symbol)
.decl MethodHandle_ReturnType(?methodHandle:MethodHandle, ?retType:Type)

MethodHandle_Method(?methodHandle, ?method) :-
  MethodHandleConstant_Method(?methodHandle, ?method).

MethodHandle_ReturnType(?methodHandle, ?type) :- MethodHandleConstant_ReturnType(?methodHandle, ?type).
MethodHandle_ParamTypes(?methodHandle, ?paramTypes) :- MethodHandleConstant_ParamTypes(?methodHandle, ?paramTypes).

// Invocations of a MethodHandle. These can either be explicit calls to
// MethodHandle.invoke()/invokeExact() or implicit calls via invokedynamic.
.decl MethodHandleCallGraphEdge(?callerCtx:configuration.Context, ?i:MethodInvocation, ?calleeCtx:configuration.Context, ?m:Method, ?mh:MethodHandle, ?name:symbol)

MethodHandleCallGraphEdge(?callerCtx, ?invo, ?calleeCtx, ?method, ?mh, ?name) :-
  // Permit treatment of invoke methods as opaque.
  (_VirtualMethodInvocation(?invo, _, _, ?base, ?containingMethod) ;
   _SpecialMethodInvocation(?invo, _, _, ?base, ?containingMethod)),
  _MethodHandleInvocation(?invo, ?name),
  ReachableContext(?callerCtx, ?containingMethod),
  VarPointsTo(_, ?mh, ?callerCtx, ?base),
  MethodHandle_Method(?mh, ?method),
  // TODO: context sensitivity in the callee.
  isImmutableContext(?calleeCtx).
ReachableContext(?calleeCtx, ?method) :-
  MethodHandleCallGraphEdge(_, _, ?calleeCtx, ?method, _, _).

// A boxing/unboxing conversion of types including the null type.
.decl BoxTypeConversion(?original:Type, ?new:Type)
// Create a new allocation in the case of boxing.
.decl BoxAllocation(?value:Value, ?type:Type)
#define BOX_ALLOC(t) cat("mock box allocation for type ", t)

BoxTypeConversion(?t1, ?t2),
MockValueConsMacro(?mockAlloc, ?t2),
BoxAllocation(?mockAlloc, ?t2) :-
  PrimitiveType_Boxed(?t1, ?wrapperT),
  basic.SubtypeOf(?wrapperT, ?t2),
  ?mockAlloc = BOX_ALLOC(?t2).
BoxTypeConversion(?t1, ?t2) :- PrimitiveType_Boxed(?t1, _), isNullType(?t2).
BoxTypeConversion(?t1, ?t2) :- PrimitiveType_Boxed(_, ?t2), isNullType(?t1).
BoxTypeConversion(?t1, ?t2) :- BoxTypeConversion(?t2, ?t1).

.decl ConversibleTypes(?t:Type, ?tConv:Type)
ConversibleTypes(?t, ?tConv) :- basic.SubtypeOf(?tConv, ?t).
ConversibleTypes(?t, ?tConv) :- BoxTypeConversion(?t, ?tConv).

// Pass arguments to static methods.
VarPointsTo(?hctx, ?val, ?calleeCtx, ?formal) :-
  MethodHandleCallGraphEdge(?callerCtx, ?invo, ?calleeCtx, ?method, _, _),
  Method_Modifier("static", ?method),
  ActualParam(?idx, ?invo, ?actual),
  VarPointsTo(?hctx, ?val, ?callerCtx, ?actual),
  FormalParam(?idx, ?method, ?formal),
  Var_Type(?actual, ?actualType),
  Var_Type(?formal, ?formalType),
  ConversibleTypes(?actualType, ?formalType).

// Pass arguments to instance methods (first argument becomes the receiver).
VarPointsTo(?hctx, ?val, ?calleeCtx, ?formal) :-
  MethodHandleCallGraphEdge(?callerCtx, ?invo, ?calleeCtx, ?method, _, _),
  !Method_Modifier("static", ?method),
  ActualParam(?idx, ?invo, ?actual),
  ?idx > 0,
  VarPointsTo(?hctx, ?val, ?callerCtx, ?actual),
  FormalParam(?idx - 1, ?method, ?formal),
  Var_Type(?actual, ?actualType),
  Var_Type(?formal, ?formalType),
  ConversibleTypes(?actualType, ?formalType).
VarPointsTo(?hctx, ?val, ?calleeCtx, ?this) :-
  MethodHandleCallGraphEdge(?callerCtx, ?invo, ?calleeCtx, ?method, _, _),
  !Method_Modifier("static", ?method),
  ActualParam(0, ?invo, ?actual),
  VarPointsTo(?hctx, ?val, ?callerCtx, ?actual),
  ThisVar(?method, ?this),
  Var_Type(?actual, ?actualType),
  Var_Type(?this, ?thisType),
  ConversibleTypes(?actualType, ?thisType).

// Get return value.
VarPointsTo(?hctx, ?val, ?callerCtx, ?var) :-
  MethodHandleCallGraphEdge(?callerCtx, ?invo, ?calleeCtx, ?method, _, _),
  ReturnVar(?ret, ?method),
  VarPointsTo(?hctx, ?val, ?calleeCtx, ?ret),
  AssignReturnValue(?invo, ?var),
  Var_Type(?ret, ?retType),
  Var_Type(?var, ?varType),
  ConversibleTypes(?retType, ?varType).

// Model MethdHandle.asType().
MockValueConsMacro(?adapterMH, "java.lang.invoke.MethodHandle"),
MethodHandle_Method(?adapterMH, ?mhMethod),
MethodHandle_ReturnType(?adapterMH, ?retType),
MethodHandle_ParamTypes(?adapterMH, ?paramTypes),
VarPointsTo(?hctx, ?adapterMH, ?ctx, ?ret) :-
  _VirtualMethodInvocation(?invo, _, ?sig, ?base, ?method),
  ReachableContext(?ctx, ?method),
  ?sig = "<java.lang.invoke.MethodHandle: java.lang.invoke.MethodHandle asType(java.lang.invoke.MethodType)>",
  VarPointsTo(?hctx, ?mh, ?ctx, ?base),
  ActualParam(0, ?invo, ?arg),
  VarPointsTo(_, ?mt, ?ctx, ?arg),
  AssignReturnValue(?invo, ?ret),
  MethodHandle_Method(?mh, ?mhMethod),
  MethodType_ReturnType(?mt, ?retType),
  Method_Params(?mhMethod, ?paramTypes),
  ?adapterMH = cat("<adapter for ", cat(?mh, cat(" as ", ?mt))).

/*************************************************************
 * Method Handles Lookup
 *************************************************************/

.decl MHLookup_Type(?value:Value, ?type:Type)
#define MOCK_MH_LOOKUP(t) cat("mock method handles lookup object for type ", t)

#ifdef REFLECTION_METHOD_HANDLES
#ifdef REFLECTION

// Model of MethodHandles.lookup().
MockValueConsMacro(?mockMHLookup, "java.lang.invoke.MethodHandles$Lookup"),
MHLookup_Type(?mockMHLookup, ?type),
VarPointsTo(?immHctx, ?mockMHLookup, ?immCtx, ?ret) :-
  _StaticMethodInvocation(?invo, _, "<java.lang.invoke.MethodHandles: java.lang.invoke.MethodHandles$Lookup lookup()>", ?method),
  ReachableContext(?ctx, ?method),
  Method_DeclaringType(?method, ?type),
  ReifiedClass(?type, ?typeValue),
  AssignReturnValue(?invo, ?ret),
  isImmutableContext(?immCtx),
  isImmutableHContext(?immHctx),
  ?mockMHLookup = MOCK_MH_LOOKUP(?type).

// Model of MethodHandles.Lookup.lookupClass().
VarPointsTo(?hctx, ?classValue, ?ctx, ?ret) :-
  _VirtualMethodInvocation(?invo, _, "<java.lang.invoke.MethodHandles$Lookup: java.lang.Class lookupClass()>", ?base, ?method),
  ReachableContext(?ctx, ?method),
  VarPointsTo(?hctx, ?mhLookup, ?ctx, ?base),
  MHLookup_Type(?mhLookup, ?type),
  ReifiedClass(?type, ?classValue),
  AssignReturnValue(?invo, ?ret).

// Helper relation to only create direct method handles when no constant method
// handles are found. Used when computing the handle to store in a variable.
.decl AssignMethodHandleToVarRequest(?method:Method, ?retType:Type, ?hctx:configuration.HContext, ?ctx:configuration.Context, ?ret:Var)
// Case 1: method handle constant exists.
VarPointsTo(?hctx, ?mh, ?ctx, ?var) :-
  AssignMethodHandleToVarRequest(?method, ?retType, ?hctx, ?ctx, ?var),
  MethodHandleConstant_Method(?mh, ?method),
  MethodHandleConstant_ReturnType(?mh, ?retType).
// Case 2: method handle constant not found, invent a mock object.
MockValueConsMacro(?dmh, "java.lang.invoke.MethodHandle"),
MethodHandle_Method(?dmh, ?method),
MethodHandle_ParamTypes(?dmh, ?params),
MethodHandle_ReturnType(?dmh, ?retType),
VarPointsTo(?hctx, ?dmh, ?ctx, ?var) :-
  AssignMethodHandleToVarRequest(?method, ?retType, ?hctx, ?ctx, ?var),
  !MethodHandleConstant_Method(_, ?method),
  Method_Params(?method, ?params),
  ?dmh = cat("<computed direct method handle for ", cat(?method, ">")).

// Model conversions from reflection Method to method handle.
AssignMethodHandleToVarRequest(?method, ?retType, ?hctx, ?ctx, ?ret) :-
  ( MethodInvocation_Method(?invo, "<java.lang.invoke.MethodHandles$Lookup: java.lang.invoke.MethodHandle unreflect(java.lang.reflect.Method)>") ;
  MethodInvocation_Method(?invo, "<java.lang.invoke.MethodHandles$Lookup: java.lang.invoke.MethodHandle unreflectSpecial(java.lang.reflect.Method,java.lang.Class)>")),
  Instruction_Method(?invo, ?caller),
  ReachableContext(?ctx, ?caller),
  ActualParam(0, ?invo, ?arg),
  VarPointsTo(?hctx, ?methodValue, ?ctx, ?arg),
  ReifiedMethod(?method, ?methodValue),
  Method_ReturnType(?method, ?retType),
  AssignReturnValue(?invo, ?ret).
AssignMethodHandleToVarRequest(?method, ?retType, ?hctx, ?ctx, ?ret) :-
  MethodInvocation_Method(?invo, "<java.lang.invoke.MethodHandles$Lookup: java.lang.invoke.MethodHandle unreflectConstructor(java.lang.reflect.Constructor)>"),
  Instruction_Method(?invo, ?caller),
  ReachableContext(?ctx, ?caller),
  ActualParam(0, ?invo, ?arg),
  VarPointsTo(?hctx, ?constructor, ?ctx, ?arg),
  ReifiedConstructor(?method, ?constructor),
  Method_ReturnType(?method, ?retType),
  AssignReturnValue(?invo, ?ret).

#endif // REFLECTION
#endif // REFLECTION_METHOD_HANDLES

// Method lookup methods.

.decl FindVirtual(?invo:MethodInvocation)
FindVirtual(?invo) :-
  MethodInvocation_Method(?invo, "<java.lang.invoke.MethodHandles$Lookup: java.lang.invoke.MethodHandle findVirtual(java.lang.Class,java.lang.String,java.lang.invoke.MethodType)>"),
  Instruction_Method(?invo, ?caller),
  ReachableContext(_, ?caller).

.decl FindStatic(?invo:MethodInvocation)
FindStatic(?invo) :-
  MethodInvocation_Method(?invo, "<java.lang.invoke.MethodHandles$Lookup: java.lang.invoke.MethodHandle findStatic(java.lang.Class,java.lang.String,java.lang.invoke.MethodType)>"),
  Instruction_Method(?invo, ?caller),
  ReachableContext(_, ?caller).

.decl MethodFinder(?invo:MethodInvocation, ?ret:Var)
MethodFinder(?invo, ?ret) :-
  ( FindStatic(?invo) ; FindVirtual(?invo) ),
  VirtualMethodInvocation_Base(?invo, ?lookup),
  VarPointsTo(_, ?baseVal, _, ?lookup),
  !Value_Null(?baseVal),
  AssignReturnValue(?invo, ?ret).

#ifdef REFLECTION_METHOD_HANDLES
#ifdef REFLECTION

// Direct method handle lookup.
.decl DMHLookup(?type:Type, ?id:symbol, ?mt:Value, ?method:Method, ?retType:Type, ?paramTypes:symbol)

DMHLookup(?type, ?id, ?mt, ?method, ?retType, ?paramTypes) :-
  Method_DeclaringType(?method, ?type),
  Method_SimpleName(?method, ?id),
  Method_Descriptor(?method, ?descriptor),
  Method_ReturnType(?method, ?retType),
  Method_Params(?method, ?paramTypes),
  MTValue_Descriptor(?mt, ?descriptor).

// Create VarPointsTo for return values of method finders.
AssignMethodHandleToVarRequest(?method, ?retType, ?hctx, ?ctx, ?ret) :-
  MethodFinder(?invo, ?ret),
  ActualParam(0, ?invo, ?classParam),
  VarPointsTo(?hctx, ?classValue, ?ctx, ?classParam),
  ReifiedClass(?type, ?classValue),
  ActualParam(1, ?invo, ?stringParam),
  VarPointsTo(_, ?id, _, ?stringParam),
  ActualParam(2, ?invo, ?mtParam),
  VarPointsTo(_, ?mt, _, ?mtParam),
  DMHLookup(?type, ?id, ?mt, ?method, ?retType, _).
  // MethodType_ParamTypes(?mt, ?paramTypes),
  // DMHLookup(?type, ?id, ?mt, ?method, ?retType, ?paramTypes).

#endif // REFLECTION
#endif // REFLECTION_METHOD_HANDLES

// Create a receiver object when calling constructors.
MockValueConsMacro(?value, ?type),
VarPointsTo(?hctx, ?value, ?calleeCtx, ?thisVar),
VarPointsTo(?hctx, ?value, ?callerCtx, ?ret) :-
  MethodHandleCallGraphEdge(?callerCtx, ?invo, ?calleeCtx, ?method, ?mh, _),
  Method_SimpleName(?method, "<init>"),
  ThisVar(?method, ?thisVar),
  Method_DeclaringType(?method, ?type),
  isImmutableHContext(?hctx),
  ?value = cat(?type, cat(" value constructed by method handle ", ?mh)),
  AssignReturnValue(?invo, ?ret).

/*************************************************************
 * Generic invokedynamic
 *************************************************************/

.decl ReachableInvokedynamic(?invokedynamic:DynamicMethodInvocation_Insn, ?dynName:symbol, ?dynRetType:Type, ?ctx:configuration.Context)
ReachableInvokedynamic(?invokedynamic, ?dynName, ?dynRetType, ?ctx) :-
  isDynamicMethodInvocation_Insn(?invokedynamic),
  Instruction_Method(?invokedynamic, ?inMethod),
  DynamicMethodInvocation_DynName(?invokedynamic, ?dynName),
  DynamicMethodInvocation_DynReturnType(?invokedynamic, ?dynRetType),
  ReachableContext(?ctx, ?inMethod).

// Helper relation to make bootstrap method context configurable.
.decl isBootstrapMethodContext(?ctx:configuration.Context)
isBootstrapMethodContext(?ctx) :- isImmutableContext(?ctx).

// Call-graph edge: invokedynamic instruction -> boot method.
.decl InvokedynamicBootCallGraphEdge(?callerCtx:configuration.Context, ?invokedynamic:DynamicMethodInvocation_Insn, ?calleeCtx:configuration.Context, ?bootMethod:Method)
InvokedynamicBootCallGraphEdge(?callerCtx, ?invokedynamic, ?calleeCtx, ?bootMethod) :-
  ReachableInvokedynamic(?invokedynamic, _, _, ?callerCtx),
  DynamicMethodInvocation_Bootstrap(?invokedynamic, ?bootMethod),
  isBootstrapMethodContext(?calleeCtx).

ReachableContext(?calleeCtx, ?bootMethod) :-
  InvokedynamicBootCallGraphEdge(_, _, ?calleeCtx, ?bootMethod).

.decl Invokedynamic_MethodType(?invokedynamic:DynamicMethodInvocation_Insn, ?mt:MethodType)
#define MOCK_MT(retType, paramTypes) cat("mock method type ", cat(retType, paramTypes))
.decl PopulateMTParamTypes(?mt:Value, ?invokedynamic:DynamicMethodInvocation_Insn)

// For every reachable invokedynamic, create a mock method type.
MockValueConsMacro(?mockMethodType, "java.lang.invoke.MethodType"),
MethodType_ReturnType(?mockMethodType, ?dynRetType),
PopulateMTParamTypes(?mockMethodType, ?invokedynamic),
Invokedynamic_MethodType(?invokedynamic, ?mockMethodType) :-
  InvokedynamicBootCallGraphEdge(_, ?invokedynamic, _, _),
  DynamicMethodInvocation_DynReturnType(?invokedynamic, ?dynRetType),
  DynamicMethodInvocation_DynParamTypes(?invokedynamic, ?dynParamTypes),
  ?mockMethodType = MOCK_MT(?dynRetType, ?dynParamTypes).
MethodType_ParamType(?mt, ?index, ?pType) :-
  PopulateMTParamTypes(?mt, ?invokedynamic),
  _DynamicMethodInvocation_DynParamType(?invokedynamic, ?index, ?pType).

// Pass arguments to bootstrap methods. First three arguments are
// filled in by the JVM, so we fill them with mock objects.
MockValueConsMacro(?mockMHLookup, "java.lang.invoke.MethodHandles$Lookup"),
MHLookup_Type(?mockMHLookup, ?callerClass),
VarPointsTo(?immHctx, ?mockMHLookup, ?calleeCtx, ?caller),
VarPointsTo(?immHctx, ?mockMethodType, ?calleeCtx, ?invokedTypeParam) :-
  InvokedynamicBootCallGraphEdge(_, ?invokedynamic, ?calleeCtx, ?bootMethod),
  FormalParam(0, ?bootMethod, ?caller),
  FormalParam(2, ?bootMethod, ?invokedTypeParam),
  DynamicMethodInvocation_DynReturnType(?invokedynamic, ?dynRetType),
  DynamicMethodInvocation_DynParamTypes(?invokedynamic, ?dynParamTypes),
  Invokedynamic_MethodType(?invokedynamic, ?mockMethodType),
  isImmutableHContext(?immHctx),
  Instruction_Method(?invokedynamic, ?method),
  Method_DeclaringType(?method, ?callerClass),
  ?mockMHLookup = MOCK_MH_LOOKUP(?callerClass).

// The second-arg rule should only be enabled when strings are not merged.
#if defined(DISTINGUISH_REFLECTION_ONLY_STRING_CONSTANTS) || defined(DISTINGUISH_ALL_STRING_CONSTANTS) || defined(NO_MERGES)
VarPointsTo(?immHctx, ?invokedName, ?calleeCtx, ?invokedNameParam) :-
  InvokedynamicBootCallGraphEdge(_, ?invokedynamic, ?calleeCtx, ?bootMethod),
  isStringConstant(?invokedName),
  FormalParam(1, ?bootMethod, ?invokedNameParam),
  DynamicMethodInvocation_DynName(?invokedynamic, ?invokedName),
  isImmutableHContext(?immHctx).
#endif // DISTINGUISH_REFLECTION_ONLY_STRING_CONSTANTS || DISTINGUISH_ALL_STRING_CONSTANTS || NO_MERGES

// Helper method to compute the varargs accumulator formal of a method.
.decl MethodVarArgs(?method:Method, ?idx:number, ?formal:Var, ?type:ArrayType)
MethodVarArgs(?method, ?idx, ?formal, ?type) :-
  Method_Modifier("varargs", ?method),
  Method_Arity(?method, ?arity),
  ?idx = ?arity - 1,
  FormalParam(?idx, ?method, ?formal),
  Var_Type(?formal, ?type),
  isArrayType(?type).

// Use a mock array to fix calls to a bootstrap method accepting varargs.
#define MOCK_ARRAY(invokedynamic) cat("bootstrap varargs array for ", invokedynamic)

ArrayIndexPointsTo(?immHctx, ?val, ?immHctx, ?mockArray),
MockValueConsMacro(?mockArray, ?varArgsType),
VarPointsTo(?immHctx, ?mockArray, ?calleeCtx, ?formalVarArgs) :-
  InvokedynamicBootCallGraphEdge(?callerCtx, ?invokedynamic, ?calleeCtx, ?bootMethod),
  MethodVarArgs(?bootMethod, ?bootIdx, ?formalVarArgs, ?varArgsType),
  BootstrapParam(?idx, ?invokedynamic, ?actual),
  ?idx > ?bootIdx - 3,
  VarPointsTo(_, ?val, _, ?actual),
  isImmutableHContext(?immHctx),
  ?mockArray = MOCK_ARRAY(?invokedynamic).

// Normal handling for the last three arguments of the bootstrap method, shifted.
VarPointsTo(?immHctx, ?val, ?calleeCtx, ?formal) :-
  InvokedynamicBootCallGraphEdge(_, ?invokedynamic, ?calleeCtx, ?bootMethod),
  !Method_Modifier("varargs", ?bootMethod),
  FormalParam(?idx + 3, ?bootMethod, ?formal),
  BootstrapParam(?idx, ?invokedynamic, ?actual),
  VarPointsTo(_, ?val, _, ?actual),
  isImmutableHContext(?immHctx).

.type CallSite = mainAnalysis.Value
.decl InvokedynamicCallSite(?callsite:CallSite, ?invokedynamic:DynamicMethodInvocation_Insn, ?dynName:symbol, ?K:number, ?dynRetType:Type, ?ctx:configuration.Context)

// Record CallSite metadata.
InvokedynamicCallSite(?callsite, ?invokedynamic, ?dynName, ?K, ?dynRetType, ?callerCtx) :-
  ReachableInvokedynamic(?invokedynamic, ?dynName, ?dynRetType, ?callerCtx),
  DynamicMethodInvocation_DynArity(?invokedynamic, ?K),
  DynamicMethodInvocation_Bootstrap(?invokedynamic, ?bootMethod),
  ReturnVar(?bootRetVar, ?bootMethod),
  isBootstrapMethodContext(?calleeCtx),
  VarPointsTo(_, ?callsite, ?calleeCtx, ?bootRetVar).

.decl CallSiteContents(?callsite:CallSite, ?methodHandle:MethodHandle, ?method:Method)
CallSiteContents(?callsite, ?methodHandle, ?method) :-
  InvokedynamicCallSite(?callsite, _, _, _, ?dynRetType, _),
  InstanceFieldPointsTo(_, ?methodHandle, "<java.lang.invoke.CallSite: java.lang.invoke.MethodHandle target>", _, ?callsite),
  MethodHandle_Method(?methodHandle, ?method),
  MethodHandle_ReturnType(?methodHandle, ?dynRetType).
// Method handle for C.<init> has dynamic return type C instead of "void".
CallSiteContents(?callsite, ?methodHandle, ?method) :-
  InvokedynamicCallSite(?callsite, _, _, _, ?dynRetType, _),
  InstanceFieldPointsTo(_, ?methodHandle, "<java.lang.invoke.CallSite: java.lang.invoke.MethodHandle target>", _, ?callsite),
  MethodHandle_Method(?methodHandle, ?method),
  Method_SimpleName(?method, "<init>"),
  Method_DeclaringType(?method, ?dynRetType).

// After a method handle is resolved, invokedynamic calls it, as if
// "invokeExact" was invoked on it. This is a call-graph edge from an
// invokedynamic instruction to the method invoked by the call site.

configuration.StaticContextRequest(?callerCtx, ?invokedynamic) :-
  InvokedynamicCallSite(?callsite, ?invokedynamic, _, _, _, ?callerCtx),
  CallSiteContents(?callsite, _, ?method),
  Method_Modifier("static", ?method).
MethodHandleCallGraphEdge(?callerCtx, ?invokedynamic, ?calleeCtx, ?method, ?mh, "invokeExact") :-
  InvokedynamicCallSite(?callsite, ?invokedynamic, _, _, _, ?callerCtx),
  CallSiteContents(?callsite, ?mh, ?method),
  configuration.StaticContextResponse(?callerCtx, ?invokedynamic, ?calleeCtx).

// General rule for non-static methods resolved by invokedynamic. This rule
// does not use the Request/Response schema, since we do not have a "value"
// for the receiver (call site resolution happens at load time).
MethodHandleCallGraphEdge(?callerCtx, ?invokedynamic, ?calleeCtx, ?method, ?mh, "invokeExact") :-
  InvokedynamicCallSite(?callsite, ?invokedynamic, _, _, ?dynRetType, ?callerCtx),
  CallSiteContents(?callsite, ?mh, ?method),
  !Method_Modifier("static", ?method),
  MethodHandle_ReturnType(?mh, ?mhRetType),
  ConversibleTypes(?mhRetType, ?dynRetType),
  isImmutableContext(?calleeCtx).

ReachableContext(?calleeCtx, ?callee) :-
  MethodHandleCallGraphEdge(_, _, ?calleeCtx, ?callee, _, _).

/*************************************************************
 * Lambda-specific invokedynamic
 *************************************************************/

/** Phase 1: Linkage (creating a lambda CallSite) **/

#define LAMBDA_METAFACTORY "<java.lang.invoke.LambdaMetafactory: java.lang.invoke.CallSite metafactory(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.invoke.MethodType,java.lang.invoke.MethodHandle,java.lang.invoke.MethodType)>"

#define LAMBDA_ALTMETAFACTORY "<java.lang.invoke.LambdaMetafactory: java.lang.invoke.CallSite altMetafactory(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.Object[])>"

// Find invocations to the lambda metafactories.
.decl LambdaMetafactoryInvoke(?invokedynamic:DynamicMethodInvocation_Insn)
LambdaMetafactoryInvoke(?invokedynamic) :-
  DynamicMethodInvocation_Bootstrap(?invokedynamic, ?method),
  (?method = LAMBDA_METAFACTORY ; ?method = LAMBDA_ALTMETAFACTORY).

.decl ReachableLambdaMetafactoryInvoke(?invokedynamic:DynamicMethodInvocation_Insn, ?ctx:configuration.Context)
ReachableLambdaMetafactoryInvoke(?invokedynamic, ?ctx) :-
  LambdaMetafactoryInvoke(?invokedynamic),
  ReachableInvokedynamic(?invokedynamic, _, _, ?ctx).

// Record invokedynamic invocations whose bootstrap methods are not
// handled at all. Used for statistics.
.decl UnhandledInvokedynamic(?invokedynamic:DynamicMethodInvocation_Insn, ?bootMethodId:symbol)

UnhandledInvokedynamic(?invokedynamic, ?bootMethodId) :-
  DynamicMethodInvocation_Bootstrap(?invokedynamic, ?bootMethodId),
  !LambdaMetafactoryInvoke(?invokedynamic).

#define LAMBDA_ALT_VAL(invo, ret, type, method, real, name) \
  cat(invo, cat("::: ", cat(ret, cat("::: (Mock)::: ", cat("reference ", cat(type, cat ("::", cat(method, cat(" from ", cat(real, cat(" wrapped as ", cat(ret, cat(".", name)))))))))))))

.type Lambda = mainAnalysis.Value
.decl LambdaCallSite(?callsite:CallSite, ?invokedynamic:DynamicMethodInvocation_Insn, ?lambda:Lambda, ?dynName:symbol, ?K:number, ?implMethod:Method, ?desc:symbol, ?ctx:configuration.Context)

#define LAMBDA(invokedynamic, type) \
  cat(invokedynamic, cat("::: ", cat(type, cat("::: (Mock)::: ", cat("lambda object of type ", type)))))

// Record more information about the call site to model the metafactory result.
MockValueConsMacro(?lambda, ?dynRetType),
LambdaCallSite(?callsite, ?invokedynamic, ?lambda, ?dynName, ?K, ?implMethod, ?desc, ?callerCtx) :-
  ReachableLambdaMetafactoryInvoke(?invokedynamic, ?callerCtx),
  InvokedynamicCallSite(?callsite, ?invokedynamic, ?dynName, ?K, ?dynRetType, ?callerCtx),
  BootstrapParam(1, ?invokedynamic, ?handleVar),
  VarPointsTo(_, ?handleVal, ?callerCtx, ?handleVar),
  MethodHandleConstant_Method(?handleVal, ?implMethod),
  // Used to generate friendly description for the lambda.
  Method_SimpleName(?implMethod, ?handleMeth),
  Method_DeclaringType(?implMethod, ?handleType),
  ?desc = LAMBDA_ALT_VAL(?invokedynamic, ?dynRetType, ?handleType, ?handleMeth, ?implMethod, ?dynName),
  ?lambda = LAMBDA(?invokedynamic, ?dynRetType).

// Return the mock lambda object.
VarPointsTo(?immHctx, ?lambda, ?ctx, ?ret) :-
  LambdaCallSite(_, ?invokedynamic, ?lambda, _, _, _, _, ?ctx),
  AssignReturnValue(?invokedynamic, ?ret),
  isImmutableHContext(?immHctx).

// // A helper filtering relation for metafactory bootstrap calls.

// .decl InvokedynamicMetafactoryCallGraphEdge(?callerCtx:configuration.Context, ?invokedynamic:DynamicMethodInvocation_Insn, ?calleeCtx:configuration.Context, ?bootMethod:Method)
// InvokedynamicMetafactoryCallGraphEdge(?callerCtx, ?invokedynamic, ?calleeCtx, ?metafactory) :-
//   ReachableLambdaMetafactoryInvoke(?invokedynamic, ?callerCtx),
//   InvokedynamicBootCallGraphEdge(?callerCtx, ?invokedynamic, ?calleeCtx, ?metafactory).

// .decl Lambda_N(?lambda:Lambda, ?N:number, ?samMethodType:Value)

// Lambda_N(?lambda, ?N, ?val) :-
//   InvokedynamicMetafactoryCallGraphEdge(?callerCtx, ?invokedynamic, _, ?metafactory),
//   ?metafactory = LAMBDA_METAFACTORY,
//   LambdaCallSite(_, ?invokedynamic, ?lambda, _, _, _, ?callerCtx),
//   BootstrapParam(0, ?invokedynamic, ?actual),
//   VarPointsTo(_, ?val, ?callerCtx, ?actual),
//   MethodTypeConstant_Arity(?val, ?N).

// Lambda_N(?lambda, ?N, ?val) :-
//   InvokedynamicMetafactoryCallGraphEdge(?callerCtx, ?invokedynamic, _, ?metafactory),
//   ?metafactory = LAMBDA_ALTMETAFACTORY,
//   LambdaCallSite(_, ?invokedynamic, ?lambda, _, _, _, ?callerCtx),
//   // TODO: this does not match contexts, so it loses precision.
//   ArrayIndexPointsTo(_, ?val, _, MOCK_ARRAY(?invokedynamic)),
//   MethodTypeConstant_Arity(?val, ?N).

/** Phase 2: Capture (invoke CallSite, return functional object) **/

/** Phase 3: Invocation (call method on the functional object) **/

// When a method is called on a lambda object constructed by a
// constant method handle, the real method is called. This can wrap a
// static method call as an instance method call.

// Call-graph edge: method invocation on lambda object -> implementing method.
.decl LambdaCallGraphEdge(?callerCtx:configuration.Context, ?i:MethodInvocation, ?calleeCtx:configuration.Context, ?m:Method, ?lambda:Lambda)

// Call-graph edge: method call on lambda object -> implementing
// method.  For simplicity, the callee context is trivial. For proper
// context sensitivity, we must model all combinations of calling
// contexts with implementing-method staticness.
LambdaCallGraphEdge(?callerCtx, ?i, ?calleeCtx, ?implMethod, ?lambda) :-
  LambdaCallSite(_, _, ?lambda, ?dynName, _, ?implMethod, _, _),
  VarPointsTo(_, ?lambda, ?callerCtx, ?var),
  VirtualMethodInvocation_Base(?i, ?var),
  VirtualMethodInvocation_SimpleName(?i, ?dynName),
  isImmutableContext(?calleeCtx).

ReachableContext(?calleeCtx, ?callee) :-
  LambdaCallGraphEdge(_, _, ?calleeCtx, ?callee, _).

// Handle return values for lambda call-graph edges.
VarPointsTo(?hctx, ?retVal, ?callerCtx, ?ret) :-
  LambdaCallGraphEdge(?callerCtx, ?i, ?calleeCtx, ?method, _),
  ReturnVar(?realReturnVar, ?method),
  VarPointsTo(?hctx, ?retVal, ?calleeCtx, ?realReturnVar),
  AssignReturnValue(?i, ?ret).

// Helper relation: implementing method is an instance method.
.decl CalledInstanceImplMethod(?invokedynamic:DynamicMethodInvocation_Insn, ?implMethod:Method, ?this:Var, ?thisType:Type, ?calleeCtx:configuration.Context, ?lambda:Lambda)
CalledInstanceImplMethod(?invokedynamic, ?implMethod, ?this, ?thisType, ?calleeCtx, ?lambda) :-
  LambdaCallGraphEdge(_, _, ?calleeCtx, ?implMethod, ?lambda),
  !Method_Modifier("static", ?implMethod),
  LambdaCallSite(_, ?invokedynamic, ?lambda, _, _, _, _, _),
  ThisVar(?implMethod, ?this),
  Var_Type(?this, ?thisType).

// Helper relation: a lambda call site that uses an instance method.
.decl LambdaCallSiteWithInstanceMethod(?invokedynamic:DynamicMethodInvocation_Insn, ?lambda:Lambda, ?implMethod:Method)
LambdaCallSiteWithInstanceMethod(?invokedynamic, ?lambda, ?implMethod) :-
  LambdaCallSite(_, ?invokedynamic, ?lambda, _, _, ?implMethod, _, _),
  !Method_Modifier("static", ?implMethod).

// Capture values of the enclosing environment.
.decl CallSiteCaptured(?callsite:CallSite, ?invokedynamic:DynamicMethodInvocation_Insn, ?val:Value, ?idx:number)
CallSiteCaptured(?callsite, ?invokedynamic, ?val, ?idx) :-
  InvokedynamicCallSite(?callsite, ?invokedynamic, _, ?K, _, ?callerCtx),
  ?K > 0,
  ActualParam(?idx, ?invokedynamic, ?actual),
  VarPointsTo(_, ?val, ?callerCtx, ?actual).

// Helper relation: instance methods may implicitly consume one of the
// K or N arguments for the receiver (shifting them by 1), while
// static methods take all K arguments before N ones.
.decl Params_ReceiverShiftRight(?lambda:Lambda, ?implMethod:Method, ?shiftK:number, ?shiftN:number)
Params_ReceiverShiftRight(?lambda, ?implMethod, 0, 0) :-
  LambdaCallSite(_, _, ?lambda, _, _, ?implMethod, _, _),
  Method_Modifier("static", ?implMethod).
// No bootstrap arguments = an actual argument will be used for 'this'.
Params_ReceiverShiftRight(?lambda, ?implMethod, 0, 1) :-
  LambdaCallSiteWithInstanceMethod(?invokedynamic, ?lambda, ?implMethod),
  DynamicMethodInvocation_DynArity(?invokedynamic, 0).
// First bootstrap argument exists, will be used for 'this'.
Params_ReceiverShiftRight(?lambda, ?implMethod, 1, 0) :-
  LambdaCallSiteWithInstanceMethod(?invokedynamic, ?lambda, ?implMethod),
  CallSiteCaptured(_, ?invokedynamic, _, 0).

// Pass invocation arguments to the implementing method.
VarPointsTo(?hctx, ?val, ?calleeCtx, ?formal) :-
  LambdaCallGraphEdge(_, ?i, ?calleeCtx, ?implMethod, ?lambda),
  Params_ReceiverShiftRight(?lambda, ?implMethod, ?shiftK, ?shiftN),
  LambdaCallSite(_, _, ?lambda, _, ?K, ?implMethod, _, _),
  ActualParam(?idx, ?i, ?actual),
  FormalParam(?K - ?shiftK + ?idx - ?shiftN, ?implMethod, ?formal),
  VarPointsTo(_, ?val, _, ?actual),
  Value_Type(?val, ?valType),
  Var_Type(?formal, ?formalType),
  // Check type compatibility (including (un)boxing).
  ConversibleTypes(?valType, ?formalType),
  isImmutableHContext(?hctx).

// Pass captured arguments to the implementing method.
VarPointsTo(?hctx, ?val, ?calleeCtx, ?formal) :-
  LambdaCallGraphEdge(_, _, ?calleeCtx, ?implMethod, ?lambda),
  Params_ReceiverShiftRight(?lambda, ?implMethod, ?shiftK, _),
  LambdaCallSite(_, ?invokedynamic, ?lambda, _, ?K, ?implMethod, _, _),
  CallSiteCaptured(_, ?invokedynamic, ?val, ?idx),
  ?idx + ?shiftK <= ?K,
  FormalParam(?idx - ?shiftK, ?implMethod, ?formal),
  Value_Type(?val, ?valType),
  Var_Type(?formal, ?formalType),
  basic.SubtypeOf(?valType, ?formalType),
  isImmutableHContext(?hctx).

// Special handling for captured "this" parameters.
VarPointsTo(?hctx, ?thisValue, ?calleeCtx, ?this) :-
  Params_ReceiverShiftRight(?lambda, ?implMethod, 1, 0),
  CalledInstanceImplMethod(?invokedynamic, ?implMethod, ?this, ?thisType, ?calleeCtx, ?lambda),
  CallSiteCaptured(_, ?invokedynamic, ?thisValue, 0),
  Value_Type(?thisValue, ?thisValueType),
  basic.SubtypeOf(?thisValueType, ?thisType),
  isImmutableHContext(?hctx).

// Special handling for "this" parameters to method references that do
// not capture a receiver.
VarPointsTo(?hctx, ?argValue, ?calleeCtx, ?this) :-
  LambdaCallGraphEdge(?callerCtx, ?i, ?calleeCtx, ?implMethod, ?lambda),
  Params_ReceiverShiftRight(?lambda, ?implMethod, 0, 1),
  ActualParam(0, ?i, ?actual),
  VarPointsTo(?hctx, ?argValue, ?callerCtx, ?actual),
  Value_Type(?argValue, ?argType),
  ThisVar(?implMethod, ?this),
  Var_Type(?this, ?thisType),
  basic.SubtypeOf(?argType, ?thisType).

// Applications of constructor references construct values. However,
// these values do not come from a 'new' instruction in the code but
// are created here as mock values, one per type/invocation.
MockValueConsMacro(?mockObj, ?type),
VarPointsTo(?hctx, ?mockObj, ?callerCtx, ?var),
VarPointsTo(?hctx, ?mockObj, ?calleeCtx, ?thisVar) :-
  LambdaCallGraphEdge(?callerCtx, ?i, ?calleeCtx, ?implMethod, _),
  Method_SimpleName(?implMethod, "<init>"),
  Method_DeclaringType(?implMethod, ?type),
  AssignReturnValue(?i, ?var),
  ThisVar(?implMethod, ?thisVar),
  ?mockObj = cat("mock ", cat(?type, cat(" constructed by constructor reference at ", ?i))),
  isImmutableHContext(?hctx).

#ifdef REFLECTION_METHOD_HANDLES
#ifdef REFLECTION

/**
 * Naive model of Class.getDeclaredConstructors() without back-propagation of
 * special values. Needed since the invokedynamic handling does not propagate
 * these special values up to their uses.
 */

.decl FillConstructorsFromClass(?hctx:configuration.HContext, ?mockConstructors:Value, ?class:Type)

#define GET_DECLARED_METHODS "<java.lang.Class: java.lang.reflect.Method[] getDeclaredMethods()>"
#define GET_DECLARED_CONSRUCTORS "<java.lang.Class: java.lang.reflect.Constructor[] getDeclaredConstructors()>"
.decl Class_getMembers(?sig:Method, ?hctx:configuration.HContext, ?ctx:configuration.Context, ?ret:Var, ?class:Type)

Class_getMembers(?sig, ?hctx, ?ctx, ?ret, ?class) :-
  _VirtualMethodInvocation(?invo, _, ?sig, ?base, ?method),
  (?sig = GET_DECLARED_CONSTRUCTORS ; ?sig = GET_DECLARED_METHODS),
  ReachableContext(?ctx, ?method),
  VarPointsTo(_, ?classValue, ?ctx, ?base),
  ReifiedClass(?class, ?classValue),
  ApplicationClass(?class),
  AssignReturnValue(?invo, ?ret),
  isImmutableHContext(?hctx).

MockValueConsMacro(?mockConstructors, "java.lang.reflect.Constructor[]"),
VarPointsTo(?hctx, ?mockConstructors, ?ctx, ?ret),
FillConstructorsFromClass(?hctx, ?mockConstructors, ?class) :-
  Class_getMembers(GET_DECLARED_CONSTRUCTORS, ?hctx, ?ctx, ?ret, ?class),
  ?mockConstructors = cat("mock constructors array for ", ?class).

ArrayIndexPointsTo(?immHctx, ?constructor, ?hctx, ?mockConstructors) :-
  FillConstructorsFromClass(?hctx, ?mockConstructors, ?class),
  Method_DeclaringType(?method, ?class),
  Method_SimpleName(?method, "<init>"),
  ReifiedConstructor(?method, ?constructor),
  isImmutableHContext(?immHctx).

MockValueConsMacro(?mockMethods, "java.lang.reflect.Method[]"),
VarPointsTo(?hctx, ?mockMethods, ?ctx, ?ret),
FillConstructorsFromClass(?hctx, ?mockMethods, ?class) :-
  Class_getMembers(GET_DECLARED_METHODS, ?hctx, ?ctx, ?ret, ?class),
  ?mockMethods = cat("mock methods array for ", ?class).

ArrayIndexPointsTo(?immHctx, ?methodValue, ?hctx, ?mockMethods) :-
  FillConstructorsFromClass(?hctx, ?mockMethods, ?class),
  Method_DeclaringType(?method, ?class),
  ReifiedMethod(?method, ?methodValue),
  isImmutableHContext(?immHctx).

#endif // REFLECTION
#endif // REFLECTION_METHOD_HANDLES
