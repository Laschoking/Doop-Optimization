#pragma once

// For _EXT relations, use -1 for value, if no value available
.decl IVALUE_Var(var: Var, value: number)
.decl IVALUE_Var_EXT(var: Var, value: number)
.decl IVALUE_ArraySize_EXT(stmt: Instruction, size: number)
.decl IVALUE_ArrayIndex(stmt: Instruction, index: number)
.decl IVALUE_OPERAND(stmt: Instruction, pos: number, value: number)

IVALUE_Var(var, to_number(const)),
IVALUE_Var_EXT(var, to_number(const)) :-
	VarHasExpr(var, expr),
	Normalize(expr, normExpr),
	IsConstantExpr(normExpr, const).

IVALUE_Var_EXT(var, -1) :-
	isVar(var),
	!VarHasExpr(var, _).

IVALUE_Var_EXT(var, -1) :-
	isVar(var),
	VarHasExpr(var, expr),
	Normalize(expr, normExpr),
	!IsConstantExpr(normExpr, _).


IVALUE_ArraySize_EXT(stmt, size) :-
	InterestingStmt(stmt),
	AllocArraySize_NUM(stmt, _, size).

IVALUE_ArraySize_EXT(stmt, size) :-
	InterestingStmt(stmt),
	AllocArraySize_VAR(stmt, _, var),
	IVALUE_Var_EXT(var, size).

IVALUE_ArrayIndex(stmt, index) :-
	InterestingStmt(stmt),
	ArrayNumIndex(stmt, index).

IVALUE_ArrayIndex(stmt, index) :-
	InterestingStmt(stmt),
	ArrayInsnIndex(stmt, var),
	IVALUE_Var(var, index).


IVALUE_OPERAND(stmt, pos, value) :-
	InterestingStmt(stmt),
	OPERAND_NUM(stmt, pos, value).

IVALUE_OPERAND(stmt, pos, value) :-
	InterestingStmt(stmt),
	OPERAND_VAR(stmt, pos, var),
	IVALUE_Var(var, value).

.decl API_ResultMethod(method: Method)

.decl ReverseCondition(op: symbol, reverseOp: symbol) inline
.decl FlippedCondition(op: symbol, flippedOp: symbol) inline

ReverseCondition(">", "<=").
ReverseCondition(">=", "<").
ReverseCondition("<", ">=").
ReverseCondition("<=", ">").
ReverseCondition("==", "!=").
ReverseCondition("!=", "==").

FlippedCondition(">", "<").
FlippedCondition(">=", "<=").
FlippedCondition("<", ">").
FlippedCondition("<=", ">=").
FlippedCondition("==", "==").
FlippedCondition("!=", "!=").


.type AccessPath = [first: symbol, rest: AccessPath]
.decl VarHasAP_AUX(var: Var, ap: AccessPath, size: number)
.decl VarHasAP(var: Var, ap: AccessPath)
.decl isAccessPath(ap: AccessPath)
.decl AccessPathStr(ap: AccessPath, out: symbol)

VarHasAP_AUX(var, [array, ["@", [indexStr, rest]]], size + 3) :-
	VarHasAP_AUX(var, [to, rest], size),
	((ALOAD_NUM(_, to, array, index), indexStr = to_string(index));
	 ALOAD_VAR(_, to, array, indexStr)).

VarHasAP(var, ap) :-
	VarHasAP_AUX(var, ap, maxSize),
	!IVALUE_Var(var, _),
	maxSize = max size : { VarHasAP_AUX(var, _, size) }.

VarHasAP(var, [to_string(val), nil]) :-
	VarHasAP_AUX(var, [var, nil], _),
	IVALUE_Var(var, val).

isAccessPath(rest) :- isAccessPath([_, rest]), rest != nil.
isAccessPath(ap) :- VarHasAP(_, ap).

AccessPathStr(ap, first) :- isAccessPath(ap), ap = [first, nil].

AccessPathStr(ap, cat(first, out)) :-
	isAccessPath(ap), ap = [first, rest], rest != nil,
	AccessPathStr(rest, out).