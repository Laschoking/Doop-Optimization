
/* Input expressions are coming from
 *  1) Method parameters
 *  2) Field loads
 *  3) Static class fields
 *  4) Catch blocks
 */

// Method Parameters

ResolveExpr(?meth, ?var, ?expr),
isInputExpr(?expr) :-
    isAssignLocal_Insn(?insn),
    AssignLocal_From(?insn, ?param),
    FormalParam(_, ?meth, ?param),
    Var_Type(?param, ?type),
    Type_boolean(?type),
    AssignInstruction_To(?insn, ?var),
    Instruction_Method(?insn, ?meth),
    ?expr = [?param, ?type, nil, nil].

// Method Invocation result

ResolveExpr(?meth, ?var, ?expr),
isInputExpr(?expr) :-
    isMethodInvocation(?methInvo),
    MethodInvocation_Method(?methInvo, ?methSig),
    Method_ReturnType(?methSig, ?type),
    Type_boolean(?type),
    Instruction_Method(?methInvo, ?meth),
    AssignReturnValue(?methInvo, ?var),
    ?expr = [?var, ?type, nil, nil].

// Load instance/static fields

ResolveExpr(?meth, ?var, ?expr),
isInputExpr(?expr) :-
    isLoadInstanceField_Insn(?insn),
    LoadInstanceField_To(?insn, ?var),
    Var_Type(?var, ?type),
    Type_boolean(?type),
    Instruction_Method(?insn, ?meth),
    ?expr = [?var, ?type, nil, nil].

// Assign Num Constant

ResolveExpr(?meth, ?var, ?expr),
isInputExpr(?expr) :-
    isAssignNumConstant_Insn(?insn),
    AssignInstruction_To(?insn, ?var),
    Var_Type(?var, ?type),
    Type_boolean(?type),
    Instruction_Method(?insn, ?meth),
    AssignNumConstant_Id(?insn, ?const),
    ?expr = [?const, ?type, nil, nil].

//// Assign Local
//
//#ifdef DEBUG
//ToString(?expr, ?out),
//#endif // DEBUG
//ResolveExpr(?meth, ?var, ?expr),
//isExpr(?expr) :-
//    Instruction_Method(?insn, ?meth),
//    isAssignLocal_Insn(?insn),
//    AssignInstruction_To(?insn, ?var),
//    Var_Type(?var, ?type),
//    Type_boolean(?type),
////    c = count: AssignInstruction_To(_, ?var),
////    c = 1,
//    AssignLocal_From(?insn, ?from),
//#ifdef DEBUG
//    ToString(?expr, ?out),
//#endif // DEBUG
//    ResolveExpr(?meth, ?from, ?expr).

// Assign Unary

ResolveExpr(?meth, ?var, ?expr),
isExpr(?expr) :-
    isAssignUnop_Insn(?insn),
    AssignInstruction_To(?insn, ?var),
    Var_Type(?var, ?type),
    Type_boolean(?type),
    Instruction_Method(?insn, ?meth),
    AssignOper_From(?insn, _, ?right),
    _OperatorAt(?insn, ?op),
    ResolveExpr(?meth, ?right, ?rExpr),
    ?expr = [?op, ?type, ?rExpr, nil].

// Assign Binary

ResolveExpr(?meth, ?var, ?expr),
isExpr(?expr) :-
    isAssignBinop_Insn(?insn),
    AssignInstruction_To(?insn, ?var),
    Var_Type(?var, ?type),
    Type_boolean(?type),
    Instruction_Method(?insn, ?meth),
    AssignOper_From(?insn, ?pos1, ?right1),
    AssignOper_From(?insn, ?pos2, ?right2),
    ?pos1 < ?pos2,
    _OperatorAt(?insn, ?op),
    ResolveExpr(?meth, ?right1, ?rExpr),
    ResolveExpr(?meth, ?right2, ?lExpr),
    ?expr = [?op, ?type, ?lExpr, ?rExpr].

// If Conditions - Var_Var

ResolveExpr(?meth, ?var, ?expr),
isExpr(?expr) :-
    IfVarVar(_, ?var, ?meth, ?right1, ?right2, ?op),
    ResolveExpr(?meth, ?right1, ?lExpr),
    ResolveExpr(?meth, ?right2, ?rExpr),
    ?expr = [?op, "boolean", ?lExpr, ?rExpr].

// If Conditions - Var_Const

isExpr(?constExpr),
ResolveExpr(?meth, ?var, ?expr),
isExpr(?expr) :-
    IfVarConst(_, ?var, ?meth, ?right1, ?right2, ?op),
    ?constExpr = [?right2, "boolean", nil, nil],
    ResolveExpr(?meth, ?right1, ?lExpr),
    ?expr = [?op, "boolean", ?lExpr, ?constExpr].
