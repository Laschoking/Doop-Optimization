.type SymbolicInput = Var | MethodInvocation
.type Operator = symbol

.type Base = SymbolicInput | Operator

.type Expr = [
    ?base: Base,
    ?type: PrimitiveType,
    ?left: Expr,
    ?right: Expr
]

.decl ResolveExpr(?meth: Method, ?var: symbol, ?expr: Expr)
.decl ToString(?expr: Expr, ?out: symbol)
.decl isBooleanExpr(?expr: Expr)
.decl isInputExpr(?expr: Expr)
.decl isExpr(?expr: Expr)
//.decl MethodSymbolicInput(?meth: Method, ?input: SymbolicInput)

.output ResolveExpr
.output ToString
.output isBooleanExpr
.output isInputExpr
.output isExpr
//.output MethodSymbolicInput

/** Input expressions are coming from
 *  1) Method parameters
 *  2) Field loads
 *  3) Static class fields
 *  4) Catch blocks
 **/

isBooleanExpr(?expr) :-
    (isInputExpr(?expr) ; isExpr(?expr)),
    ?expr = [?op, ?type, ?rExpr, ?lExpr],
    ?type = "boolean".

// Method Parameters

ToString(?expr, ?param),
ResolveExpr(?meth, ?param, ?expr),
isInputExpr(?expr) :-
    FormalParam(_, ?meth, ?param),
    Var_Type(?param, ?type),
    ?expr = [?param, ?type, nil, nil].

// Method Invocation result

ToString(?expr, ?methInvo),
ResolveExpr(?meth, ?var, ?expr),
isInputExpr(?expr) :-
    Instruction_Method(?methInvo, ?meth),
    isMethodInvocation(?methInvo),
    MethodInvocation_Method(?methInvo, ?methSig),
    AssignReturnValue(?methInvo, ?var),
    Method_ReturnType(?methSig, ?type),
    ?expr = [?methInvo, ?type, nil, nil].

// Load instance/static fields

ResolveExpr(?meth, ?var, ?expr),
ToString(?expr, ?base),
isInputExpr(?expr) :-
    Instruction_Method(?inst, ?meth),
    isLoadInstanceField_Insn(?inst),
    LoadInstanceField_To(?inst, ?var),
    LoadInstanceField_Base(?inst, ?base),
    Var_Type(?base, ?type),
    ?expr = [?base, ?type, nil, nil].

// Assign Local

ToString(?expr, ?out),
ResolveExpr(?meth, ?var, ?expr),
isExpr(?expr) :-
    Instruction_Method(?inst, ?meth),
    AssignInstruction_To(?inst, ?var),
    Var_Type(?var, ?type),
    AssignLocal_From(?inst, ?from),
    ResolveExpr(_, ?from, ?expr),
    ToString(?expr, ?out).

// Assign Unary

ToString([?op, ?type, ?rExpr, nil], ?out),
ResolveExpr(?meth, ?var, [?op, ?type, ?rExpr, nil]),
isExpr([?op, ?type, ?rExpr, nil]) :-
    AssignInstruction_To(?inst, ?var),
    isAssignUnop_Insn(?inst),
    Var_Type(?var, ?type),
    AssignOper_From(?inst, _, ?right),
    _OperatorAt(?inst, ?op),
    ResolveExpr(?meth, ?right, ?rExpr),
    ToString(?rExpr, ?out),
    ?out = cat(?op, cat(" ", ?out)).

// Assign Binary

ToString(?expr, ?out),
ResolveExpr(?meth, ?var, ?expr),
isExpr(?expr) :-
    AssignInstruction_To(?inst, ?var),
    Var_Type(?var, ?type),
    isAssignBinop_Insn(?inst),
    AssignOper_From(?inst, ?pos1, ?right1),
    AssignOper_From(?inst, ?pos2, ?right2),
    ?pos1 < ?pos2,
    _OperatorAt(?inst, ?op),
    ResolveExpr(?meth, ?right1, ?rExpr),
    ResolveExpr(?meth, ?right2, ?lExpr),
    ToString(?lExpr, ?out1),
    ToString(?rExpr, ?out2),
    ?expr = [?op, ?type, ?lExpr, ?rExpr],
    ?out = cat("(", cat(?out1, cat(")", cat(?op, cat("(", cat(?out2, ")")))))).

// If Conditions

ToString(?expr, ?out),
ResolveExpr(?meth, ?var, ?expr),
isExpr(?expr) :-
    Instruction_Method(?inst, ?meth),
    DummyIf_Var(?inst, ?var),
    isIf_Insn(?inst),
    Var_Type(?var, ?type),
    If_Var(?inst, ?pos1, ?right1),
    If_Var(?inst, ?pos2, ?right2),
    ?pos1 < ?pos2,
    _OperatorAt(?inst, ?op),
    ResolveExpr(_, ?right1, ?lExpr),
    ResolveExpr(_, ?right2, ?rExpr),
    ToString(?lExpr, ?out1),
    ToString(?rExpr, ?out2),
    ?expr = [?op, ?type, ?lExpr, ?rExpr],
    ?out = cat("(", cat(?out1, cat(")", cat(?op, cat("(", cat(?out2, ")")))))).
