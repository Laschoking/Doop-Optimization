#define DEBUG

#ifdef DEBUG

ToString(?expr, ?out) :-
//    ResolveExpr(_, _, ?expr),
    isInputExpr(?expr),
    ?expr = [?base, ?type, ?exprL, ?exprR],
    ?out = ?base.
ToString(?expr, ?out) :-
//    ResolveExpr(_, _, ?expr),
    isExpr(?expr),
    isOperator(?base),
    ?expr = [?base, ?type, ?exprLeft, nil],
    ToString(?exprLeft, ?outLeft),
    ?out = cat(?base, ?outLeft).
ToString(?expr, ?out) :-
//    ResolveExpr(_, _, ?expr),
    isExpr(?expr),
    isOperator(?base),
    ?expr = [?base, ?type, ?exprLeft, ?exprRight],
    ToString(?exprLeft, ?outLeft),
    ToString(?exprRight, ?outRight),
    ?out = cat(?outLeft, cat(" ", cat(?base, cat(" ", ?outRight)))).
ToString(?expr, ?out) :-
    isExpr(?expr),
//    PathExpressionBefore(_, _, ?expr),
    isOperator(?base),
    ?expr = [?base, ?type, ?exprLeft, ?exprRight],
    ToString(?exprLeft, ?outLeft),
    ToString(?exprRight, ?outRight),
    ?out = cat(?outLeft, cat(" ", cat(?base, cat(" ", ?outRight)))).
ToString(?expr, ?out) :-
 //   PathExpressionAfterTrue(_, _, ?expr),
    isExpr(?expr),
    isOperator(?base),
    ?expr = [?base, ?type, ?exprLeft, ?exprRight],
    ToString(?exprLeft, ?outLeft),
    ToString(?exprRight, ?outRight),
    ?out = cat(?outLeft, cat(" ", cat(?base, cat(" ", ?outRight)))).
ToString(?expr, ?out) :-
//    PathExpressionAfterFalse(_, _, ?expr),
    isExpr(?expr),
    isOperator(?base),
    ?expr = [?base, ?type, ?exprLeft, ?exprRight],
    ToString(?exprLeft, ?outLeft),
    ToString(?exprRight, ?outRight),
    ?out = cat(?outLeft, cat(" ", cat(?base, cat(" ", ?outRight)))).

#endif

isExpr(?expr) :-
    PathExpressionAfterTrue(_, _, ?expr).
isExpr(?expr) :-
    PathExpressionAfterFalse(_, _, ?expr).

isBooleanExpr(?expr) :-
    (isInputExpr(?expr) ; isExpr(?expr)),
    ?expr = [?op, ?type, ?rExpr, ?lExpr],
    Type_boolean(?type).

isArithmeticExpr(?expr) :-
    (isInputExpr(?expr) ; isExpr(?expr)),
    ?expr = [?op, ?type, ?rExpr, ?lExpr],
    (Type_byte(?type) ;
     Type_char(?type) ;
     Type_short(?type) ;
     Type_int(?type) ;
     Type_long(?type) ;
     Type_float(?type) ;
     Type_double(?type)).

isOperator("&&").
isOperator("||").
isOperator("==").
isOperator("!=").
isOperator("<").
isOperator(">").
isOperator(">=").
isOperator("<=").

/* Facts for NegateOp */

NegateOp("==", "!=").
NegateOp("!=", "==").

NegateOp("<", ">=").
NegateOp(">", "<=").

NegateOp(">=", "<").
NegateOp("<=", ">").

/* Rules */

/*
 * Multiple predecessors may flow up to this statement, thus we need
 * to enumerate all possible predecessors in order to build the
 * corresponding path expression, before the instruction.
 */

// Pick the predecessor with the minimum ord value as the ?first predecessor

FirstIfInsnInMethod(?insn, ?meth) :-
    Instruction_Method(?insn, ?meth),
    minOrd = min ord(?insn): IfsInMethod(?insn, ?meth),
    ord(?insn) = minOrd.

IfsInMethod(?pred, ?meth) :-
    Instruction_Method(?insn, ?meth),
    BBHeadInMethod(?insn, ?meth),
    SinglePredOfInsnInMethod(?pred, ?insn, ?meth).

FirstPredOfInsnInMethodOrdinal(?meth, ?firstOrd, ?insn) :-
    Instruction_Method(?insn, ?meth),
    ?firstOrd = min ord(?prev): MayPredecessorModuloThrow(?prev, ?insn).

FirstPredOfInsnInMethod(?meth, ?first, ?insn) :-
    Instruction_Method(?insn, ?meth),
    MayPredecessorModuloThrow(?first, ?insn),
    ?min_ord = ord(?first),
    FirstPredOfInsnInMethodOrdinal(?meth, ?min_ord, ?insn).

// Pick the predecessor with the maximum ord value as the ?last predecessor

LastPredOfInsnInMethodOrdinal(?meth, ?lastOrd, ?insn) :-
    Instruction_Method(?insn, ?meth),
    ?lastOrd = max ord(?prev): MayPredecessorModuloThrow(?prev, ?insn).

LastPredOfInsnInMethod(?meth, ?last, ?insn) :-
    Instruction_Method(?insn, ?meth),
    MayPredecessorModuloThrow(?last, ?insn),
    ?max_ord = ord(?last),
    LastPredOfInsnInMethodOrdinal(?meth, ?max_ord, ?insn).

// Pick as ?next predecessor of ?insn the instruction with the least
// greater ord number, compared to the ?prev predecessor

NotNextPredOfInsnInMethod(?meth, ?prev, ?next, ?insn) :-
    Instruction_Method(?insn, ?meth),
    MayPredecessorModuloThrow(?prev, ?insn),
    MayPredecessorModuloThrow(?next, ?insn),
    MayPredecessorModuloThrow(?nextPossible, ?insn),
    ord(?prev) < ord(?next),
    ord(?prev) < ord(?nextPossible),
    ord(?nextPossible) < ord(?next).

NextPredOfInsnInMethod(?meth, ?prev, ?next, ?insn) :-
    Instruction_Method(?insn, ?meth),
    MayPredecessorModuloThrow(?prev, ?insn),
    MayPredecessorModuloThrow(?next, ?insn),
    ord(?prev) < ord(?next),
    !NotNextPredOfInsnInMethod(?meth, ?prev, ?next, ?insn).


// Determine expr operands for if-statements

IfVarVar(?inst, ?var, ?meth, ?right1, ?right2, ?op) :-
    Instruction_Method(?inst, ?meth),
    DummyIf_Var(?inst, ?var),
    isIf_Insn(?inst),
    If_Var(?inst, ?pos1, ?right1),
    If_Var(?inst, ?pos2, ?right2),
    ?pos1 < ?pos2,
    _OperatorAt(?inst, ?op).

IfVarConst(?inst, ?var, ?meth, ?right1, ?right2, ?op) :-
    Instruction_Method(?inst, ?meth),
    DummyIf_Var(?inst, ?var),
    isIf_Insn(?inst),
    If_Var(?inst, ?pos1, ?right1),
    If_Constant(?inst, ?pos2, ?right2),
    ?pos1 < ?pos2,
    _OperatorAt(?inst, ?op).

// Single Pred

SinglePredOfInsnInMethod(?pred, ?insn, ?meth) :-
    Instruction_Method(?insn, ?meth),
    FirstPredOfInsnInMethod(?meth, ?pred, ?insn),
    LastPredOfInsnInMethod(?meth, ?pred, ?insn).

// Multiple Preds - First

FirstOfMultiplePredsOfInsnInMethod(?pred, ?insn, ?meth) :-
    Instruction_Method(?insn, ?meth),
    FirstPredOfInsnInMethod(?meth, ?pred, ?insn),
    !LastPredOfInsnInMethod(?meth, ?pred, ?insn).

// Multiple Preds - Next

NextOfMultiplePredsOfInsnInMethod(?next, ?prev, ?insn, ?meth) :-
    Instruction_Method(?insn, ?meth),
    !LastPredOfInsnInMethod(?meth, ?prev, ?insn),
    NextPredOfInsnInMethod(?meth, ?prev, ?next, ?insn).

// Multiple Preds - Last

LastOfMultiplePredsOfInsnInMethod(?pred, ?insn, ?meth) :-
    Instruction_Method(?insn, ?meth),
    !FirstPredOfInsnInMethod(?meth, ?pred, ?insn),
    LastPredOfInsnInMethod(?meth, ?pred, ?insn).
