<html><body> <h1>Doop rules</h1>

    <p>This document lists all Souffl&eacute;-Datalog rules appearing
    in Doop logic. Note that some of these rules may be guarded by
    macros and thus be disabled in particular Doop runs.</p> <h2> addons/butterknife.dl </h2>
<ul>
<li> .decl FieldBindView(?field:Field, ?controlValue:Value, ?controlType:ReferenceType, ?ctx:configuration.Context, ?hctx:configuration.HContext)</li>
<li> .decl ViewBinder(?value:Value, ?type:ReferenceType, ?hctx:configuration.HContext)</li>
</ul>
<h2> addons/cfg-analysis/analysis.dl </h2>
<ul>
<li> .decl BBHeadInMethod(?insn:Instruction, ?method:Method)</li>
<li> .decl BasicBlockBegin(?insn:Instruction)</li>
<li> .decl BasicBlockEnd(?insn:Instruction)</li>
<li> .decl BasicBlockHead(?insn:Instruction, ?headInsn:Instruction)</li>
<li> .decl BasicBlockTail(?headInsn:Instruction, ?tailInsn:Instruction)</li>
<li> .decl CFGRoot(?insn:Instruction, ?method:Method)</li>
<li> .decl DoesNotDominate(?dominatorCandidate:Instruction, ?insn:Instruction)</li>
<li> .decl Dominates(?dominator:Instruction, ?insn:Instruction)</li>
<li> .decl DominatesItsPredecessorInstruction(?prevInsn:Instruction, ?insn:Instruction)</li>
<li> .decl DominatesItsSuccessorInstruction(?insn:Instruction, ?prevInsn:Instruction)</li>
<li> .decl ExceptionHandlerFirstInstruction(?insn:Instruction)</li>
<li> .decl ExistsMayPredecessorBBModuloThrow(?insn:Instruction)</li>
<li> .decl ExistsPreviousNonDomPredecessorToSameBB(?pred:Instruction, ?insn:Instruction)</li>
<li> .decl ExistsPreviousPredecessorToSameBB(?pred:Instruction, ?insn:Instruction)</li>
<li> .decl ExistsPreviousReturn(?insn:Instruction)</li>
<li> .decl FallThrough(?insn:Instruction)</li>
<li> .decl HigherReturnIndex(?insn:Instruction, ?indexHigher:number)</li>
<li> .decl InstructionInPhiNode(?insn:Instruction, ?headInsn:Instruction)</li>
<li> .decl Instruction_Next(?i:Instruction, ?next:Instruction)</li>
<li> .decl Instruction_Prev(?i:Instruction, ?prev:Instruction)</li>
<li> .decl IsJumpTarget(?insn:Instruction)</li>
<li> .decl JumpTarget(?insn:Instruction, ?prev:Instruction)</li>
<li> .decl LargerNonDomPredecessorIndexToSameBB(?insn:Instruction, ?indexLarge:number, ?prevSmall:Instruction)</li>
<li> .decl LargerPredecessorIndexToSameBB(?insn:Instruction, ?indexLarge:number, ?prevSmall:Instruction)</li>
<li> .decl MayPredecessorBBModuloThrow(?prev:Instruction, ?next:Instruction)</li>
<li> .decl MayPredecessorModuloThrow(?prev:Instruction, ?next:Instruction)</li>
<li> .decl MaySuccessorBBModuloThrow(?next:Instruction, ?prev:Instruction)</li>
<li> .decl MaySuccessorModuloThrow(?next:Instruction, ?prev:Instruction)</li>
<li> .decl Method_FirstInstruction(?method:Method, ?insn:Instruction)</li>
<li> .decl NextInSameBasicBlock(?insn:Instruction, ?next:Instruction)</li>
<li> .decl NextInSamePhiNode(?insn1:Instruction, ?insn2:Instruction)</li>
<li> .decl NextNonDomPredecessorIndexToSameBB(?insn:Instruction, ?prev:Instruction, ?indexNext:number)</li>
<li> .decl NextNonDomPredecessorToSameBB(?insn:Instruction, ?pred:Instruction, ?nextPred:Instruction)</li>
<li> .decl NextPredecessorIndexToSameBB(?insn:Instruction, ?prev:Instruction, ?indexNext:number)</li>
<li> .decl NextPredecessorToSameBB(?insn:Instruction, ?pred:Instruction, ?nextPred:Instruction)</li>
<li> .decl NextReturn(?insn1:Instruction, ?insn2:Instruction)</li>
<li> .decl NextReturnIndex(?returnInsn:Instruction, ?nextReturnIndex:number)</li>
<li> .decl NonDomPredecessorBBsToSameBB(?insn:Instruction, ?prev1:Instruction, ?prev2:Instruction)</li>
<li> .decl OptInstructionFromMethodIndex(?method:Method, ?index:number, ?insn:Instruction)</li>
<li> .decl OptReturnInsn(?insn:Instruction, ?method:Method)</li>
<li> .decl PhiNodeHead(?insn:Instruction, ?headInsn:Instruction)</li>
<li> .decl PredecessorBBsToSameBB(?insn:Instruction, ?prev1:Instruction, ?prev2:Instruction)</li>
<li> .decl PrevInSameBasicBlock(?insn:Instruction, ?prev:Instruction)</li>
<li> .decl PreviousNonDomPredecessorToSameBB(?insn:Instruction, ?nextPred:Instruction, ?prevPred:Instruction)</li>
<li> .decl PreviousPredecessorToSameB(?insn:Instruction, ?nextPred:Instruction, ?prevPred:Instruction)</li>
<li> .decl SameMethodBBHeads(?insn1:Instruction, ?insn2:Instruction)</li>
<li> .decl UnconditionalControlTransfer(?insn:Instruction)</li>
</ul>
<h2> addons/constant-folding/analysis.dl </h2>
<ul>
<li> .decl AssignBinary(?instr:symbol, ?var: symbol, ?left:number, ?right:number, ?meth:symbol, ?prev_use1:number, ?prev_use2:number)</li>
<li> .decl AssignBinaryNonZeroRight(?instr:symbol, ?var:symbol, ?left:number, ?right:number, ?meth:symbol, ?prev_use1:number, ?prev_use2:number)</li>
<li> .decl AssignUnary(?instr:symbol, ?var:symbol, ?value:number, ?meth:symbol, ?use:number)</li>
<li> .decl BoolConstFolding(?instruction:symbol, ?variable:symbol, ?value:number, ?method:symbol)</li>
<li> .decl BoolConstant(?instr:symbol, ?var:symbol, ?value:number, ?meth:symbol)</li>
<li> .decl IntConstFolding(?instruction:symbol, ?variable:symbol, ?value:number, ?meth:symbol, ?use:number)</li>
<li> .decl IntConstant(?instr:symbol, ?var:symbol, ?value:number, ?method:symbol, ?type:symbol)</li>
<li> .decl IntNonZeroConstFolding(?instruction:symbol, ?variable:symbol, ?value:number, ?meth:symbol, ?use:number)</li>
</ul>
<h2> addons/dacapo/rules.dl </h2>
<ul>
<li> .decl Dacapo(?classNameHeap:StringConstant, method:Method)</li>
</ul>
<h2> addons/glide.dl </h2>
<ul>
<li> .decl GlideReifiedType(?value:Value, ?type:ReferenceType)</li>
</ul>
<h2> addons/information-flow/declarations.dl </h2>
<ul>
<li> .decl AnyMethodInvocation(?invocation:MethodInvocation, ?tomethod:Method)</li>
<li> .decl BaseToParamTaintTransferMethod(?method:Method)</li>
<li> .decl BaseToRetTaintTransferMethod(?method:Method)</li>
<li> .decl CallTaintingMethod(?label:InformationLabel, ?ctx:CONTEXT, ?invocation:MethodInvocation)</li>
<li> .decl LabelFromSource(?source:symbol, ?label:InformationLabel)</li>
<li> .decl LeakingSinkMethod(?lable:InformationLabel, ?method:Method)</li>
<li> .decl LeakingSinkMethodArg(?label:InformationLabel, ?index:number, ?method:Method)</li>
<li> .decl LeakingSinkVariable(?label:InformationLabel, ?tomethod:MethodInvocation, ?ctx:CONTEXT, ?var:Var)</li>
<li> .decl LeakingTaintedInformation(?fromLabel:InformationLabel, ?toLabel:InformationLabel, ?ctx:CONTEXT, ?invocation:MethodInvocation, ?value:symbol)</li>
<li> .decl LeakingTaintedInformationVars(?fromCtx:CONTEXT, ?from:Var, ?toCtx:CONTEXT, ?to:Var)</li>
<li> .decl MethodInvocationInContext(?ctx:CONTEXT, ?invocation:MethodInvocation, ?tomethod:Method)</li>
<li> .decl MethodInvocationInContextInApplication(?ctx:CONTEXT, ?invocation:MethodInvocation, ?method:Method)</li>
<li> .decl MethodInvocationInfo(?invocation:MethodInvocation, ?type:Type, ?var:Var)</li>
<li> .decl MethodReturningStringFactory(?tomethod:Method)</li>
<li> .decl MockBaseToRetTaintTransferMethod(?meth:Method)</li>
<li> .decl MockParamToRetTaintTransferMethod(?meth:Method)</li>
<li> .decl ParamIndexToBaseTaintTransferMethod(?index:number, ?method:Method)</li>
<li> .decl ParamTaintTransferredToBase(?param:Var, ?ctx:CONTEXT, ?base:Var)</li>
<li> .decl ParamTaintTransferredToRet(?type:Type, ?ret:Var, ?ctx:CONTEXT, ?param:Var)</li>
<li> .decl ParamToBaseTaintTransferMethod(?index:number, ?method:Method)</li>
<li> .decl ParamToRetTaintTransferMethod(?method:Method)</li>
<li> .decl SanitizationMethod(?method:Method)</li>
<li> .decl SensitiveLayoutControlTaintConfig(?label:symbol, ?method:Method)</li>
<li> .decl SourceFromTaintedValue(?value:Value, ?id:symbol)</li>
<li> .decl StringFactoryReturnInvocation(?invocation:MethodInvocation)</li>
<li> .decl TaintObjTransfer(fromCtx:mainAnalysis.configuration.Context, from:Var, toCtx:mainAnalysis.configuration.Context, to:Var)</li>
<li> .decl TaintSourceMethod(?label:InformationLabel, ?method:Method)</li>
<li> .decl TaintSourceMethodWithOverrides(?label:InformationLabel, ?method:Method)</li>
<li> .decl TaintTransferMethodInvocationInContext(?ctx:CONTEXT, ?index:number, ?invocation:MethodInvocation)</li>
<li> .decl TaintedObjectSerialized(?declaringType:Type, ?source:symbol, ?type:Type, ?hctx:mainAnalysis.configuration.HContext, ?val:Value, ?ctx:mainAnalysis.configuration.Context, ?base:Var)</li>
<li> .decl TaintedValue(?value:Value)</li>
<li> .decl TaintedValueTransferred(?declaringType:Type, ?id:symbol, ?type:Type, ?value:Value)</li>
<li> .decl TaintedVarPointsTo(?value:Value, ?ctx:mainAnalysis.configuration.Context, ?var:Var)</li>
<li> .decl TaintedVarTaintedFromVar(?toCtx:mainAnalysis.configuration.Context, ?to:Var, ?value:Value, ?type:Type)</li>
<li> .decl TypeForReturnValue(?type:Type, ?ret:Var, ?invocation:MethodInvocation)</li>
<li> .decl VarIsCast(?var:Var)</li>
<li> .decl VarIsTaintedFromValue(?type:Type, ?value:Value, ?ctx:mainAnalysis.configuration.Context, ?var:Var)</li>
<li> .decl VarIsTaintedFromValueIndex(?ctx:mainAnalysis.configuration.Context, ?base:Var, ?hctx:mainAnalysis.configuration.HContext, ?value:Value)</li>
<li> .decl VarIsTaintedFromVar(?type:Type, ?ctx1:CONTEXT, ?var1:Var, ?ctx2:CONTEXT, ?var2:Var)</li>
<li> .decl VarIsTaintedFromVarIndex(?base:Var, ?ctx1:CONTEXT, ?param:Var)</li>
<li> .decl VarUse(?var:Var, ?inst:Instruction)</li>
<li> .decl isInformationLabel(?id:symbol)</li>
</ul>
<h2> addons/information-flow/rules-data-flow.dl </h2>
<ul>
<li> .decl Var_Taint(?v:Var, ?label:InformationLabel, ?source:symbol)</li>
</ul>
<h2> addons/information-flow/rules.dl </h2>
<ul>
<li> .decl AppTaintedVar(?var:Var)</li>
<li> .decl AppTaintedVarPointsTo(?value:Value, ?var:Var)</li>
<li> .decl AppendInvocation_Base(?invocation:MethodInvocation, ?base:Var)</li>
<li> .decl AppendableType(?type:Type)</li>
<li> .decl BaseValueTaintedFromParamValue(v1:Value, v2:Value)</li>
<li> .decl MaybeDeserializedValue(?value:Value)</li>
<li> .decl MethodInvocationInMethod(?tomethod:Method, ?invocation:MethodInvocation, ?inmethod:Method)</li>
<li> .decl ObjectSerializedToBase(?ctx:mainAnalysis.configuration.Context, ?base:Var, ?obj:Value)</li>
<li> .decl OptDeserializeInvoke(?ret:Var)</li>
<li> .decl SerializableValue(?obj:Value)</li>
<li> .decl SerializableVar(?var:Var)</li>
<li> .decl SerializeObjectInvocation(?base:Var, ?ctx:mainAnalysis.configuration.Context, ?var:Var)</li>
<li> .decl ValueTaintedFromValue(?v1:Value, ?v2:Value)</li>
<li> .decl XYZ(?value:Value, ?ctx:mainAnalysis.configuration.Context, ?param:Var)</li>
<li> .decl XYZ2(?type:Type, ?value:Value, ?ctx:mainAnalysis.configuration.Context, ?param:Var)</li>
</ul>
<h2> addons/information-flow/spring-sources-and-sinks.dl </h2>
<ul>
<li> .decl SanitizationMethodIffBaseUntainted(?meth: Method)</li>
</ul>
<h2> addons/open-programs/application-concrete-types.dl </h2>
<ul>
<li> .decl AbstractOrInterfaceTypeHasNoApplicationConcreteImplementations(?type:Type)</li>
<li> .decl BridgeMethod(?bridge:Method, ?type:Type)</li>
<li> .decl NonApplicationConcreteImplementationRepresentative(?class:Type, ?staticType:Type)</li>
<li> .decl NonApplicationConcreteImplementations(?class:Type, ?staticType:Type)</li>
<li> .decl NonApplicationConcreteImplementationsOrd(?classOrd:number, ?staticType:Type)</li>
<li> .decl TypeHasNoApplicationConcreteImplementations(?type:Type)</li>
</ul>
<h2> addons/open-programs/entry-points.dl </h2>
<ul>
<li> .decl ClassHasPossibleOpenProgramEntryPoint(?class:ReferenceType)</li>
<li> .decl ClassIsAboveOtherInNamingHierarchy(?classAbove:ReferenceType, ?classBelow:ReferenceType)</li>
<li> .decl ClassToConsider(?class:ReferenceType)</li>
<li> .decl ClassWithTopLevelOpenProgramEntryPoint(?class:ReferenceType)</li>
<li> .decl OpenProgramEntryPoint(?method:Method)</li>
<li> .decl PossibleOpenProgramEntryPoint(?method:Method)</li>
<li> .decl PrefixAbove(class:ReferenceType, str:symbol, ?len:number)</li>
<li> .decl PrefixBelow(class:ReferenceType, str:symbol)</li>
<li> .decl TopLevelApplicationClass(?class:ReferenceType)</li>
<li> .decl TopLevelOpenProgramEntryPoint(?method:Method)</li>
</ul>
<h2> addons/open-programs/rules-alfresco.dl </h2>
<ul>
<li> .decl MockCallReturnVal(?meth:Method)</li>
<li> .decl MockedObjTypeContains(?part:symbol)</li>
<li> .decl WebappMock(?v:Value)</li>
</ul>
<h2> addons/open-programs/rules-beans.dl </h2>
<ul>
<li> .decl BeanClass(cls: Type)</li>
<li> .decl BeanInit(cls: Type, simplemeth: symbol)</li>
<li> .decl BeanIoCField(cls: Type, simplefld: symbol, heap: Type)</li>
<li> .decl BeanReachable(cls: Type, simplemeth: symbol)</li>
</ul>
<h2> addons/open-programs/rules-concrete-types.dl </h2>
<ul>
<li> .decl AllConcreteImplementations(?class:ReferenceType, ?type:ReferenceType)</li>
<li> .decl ConcreteImplementations(?staticType:ReferenceType, ?class:ClassType)</li>
<li> .decl ConcreteType(?class:ReferenceType)</li>
<li> .decl ContextForOpenProgramEntryPoint(?ctx:mainAnalysis.configuration.Context, ?method:Method)</li>
<li> .decl FieldInformation(?signature:Field, ?fieldtype:Type, ?class:ReferenceType)</li>
<li> .decl FieldTypeForMockObject(?signature:Field, ?basevalue:Value, ?fieldtype:Type)</li>
<li> .decl FormalsForOpenProgramEntryPoints(?method:Method, ?formal:Var)</li>
<li> .decl HContextForOpenProgramEntryPoint(?hctx:mainAnalysis.configuration.HContext, ?method:Method)</li>
<li> .decl MockForFormal(?value:Value, ?formal:Var, ?type:ReferenceType, ?method:Method)</li>
<li> .decl MockInvocationForEntryPoint(?value:Value, ?method:Method, ?invo:MethodInvocation)</li>
<li> .decl MockObjFromArray(?class:ReferenceType)</li>
<li> .decl MockObjFromField(?fieldType:ReferenceType)</li>
<li> .decl MockObjFromFormal(?type:ReferenceType)</li>
<li> .decl MockObjFromOpenProgramEntryPoint(?class:ReferenceType)</li>
<li> .decl MockObject(?value:Value, ?class:ReferenceType)</li>
<li> .decl MockObjectContext(?hctx:mainAnalysis.configuration.HContext, ?value:Value, ?class:ReferenceType)</li>
<li> .decl MockObjectForComponentType(?value:Value, ?arrayType:ArrayType)</li>
<li> .decl MockObjectForType(?value:Value, ?staticType:ReferenceType)</li>
<li> .decl NonPrimaryTypeHasNoNonPrimaryConcreteImplementation(?type:ReferenceType)</li>
<li> .decl NonPrimaryTypeHasNonPrimaryConcreteImplementation(?type:ReferenceType)</li>
<li> .decl ObjToMock(?class:ReferenceType)</li>
<li> .decl PrimaryTypeHasNoPrimaryConcreteImplementation(?type:ReferenceType)</li>
<li> .decl PrimaryTypeHasPrimaryConcreteImplementation(?type:ReferenceType)</li>
<li> .decl ReceiverPointsTo(?value:Value, ?ctx:mainAnalysis.configuration.Context, ?receiver:Var, ?class:ReferenceType, ?method:Method)</li>
<li> .decl StaticToActualType(?class:ReferenceType, ?staticType:ReferenceType)</li>
<li> .decl TypeForFormals(?formal:Var, ?method:Method, ?type:ReferenceType)</li>
<li> .decl TypeToConcreteImplementationOrd(?staticType:ReferenceType, ?classOrd:number)</li>
</ul>
<h2> addons/open-programs/rules-jackee.dl </h2>
<ul>
<li> .decl ActionClass(?class:Type)</li>
<li> .decl ApplicationListener(?type:Type)</li>
<li> .decl ApplicationUnreachableMethod(?method: Method)</li>
<li> .decl AuthenticationEntryPoint(?type:Type)</li>
<li> .decl AuthenticationFilterBean(?bean:Type)</li>
<li> .decl AuthenticationProviderBean(?bean:Type)</li>
<li> .decl BeanFieldInjection(?class:ClassType, ?injectedField:Field, ?mockObject:Value)</li>
<li> .decl BeanMap(?id:symbol, ?mapClass:Type, ?mapMockObject:Value)</li>
<li> .decl BeanMapEntry(?id:symbol, ?entryBeanId:symbol, ?entryBeanMockObject:Value)</li>
<li> .decl BeanResource(?id:symbol, ?mapClass:Type, ?mapMockObject:Value)</li>
<li> .decl Bean_Parent(?id:symbol, ?parentId:symbol)</li>
<li> .decl ConcreteBean_Id(?class:ClassType, ?id:symbol)</li>
<li> .decl DependencyInjectedMethod(?method:Method)</li>
<li> .decl EntryPointClass(?type: Type)</li>
<li> .decl EntryPointMethod(?method:Method)</li>
<li> .decl ErasedEntryPointMethod(?method:Method)</li>
<li> .decl GetBeanAppInvocation(?ctx: mainAnalysis.configuration.Context, ?invocation: MethodInvocation)</li>
<li> .decl IFPTUnreachableMockObject(?value:Value)</li>
<li> .decl IncompleteFieldInjection(?type:Type, ?value:Value, ?field:Field)</li>
<li> .decl IncompletelyMockedMethod(?method:Method)</li>
<li> .decl InjectionAnnotatedField(?field:Field)</li>
<li> .decl MVCInterceptorBean(?bean:Type)</li>
<li> .decl MethodWithBuggySerializableArg(?method:Method)</li>
<li> .decl MockObjFromArray(?type:ReferenceType)</li>
<li> .decl MockObjFromField(?type:ReferenceType)</li>
<li> .decl MockObjFromFormal(?type:ReferenceType)</li>
<li> .decl PossibleEntryPointClass(?type:Type)</li>
<li> .decl SerializableEntryPointMethod(?method:Method)</li>
<li> .decl Servlet(?class:Type)</li>
<li> .decl TypeCannotBeMocked(?type:Type)</li>
<li> .decl UnreachableMockObject(?value:Value)</li>
<li> .decl VPTUnreachableMockObject(?value:Value)</li>
<li> .decl Validator(?class:Type)</li>
<li> .decl XMLIFPTDI(?hctx:mainAnalysis.configuration.HContext, ?mo:Value, ?fld:Field, ?bhctx:mainAnalysis.configuration.HContext, ?bval:Value)</li>
<li> .decl isAbstractBeanId(?id:symbol)</li>
<li> .decl isBeanId(?id:symbol)</li>
<li> .decl isConcreteBean(?bean:Type)</li>
<li> .decl isSpringApplication(?value:number)</li>
</ul>
<h2> addons/open-programs/rules-servlets-only.dl </h2>
<ul>
<li> .decl AllConcreteImplementations(?type1:Type, ?type2:Type)</li>
<li> .decl ConcreteImplementations(?staticType:Type, ?class:Type)</li>
<li> .decl ConcreteImplementationsOrd(?staticType:Type, ?classOrd:number)</li>
<li> .decl MockObjFromArray(?type:ReferenceType)</li>
<li> .decl MockObjFromField(?type:ReferenceType)</li>
<li> .decl MockObjFromFormal(?type:ReferenceType)</li>
<li> .decl MockObjFromOpenProgramEntryPoint(?value:Value)</li>
<li> .decl MockObject(?value:Value, ?type:ReferenceType)</li>
<li> .decl MockOpenProgramEntryPoint(?class:Type, ?method:Method)</li>
<li> .decl OpenProgramEntryPoint(?method:Method)</li>
<li> .decl PossibleOpenProgramEntryPoint(?class:Type, ?method:Method)</li>
<li> .decl ServletClass(?class:Type)</li>
<li> .decl ServletEntryMethodName(?method:Method)</li>
<li> .decl ValueForReceiverInContext(?ctx:mainAnalysis.configuration.Context, ?receiver:Var, ?value:Value)</li>
</ul>
<h2> addons/open-programs/rules-spring.dl </h2>
<ul>
<li> .decl MockInvocationForServletEntryPoint(?value:Value, ?method:Method, ?invo:MethodInvocation)</li>
<li> .decl ServletMethodEP(m: Method)</li>
</ul>
<h2> addons/opt-directives/directives.dl </h2>
<ul>
<li> .decl AppReachableMethodFromNativeCode(?method:Method)</li>
<li> .decl ApplicationMethod_Size(?method:Method, ?size:number)</li>
<li> .decl CallerSize(?caller:Method)</li>
<li> .decl ClassNameWithOnlySlashes(?typeName:ReferenceType, ?typeNameTransformed:symbol)</li>
<li> .decl ClassNameWithSlashes(?typeName:ReferenceType, ?typeNameWithSlash:symbol)</li>
<li> .decl ClassWithReachableConstructor(?class:ClassType)</li>
<li> .decl ConstructorlessReachableInstanceClass(?class:ClassType)</li>
<li> .decl ContextInsensitiveCallGraphEdge(?invocation:MethodInvocation, ?target:Method)</li>
<li> .decl DeadMethodWithJVMDescriptor(?jvmFullName:symbol, ?method:symbol)</li>
<li> .decl DoubleInvocationTarget(?invocation:MethodInvocation, ?target:Method)</li>
<li> .decl ExceptionThrownByReachableMethod(?excType:Type, ?method:Method)</li>
<li> .decl FieldIsFinalOrInitialized(?field:Field)</li>
<li> .decl FieldPointsTo(?field:Field)</li>
<li> .decl FieldReadByReflection(?field:Field)</li>
<li> .decl FieldWrittenByReflection(?field:Field)</li>
<li> .decl FinalFieldWrittenByReflection(?field:Field)</li>
<li> .decl InvocationCount(?method:Method, ?n:number)</li>
<li> .decl InvocationTarget_Count(?invocation:MethodInvocation, ?n:number)</li>
<li> .decl InvocationToInline(?invocation:MethodInvocation, ?target:Method)</li>
<li> .decl METHODS_INLINE_COMPATIBLE(?a:Method, ?b:Method)</li>
<li> .decl MethodInvokedByReflection(?method:Method)</li>
<li> .decl MethodToRemove(?method:Method)</li>
<li> .decl MultiInvocationTarget(?invocation:MethodInvocation, ?target:Method)</li>
<li> .decl NI_AllDeclaredConstructors(?type:ReferenceType)</li>
<li> .decl NI_AllDeclaredFields(?type:ReferenceType)</li>
<li> .decl NI_AllDeclaredMethods(?type:ReferenceType)</li>
<li> .decl NI_AllPublicConstructors(?type:ReferenceType)</li>
<li> .decl NI_AllPublicFields(?type:ReferenceType)</li>
<li> .decl NI_AllPublicMethods(?type:ReferenceType)</li>
<li> .decl NI_ReachableField(?field:Field)</li>
<li> .decl NI_ReachableMethod(?method:Method)</li>
<li> .decl NI_Stats(?label:symbol, ?f:symbol)</li>
<li> .decl NonFinalFieldWrittenInNonConstructor(?field:Field)</li>
<li> .decl RClass(?r:symbol)</li>
<li> .decl ReachableAppField(?fld:Field)</li>
<li> .decl ReachableAppMethod(?method:Method)</li>
<li> .decl ReachableField(?field:Field)</li>
<li> .decl ReachableFieldAccessedByReflection(?field:Field)</li>
<li> .decl ReachableMethodOnlyUsedInSingleInvocationTarget(?method:Method)</li>
<li> .decl ReachableType(?type:ReferenceType)</li>
<li> .decl Seed(?s:symbol)</li>
<li> .decl SeedMethod(?m:Method)</li>
<li> .decl SeedMethodNotReachable(?m:Method)</li>
<li> .decl SeedMethodReachable(?m:Method)</li>
<li> .decl SingleInvocationApplicationTarget(?invocation:MethodInvocation, ?target:Method)</li>
<li> .decl SingleInvocationTarget(?invocation:MethodInvocation, ?target:Method)</li>
<li> .decl SingleInvocationToInline(?invocation:MethodInvocation, ?target:Method)</li>
<li> .decl SmallApplicationMethod(?method:Method)</li>
<li> .decl SpecialMethodToKeep(?method:Method)</li>
<li> .decl TripleInvocationTarget(?invocation:MethodInvocation, ?target:Method)</li>
<li> .decl TypeOfDeadMethod(?method:Method, ?type:ReferenceType)</li>
<li> .decl UnreachableDeclaredConstructor(?constructor:Method, ?type:ReferenceType)</li>
<li> .decl UnreachableDeclaredField(?field:Field, ?type:ReferenceType)</li>
<li> .decl UnreachableDeclaredMethod(?method:Method, ?type:ReferenceType)</li>
<li> .decl UnreachablePublicConstructor(?type:ReferenceType)</li>
<li> .decl UnreachablePublicField(?type:ReferenceType)</li>
<li> .decl UnreachablePublicMethod(?method:Method, ?type:ReferenceType)</li>
<li> .decl _RelevantStringPosition(?className: symbol, ?pos:number)</li>
<li> .decl relCount(?n:number)</li>
</ul>
<h2> addons/opt-directives/keep.dl </h2>
<ul>
<li> .decl KeepMethodRule(?m:Method)</li>
</ul>
<h2> addons/queries/classifyVPT.dl </h2>
<ul>
<li> .decl VPTAllocated(v:Var, o:Value)</li>
<li> .decl VPTCI(v:Var, o:Value)</li>
<li> .decl VPTCIandClass(v:Var, o:Value)</li>
<li> .decl VPTCIandMerged(v:Var, o:Value)</li>
<li> .decl VPTCIandMockVal(v:Var, o:Value)</li>
<li> .decl VPTCIandNum(v:Var, o:Value)</li>
<li> .decl VPTCIandStringConstant(v:Var, o:Value)</li>
<li> .decl VPTCIandStringFactory(v:Var, o:Value)</li>
<li> .decl VPTClassHeap(v:Var, o:Value)</li>
<li> .decl VPTMerged(v:Var, o:Value)</li>
<li> .decl VPTMockVal(v:Var, o:Value)</li>
<li> .decl VPTNormal(v:Var, o:Value)</li>
<li> .decl VPTNum(v:Var, o:Value)</li>
<li> .decl VPTOpt(v:Var, o:Value)</li>
<li> .decl VPTOther(v:Var, o:Value)</li>
<li> .decl VPTStringConstant(v:Var, o:Value)</li>
<li> .decl VPTStringFactory(v:Var, o:Value)</li>
<li> .decl __AllocatedHeap(h:HeapAllocation)</li>
<li> .decl __CIHeap(h:HeapAllocation)</li>
<li> .decl __MergedHeap(h:HeapAllocation)</li>
</ul>
<h2> addons/sanity.dl </h2>
<ul>
<li> .decl ArtifactTypeMissingFromHierarchy(?t:ReferenceType)</li>
<li> .decl ClassTypeIsInterfaceType(?type:ReferenceType)</li>
<li> .decl FieldPointsToWronglyTypedValue(?field:Field, ?fieldType:Type, ?value:Value, ?valueType:Type)</li>
<li> .decl ForceTypeCompatibility(?valueType:Type, ?varType:Type)</li>
<li> .decl HeapAllocationHasNoType(?heap:HeapAllocation)</li>
<li> .decl InstructionIsConcreteInstruction(?insn:Instruction)</li>
<li> .decl InstructionIsNotConcreteInstruction(?insn:Instruction)</li>
<li> .decl NotReachableVarPointsTo(?var:Var, ?method:Method)</li>
<li> .decl PrimitiveTypeIsReferenceType(?type:PrimitiveType)</li>
<li> .decl Sanity(?n:symbol, ?s:symbol, ?c:number)</li>
<li> .decl TypeIsConcreteType(?type:Type)</li>
<li> .decl TypeIsNotConcreteType(?type:Type)</li>
<li> .decl ValueHasNoDeclaringType(?value:Value)</li>
<li> .decl ValueHasNoType(?value:Value)</li>
<li> .decl ValueIsNeitherHeapNorNonHeap(?value:Value)</li>
<li> .decl VarHasNoType(var:Var)</li>
<li> .decl VarPointsToMergedHeap(?var:Var, ?value:Value)</li>
<li> .decl VarPointsToWronglyTypedValue(?var:Var, ?varType:Type, ?value:Value, ?valueType:Type)</li>
</ul>
<h2> addons/sarif/sarif.dl </h2>
<ul>
<li> .decl SARIF_InterestingRelation(?name:symbol, ?doopIdPosition:number, ?contentType:symbol, ?resultMessage:symbol, ?ruleDescription:symbol, ?level:symbol)</li>
</ul>
<h2> addons/scaler/non_precision_critical_methods.dl </h2>
<ul>
<li> .decl MethodCantBenefitFromCS(?method:Method)</li>
<li> .decl MethodDoesStores(?method:Method)</li>
<li> .decl MethodDoesntCallOthers(?method:Method)</li>
<li> .decl MethodDoesntDoStores(?method:Method)</li>
<li> .decl MethodDoesntPassReferences(?method:Method)</li>
<li> .decl MethodDoesntReturnReference(?method:Method)</li>
<li> .decl MethodPassesReferences(?method:Method)</li>
<li> .decl MethodReturnsReference(?method:Method)</li>
<li> .decl Method_CalleeCanBenefitFromCS(?method:Method)</li>
</ul>
<h2> addons/server-logic/method-lookup-ext.dl </h2>
<ul>
<li> .decl Invocation_Parts(?invocation:MethodInvocation, ?simplename:symbol, ?descriptor:symbol, ?basetype:Type, ?isSingleDispatch:number)</li>
<li> .decl MethodLookupExt(?simplename:symbol, ?descriptor:MethodDescriptor, ?type:Type, ?method:Method, ?isSingleDispatch:number)</li>
<li> .decl SingleDispatch(?method:Method)</li>
</ul>
<h2> addons/server-logic/queries.dl </h2>
<ul>
<li> .decl Server_Array_Values(?arrayValue:Value, ?value:Value)</li>
<li> .decl Server_Field_ShadowedBy(?fld:Field, ?shadowFld:Field)</li>
<li> .decl Server_IField_Values(?baseValue:Value, ?fld:Field, ?value:Value)</li>
<li> .decl Server_IField_Values_Count(?baseValue:Value, ?fld:Field, ?n:number)</li>
<li> .decl Server_Invocation_Values(?fromMethod:Method, ?invo:MethodInvocation, ?toMethod:Method)</li>
<li> .decl Server_LeakingSinkVariable(?label:InformationLabel, ?tomethod:MethodInvocation, ?var:Var)</li>
<li> .decl Server_LeakingTaintedInformation(?fromLabel:InformationLabel, ?toLabel:InformationLabel, ?invocation:MethodInvocation, ?value:Value)</li>
<li> .decl Server_Method_Subtype(?method:Method, ?subMethod:Method)</li>
<li> .decl Server_Metrics(?metric:symbol, ?n:number)</li>
<li> .decl Server_SField_Values(?fld:Field, ?value:Value)</li>
<li> .decl Server_TypeCallsType(?fromClass:ReferenceType, ?toClass:ReferenceType)</li>
<li> .decl Server_Type_Can_Access_Field(?type:ReferenceType, ?fld:Field)</li>
<li> .decl Server_Var_Return(?var:Var, ?method:Method)</li>
<li> .decl Server_Var_Values(?type:ReferenceType, ?var:Var, ?value:Value)</li>
<li> .decl _AIPT(?arrayValue:Value, ?value:Value)</li>
<li> .decl _AIPT_Count(?arrayValue:Value, ?n:number)</li>
<li> .decl _AppVirtual(?invo:MethodInvocation)</li>
<li> .decl _AppVirtual_Resolved(?invo:MethodInvocation)</li>
<li> .decl _ClassTypeUnion(?c:ReferenceType)</li>
<li> .decl _IFPT(?baseValue:Value, ?fld:Field, ?value:Value)</li>
<li> .decl _InterestingVar(?var:Var)</li>
<li> .decl _SFPT(?fld:Field, ?value:Value)</li>
<li> .decl _SFPT_Count(?fld:Field, ?n:number)</li>
<li> .decl _Server_Interesting_Type(?class:ReferenceType)</li>
<li> .decl _VPT(?var:Var, ?value:Value)</li>
<li> .decl _VPT_Count(?var:Var, ?n:number)</li>
<li> .decl _Valid_Interesting_Type(?type:ReferenceType)</li>
<li> .decl _VarDeclaringClass(?var:Var, ?class:ReferenceType)</li>
<li> .decl _VarUnderThreshold(?var:Var)</li>
</ul>
<h2> addons/server-logic/type-hierarchy-ext.dl </h2>
<ul>
<li> .decl ClassConstructor(?method:Method, ?type:ClassType)</li>
</ul>
<h2> addons/souffle-incremental-output/incr-output.dl </h2>
<ul>
<li> .decl LiveOutputRelation(?relName:symbol)</li>
<li> .decl LiveOutputRelation_Res(?relName:symbol, ?res:number)</li>
<li> .decl RegAtExitFun(?pl:number)</li>
<li> .decl RegAtExitFun_Res(?pl:number, ?res:number)</li>
<li> .decl Successfull(?maxRes:number)</li>
<li> .decl ctxToNum(?ctx:mainAnalysis.configuration.Context, ?strCtx:number)</li>
<li> .decl hctxToNum(?ctx:mainAnalysis.configuration.HContext, ?strCtx:number)</li>
</ul>
<h2> addons/ssa-transform/analysis.dl </h2>
<ul>
<li> .decl AbstractConstraint(?var_sub:symbol, ?var_sup:symbol)</li>
<li> .decl ArrayLoad(?stmt:symbol, ?base:symbol, ?var:symbol)</li>
<li> .decl ArrayStore(?stmt:symbol, ?base:symbol, ?var:symbol)</li>
<li> .decl Assign(?stmt:symbol, ?var1:symbol, ?var2:symbol)</li>
<li> .decl AssignArray(?stmt:symbol, ?var1:symbol, ?var2:symbol)</li>
<li> .decl BasicBlockOutDefs(?block:symbol, ?ssa_var:symbol, ?origin:symbol)</li>
<li> .decl CommonAncestor(?type1:symbol, ?type2:symbol, ?supertype:symbol)</li>
<li> .decl CommonDescendant(?type1:symbol, ?type2:symbol, ?subtype:symbol)</li>
<li> .decl ConstraintForVar(?var:symbol, ?stmt:symbol)</li>
<li> .decl ContainsAssignment(?dBlock:symbol, ?var:symbol)</li>
<li> .decl DFPlus(?dBlock:symbol, ?block:symbol, ?var:symbol)</li>
<li> .decl DominanceFrontier(?dBlock:symbol, ?block:symbol)</li>
<li> .decl ExistsDefInPhiHeader(?insn:symbol, ?ssa_var:symbol, ?origin:symbol)</li>
<li> .decl ExistsNonGuardType(?var:symbol)</li>
<li> .decl ExistsPhiChunkBetween(?prev:symbol, ?next:symbol)</li>
<li> .decl ExistsPseudoAssignBetween(?prev:symbol, ?next:symbol)</li>
<li> .decl FirstConstraintForVar(?var:symbol, ?stmt:symbol)</li>
<li> .decl FirstLowerConstraintForVar(?var:symbol, ?stmt:symbol)</li>
<li> .decl FirstUpperConstraintForVar(?var:symbol, ?stmt:symbol)</li>
<li> .decl GreatestCommonDescendant(?type1:symbol, ?type2:symbol, ?subtype:symbol)</li>
<li> .decl HasKnownType(?stmt:symbol, ?var:symbol, ?type:symbol)</li>
<li> .decl InDefs(?insn:symbol, ?ssa_var:symbol, ?origin:symbol)</li>
<li> .decl Index_Next(?index:number, ?nextIndex:number)</li>
<li> .decl Integer32Constraint(?var:symbol, ?insn:symbol)</li>
<li> .decl LaterConstraintForVar(?var:symbol, ?stmt:symbol, ?stmtLater:symbol)</li>
<li> .decl LaterLowerConstraintForVar(?var:symbol, ?stmt:symbol, ?stmtLater:symbol)</li>
<li> .decl LaterUpperConstraintForVar(?var:symbol, ?stmt:symbol, ?stmtLater:symbol)</li>
<li> .decl LeastCommonAncestor(?type1:symbol, ?type2:symbol, ?supertype:symbol)</li>
<li> .decl LowerBoundTypeForAllConstraints(?var:symbol, ?type:symbol)</li>
<li> .decl LowerBoundTypeForConstraint(?var:symbol, ?type:symbol, ?stmt:symbol)</li>
<li> .decl LowerBoundTypeUpToConstraint(?var:symbol, ?type:symbol, ?stmt:symbol)</li>
<li> .decl LowerConstraintForVar(?var:symbol, ?stmt:symbol)</li>
<li> .decl LowerGlobalConstraint(?type:symbol)</li>
<li> .decl NewBBStart(?old:number, ?new:number, ?method:symbol)</li>
<li> .decl NewIndexMapping(?old:number, ?new:number, ?method:symbol)</li>
<li> .decl NextConstraintForVar(?var:symbol, ?stmt:symbol, ?stmtNext:symbol)</li>
<li> .decl NextLowerConstraintForVar(?var:symbol, ?stmt:symbol, ?stmtNext:symbol)</li>
<li> .decl NextUpperConstraintForVar(?var:symbol, ?stmt:symbol, ?stmtNext:symbol)</li>
<li> .decl NonGuardCompatibleTypes(?var:symbol, ?type:symbol)</li>
<li> .decl NotFirstConstraintForVar(?var:symbol, ?stmt:symbol)</li>
<li> .decl NotFirstLowerConstraintForVar(?var:symbol, ?stmt:symbol)</li>
<li> .decl NotFirstUpperConstraintForVar(?var:symbol, ?stmt:symbol)</li>
<li> .decl NotGreatestCommonDescendant(?type1:symbol, ?type2:symbol, ?subtype:symbol)</li>
<li> .decl NotLastConstraintForVar(?var:symbol, ?stmt:symbol)</li>
<li> .decl NotLastLowerConstraintForVar(?var:symbol, ?stmt:symbol)</li>
<li> .decl NotLastUpperConstraintForVar(?var:symbol, ?stmt:symbol)</li>
<li> .decl NotLeastCommonAncestor(?type1:symbol, ?type2:symbol, ?supertype:symbol)</li>
<li> .decl PhiAssign(?phi_var:symbol, ?block:symbol)</li>
<li> .decl PhiChunkEnd(?phi_chunk:symbol, ?end:symbol)</li>
<li> .decl PhiChunkNext(?prev:symbol, ?next:symbol)</li>
<li> .decl PhiChunkStart(?phi_chunk:symbol, ?start:symbol)</li>
<li> .decl PhiHeaderEnd(?phi_chunk:symbol, ?end:symbol)</li>
<li> .decl PhiHeaderNext(?prev:symbol, ?next:symbol)</li>
<li> .decl PhiHeaderStart(?phi_chunk:symbol, ?start:symbol)</li>
<li> .decl PhiPseudoAssign(?phi_var:symbol, ?def:symbol, ?dst_block:symbol, ?pseudoname:symbol)</li>
<li> .decl PrimOp(?insn:symbol, ?to:symbol, ?from:symbol)</li>
<li> .decl ReachingDef(?insn:symbol, ?ssa_var:symbol, ?origin:symbol)</li>
<li> .decl RewriteActualParam(?index:number, ?invocation:symbol, ?var:symbol)</li>
<li> .decl RewriteArrayInitialValueFromConst(?insn:symbol, ?index:number, ?to:symbol, ?arrayIndex:number, ?const:symbol, ?baseHeap:symbol, ?inmethod:symbol)</li>
<li> .decl RewriteArrayInitialValueFromLocal(?insn:symbol, ?index:number, ?to:symbol, ?arrayIndex:number, ?from:symbol, ?baseHeap:symbol, ?inmethod:symbol)</li>
<li> .decl RewriteArrayInsnIndex(?insn:symbol, ?index:symbol)</li>
<li> .decl RewriteAssignBinop(?insn:symbol, ?index:number, ?to:symbol, ?inmethod:symbol)</li>
<li> .decl RewriteAssignCast(?insn:symbol, ?index:number, ?from:symbol, ?to:symbol, ?type:symbol, ?inmethod:symbol)</li>
<li> .decl RewriteAssignCastNull(?insn:symbol, ?index:number, ?to:symbol, ?type:symbol, ?inmethod:symbol)</li>
<li> .decl RewriteAssignCastNumConstant(?insn:symbol, ?index:number, ?const:symbol, ?to:symbol, ?type:symbol, ?inmethod:symbol)</li>
<li> .decl RewriteAssignHeapAllocation(?insn:symbol, ?index:number, ?heap:symbol, ?to:symbol, ?inmethod:symbol, ?linenumber:number)</li>
<li> .decl RewriteAssignInstanceOf(?insn:symbol, ?index:number, ?from:symbol, ?to:symbol, ?type:symbol, ?inmethod:symbol)</li>
<li> .decl RewriteAssignLocal(?insn:symbol, ?index:number, ?to:symbol, ?from:symbol, ?inmethod:symbol)</li>
<li> .decl RewriteAssignNull(?insn:symbol, ?index:number, ?to:symbol, ?inmethod:symbol)</li>
<li> .decl RewriteAssignNumConstant(?insn:symbol, ?index:number, ?const:symbol, ?to:symbol, ?inmethod:symbol)</li>
<li> .decl RewriteAssignOperFrom(?insn:symbol, ?pos:number, ?from:symbol)</li>
<li> .decl RewriteAssignReturnValue(?invocation:symbol, ?to:symbol)</li>
<li> .decl RewriteAssignUnop(?insn:symbol, ?index:number, ?to:symbol, ?inmethod:symbol)</li>
<li> .decl RewriteBootstrapParam(?index:number, ?invocation:symbol, ?var:symbol)</li>
<li> .decl RewriteDynamicMethodInvocation(?insn:symbol, ?index:number, ?bootSignature:symbol, ?dynName:symbol, ?dynRetType:symbol, ?dynArity:number, ?dynParamTypes:symbol, ?tag:number, ?method:symbol)</li>
<li> .decl RewriteEnterMonitor(?instruction:symbol, ?index:number, ?var:symbol, ?method:symbol)</li>
<li> .decl RewriteExceptionHandler(?handler:symbol, ?method:symbol, ?index:number, ?type:symbol, ?begin:number, ?end:number)</li>
<li> .decl RewriteExceptionHandler_FormalParam(?handler:symbol, ?var:symbol)</li>
<li> .decl RewriteExitMonitor(?instruction:symbol, ?index:number, ?var:symbol, ?method:symbol)</li>
<li> .decl RewriteGoto(?insn:symbol, ?index:number, ?to:number, ?inmethod:symbol)</li>
<li> .decl RewriteIf(?insn:symbol, ?index:number, ?to:number, ?inmethod:symbol)</li>
<li> .decl RewriteIfVar(?insn:symbol, ?pos:number, ?var:symbol)</li>
<li> .decl RewriteLoadArrayIndex(?insn:symbol, ?index:number, ?to:symbol, ?base:symbol, ?method:symbol)</li>
<li> .decl RewriteLoadInstanceField(?insn:symbol, ?index:number, ?to:symbol, ?base:symbol, ?signature:symbol, ?method:symbol)</li>
<li> .decl RewriteLoadStaticField(?insn:symbol, ?index:number, ?to:symbol, ?signature:symbol, ?method:symbol)</li>
<li> .decl RewriteLookupSwitch(?insn:symbol, ?index:number, ?key:symbol, ?method:symbol)</li>
<li> .decl RewriteLookupSwitch_DefaultTarget(?insn:symbol, ?target:number)</li>
<li> .decl RewriteLookupSwitch_Target(?insn:symbol, ?value:number, ?target:number)</li>
<li> .decl RewriteReturn(?insn:symbol, ?index:number, ?var:symbol, ?inmethod:symbol)</li>
<li> .decl RewriteReturnVoid(?insn:symbol, ?index:number, ?inmethod:symbol)</li>
<li> .decl RewriteSpecialMethodInvocation(?insn:symbol, ?index:number, ?signature:symbol, ?base:symbol, ?method:symbol)</li>
<li> .decl RewriteStaticMethodInvocation(?insn:symbol, ?index:number, ?signature:symbol, ?method:symbol)</li>
<li> .decl RewriteStoreArrayIndex(?insn:symbol, ?index:number, ?from:symbol, ?base:symbol, ?method:symbol)</li>
<li> .decl RewriteStoreInstanceField(?insn:symbol, ?index:number, ?from:symbol, ?base:symbol, ?signature:symbol, ?method:symbol)</li>
<li> .decl RewriteStoreStaticField(?insn:symbol, ?index:number, ?from:symbol, ?signature:symbol, ?method:symbol)</li>
<li> .decl RewriteSuperMethodInvocation(?insn:symbol, ?index:number, ?signature:symbol, ?base:symbol, ?method:symbol)</li>
<li> .decl RewriteTableSwitch(?insn:symbol, ?index:number, ?key:symbol, ?method:symbol)</li>
<li> .decl RewriteTableSwitch_DefaultTarget(?insn:symbol, ?target:number)</li>
<li> .decl RewriteTableSwitch_Target(?insn:symbol, ?value:number, ?target:number)</li>
<li> .decl RewriteThrow(?insn:symbol, ?index:number, ?var:symbol, ?method:symbol)</li>
<li> .decl RewriteThrowNull(?insn:symbol, ?index:number, ?method:symbol)</li>
<li> .decl RewriteVarDeclaringMethod(?var:symbol, ?method:symbol)</li>
<li> .decl RewriteVirtualMethodInvocation(?insn:symbol, ?index:number, ?signature:symbol, ?base:symbol, ?method:symbol)</li>
<li> .decl SSANext(?prev:symbol, ?next:symbol)</li>
<li> .decl SSA_Alias(?ssa_name:symbol, ?original:symbol)</li>
<li> .decl SSA_AssignDetails(?instr:symbol, ?to:symbol, ?index:number, ?ssa_name:symbol, ?method:symbol)</li>
<li> .decl SSA_AssignNumConstant(?insn:symbol, ?to:symbol, ?const:symbol, ?inmethod:symbol)</li>
<li> .decl SSA_AssignToOriginal(?instr:symbol, ?original:symbol)</li>
<li> .decl SSA_FormalParam(?index:number, ?method:symbol, ?ssa_name:symbol)</li>
<li> .decl SSA_InstructionIndex(?insn:symbol, ?index:number)</li>
<li> .decl SSA_ThisVar(?method:symbol, ?ssa_name:symbol)</li>
<li> .decl SSA_Type(?var:symbol, ?type:symbol)</li>
<li> .decl SSA_TypeOrd(?var:symbol, ?typeId:number)</li>
<li> .decl StatementType(?insn:symbol, ?in_type:symbol, ?out_type:symbol)</li>
<li> .decl StrictlyDominates(?dominator:symbol, ?block:symbol)</li>
<li> .decl TypeBetween(?upper:symbol, ?lower:symbol, ?type:symbol)</li>
<li> .decl TypeCompatibleWithAllConstraints(?var:symbol, ?type:symbol)</li>
<li> .decl UpperBoundTypeForAllConstraints(?var:symbol, ?type:symbol)</li>
<li> .decl UpperBoundTypeForConstraint(?var:symbol, ?type:symbol, ?stmt:symbol)</li>
<li> .decl UpperBoundTypeUpToConstraint(?var:symbol, ?type:symbol, ?stmt:symbol)</li>
<li> .decl UpperConstraintForVar(?var:symbol, ?stmt:symbol)</li>
<li> .decl UpperGlobalConstraint(?type:symbol)</li>
<li> .decl isGuardInt32(?t:symbol)</li>
<li> .decl isGuardPrimitive(?t:symbol)</li>
<li> .decl isGuardPrimitive32(?t:symbol)</li>
<li> .decl isInt32Bottom(?t:symbol)</li>
<li> .decl isInt32Primitive(?t:symbol)</li>
<li> .decl isInt32Top(?t:symbol)</li>
<li> .decl isPrimitive32Bottom(?t:symbol)</li>
<li> .decl isPrimitive32Top(?t:symbol)</li>
<li> .decl isPrimitive64Bottom(?t:symbol)</li>
<li> .decl isPrimitive64Top(?t:symbol)</li>
<li> .decl isZeroAssignTo(?insn:symbol, ?to:symbol)</li>
<li> .decl mPrimitives(?t:symbol)</li>
<li> .decl mSubtypeOf(?s:symbol, ?t:symbol)</li>
</ul>
<h2> addons/statistics/metrics.dl </h2>
<ul>
<li> .decl ContextsPerMethod(?method:Method, ?n:number)</li>
<li> .decl DependencyMethodDirectlyReachableFromApplication(?method:symbol)</li>
<li> .decl DependencyMethodDirectlyReachableFromDependency(?method:symbol)</li>
<li> .decl DependencyMethodDirectlyReachableFromSDK(?method:symbol)</li>
<li> .decl IFPTToVPTRatioPerType(?type:Type, ?n:number)</li>
<li> .decl InstanceFieldPointsToCountPerType(?type:Type, Y:number)</li>
<li> .decl Metrics_AppEntryPoint(?method:Method)</li>
<li> .decl Metrics_InvocationTargets_Count(?invo:MethodInvocation, ?n:number)</li>
<li> .decl Metrics_InvocationZeroTargets(?invo:MethodInvocation)</li>
<li> .decl Metrics_Method_IncomingInvo_Count(?method:Method, ?n:number)</li>
<li> .decl Metrics_Method_IncomingMethods_Count(?method:Method, ?n:number)</li>
<li> .decl Metrics_Method_OutgoingInvo_Count(?method:Method, ?n:number)</li>
<li> .decl Metrics_Method_OutgoingMethods_Count(?method:Method, ?n:number)</li>
<li> .decl Metrics_Value_AsReceiver_Count(?value:Value, ?n:number)</li>
<li> .decl PointsToCountPerType(?type:Type, Y:number)</li>
<li> .decl ReachableApplicationClass(?class:symbol)</li>
<li> .decl ReachableClass(?class:symbol)</li>
<li> .decl ReachableDependencyClass(?class:symbol)</li>
<li> .decl ReachableSDKClass(?class:symbol)</li>
<li> .decl SDKMethodDirectlyReachableFromApplication(?method:symbol)</li>
<li> .decl SDKMethodDirectlyReachableFromDependency(?method:symbol)</li>
<li> .decl SDKMethodDirectlyReachableFromSDK(?method:symbol)</li>
<li> .decl _MethodIncomingInvo(?toMethod:Method, ?invo:MethodInvocation)</li>
<li> .decl _MethodIncomingMethod(?toMethod:Method, ?inMethod:Method)</li>
<li> .decl _MethodOutgoingInvo(?inMethod:Method, ?invo:MethodInvocation)</li>
<li> .decl _MethodOutgoingMethod(?inMethod:Method, ?toMethod:Method)</li>
<li> .decl _Metrics_InvoTargets(?invo:MethodInvocation, ?toMethod:Method)</li>
<li> .decl _ValueAsReceiver(?value:Value, ?invo:VirtualMethodInvocation_Insn)</li>
</ul>
<h2> addons/statistics/statistics-declarations.dl </h2>
<ul>
<li> .decl Method_NumberOfContexts(?method:Method, ?n:number)</li>
<li> .decl Method_TotalVPT(?method:Method, Y:number)</li>
<li> .decl Method_VPTCountPerMethodVariable(?method:Method, ?var:Var, ?n:number)</li>
<li> .decl Stats_ApplicationHeap(?heap:HeapAllocation)</li>
<li> .decl Stats_ArrayCount(?basehctx:mainAnalysis.configuration.HContext, ?basevalue:Value, ?n:number)</li>
<li> .decl Stats_Arrays(?n:number)</li>
<li> .decl Stats_FieldCount(?sig:Field, ?basehctx:mainAnalysis.configuration.HContext, ?basevalue:Value, ?n:number)</li>
<li> .decl Stats_Fields(?n:number)</li>
<li> .decl Stats_InsensArrayCount(?basevalue:Value, ?n:number)</li>
<li> .decl Stats_InsensArrays(?n:number)</li>
<li> .decl Stats_InsensBaseValueArrayCount(?basevalue:Value, ?n:number)</li>
<li> .decl Stats_InsensBaseValueArrayIndexPointsTo(?hctx:mainAnalysis.configuration.HContext, ?value:Value, ?basevalue:Value)</li>
<li> .decl Stats_InsensBaseValueFieldCount(?sig:Field, ?basevalue:Value, ?n:number)</li>
<li> .decl Stats_InsensBaseValueInstanceFieldPointsTo(?hctx:mainAnalysis.configuration.HContext, ?value:Value, ?sig:Field, ?basevalue:Value)</li>
<li> .decl Stats_InsensBaseVarCount(?var:Var, ?n:number)</li>
<li> .decl Stats_InsensBaseVarPointsTo(?hctx:mainAnalysis.configuration.HContext, ?value:Value, ?var:Var)</li>
<li> .decl Stats_InsensFieldCount(?sig:Field, ?basevalue:Value, ?n:number)</li>
<li> .decl Stats_InsensFields(?n:number)</li>
<li> .decl Stats_InsensThrowPointsTo(?value:Value, ?method:Method)</li>
<li> .decl Stats_InsensValueArrayCount(?basehctx:mainAnalysis.configuration.HContext, ?basevalue:Value, ?n:number)</li>
<li> .decl Stats_InsensValueArrayIndexPointsTo(?value:Value, ?basehctx:mainAnalysis.configuration.HContext, ?basevalue:Value)</li>
<li> .decl Stats_InsensValueFieldCount(?sig:Field, ?basehctx:mainAnalysis.configuration.HContext, ?basevalue:Value, ?n:number)</li>
<li> .decl Stats_InsensValueInstanceFieldPointsTo(?value:Value, ?sig:Field, ?basehctx:mainAnalysis.configuration.HContext, ?basevalue:Value)</li>
<li> .decl Stats_InsensValueThrowPointsTo(?value:Value, ?ctx:mainAnalysis.configuration.Context, ?method:Method)</li>
<li> .decl Stats_InsensValueVarCount(?ctx:mainAnalysis.configuration.Context, ?var:Var, ?n:number)</li>
<li> .decl Stats_InsensValueVarPointsTo(?value:Value, ?ctx:mainAnalysis.configuration.Context, ?var:Var)</li>
<li> .decl Stats_InsensVarCount(?var:Var, ?n:number)</li>
<li> .decl Stats_InsensVars(?n:number)</li>
<li> .decl Stats_MethodContextCount(?method:Method, ?n:number)</li>
<li> .decl Stats_Methods(?n:number)</li>
<li> .decl Stats_VarCount(?ctx:mainAnalysis.configuration.Context, ?var:Var, ?n:number)</li>
<li> .decl Stats_Vars(?n:number)</li>
</ul>
<h2> addons/statistics/statistics-simple-declarations.dl </h2>
<ul>
<li> .decl NotLibraryHeapAllocation(?heap:HeapAllocation)</li>
<li> .decl Stats_Simple_ApplicationConcreteMethod(?method:Method)</li>
<li> .decl Stats_Simple_Application_ArrayIndexPointsTo(?hctx:mainAnalysis.configuration.HContext, ?value:Value, ?basehctx:mainAnalysis.configuration.HContext, ?basevalue:Value)</li>
<li> .decl Stats_Simple_Application_Cast(?type:Type, ?from:Var, ?to:Var, ?inmethod:Method)</li>
<li> .decl Stats_Simple_Application_DynamicReachableMethod(?method:Method)</li>
<li> .decl Stats_Simple_Application_EmptyReachableVirtualMethodInvocation(?invocation:MethodInvocation)</li>
<li> .decl Stats_Simple_Application_InsensArrayIndexPointsTo(?value:Value, ?basevalue:Value)</li>
<li> .decl Stats_Simple_Application_InsensDynamicInstanceFieldPointsTo(?baseHeap:HeapAllocation, ?fld:Field, ?heap:HeapAllocation)</li>
<li> .decl Stats_Simple_Application_InsensDynamicStaticFieldPointsTo(?fld:Field, ?heap:HeapAllocation)</li>
<li> .decl Stats_Simple_Application_InsensInstanceFieldPointsTo(?value:Value, ?sig:Field, ?basevalue:Value)</li>
<li> .decl Stats_Simple_Application_InsensTaintedVarPointsTo(?value:Value, ?var:Var)</li>
<li> .decl Stats_Simple_Application_InsensVarPointsTo(?value:Value, ?var:Var)</li>
<li> .decl Stats_Simple_Application_InstanceFieldPointsTo(?hctx:mainAnalysis.configuration.HContext, ?value:Value, ?sig:Field, ?basehctx:mainAnalysis.configuration.HContext, ?basevalue:Value)</li>
<li> .decl Stats_Simple_Application_NullVirtualMethodInvocation(?invocation:MethodInvocation)</li>
<li> .decl Stats_Simple_Application_PolymorphicCallSite(?invocation:MethodInvocation)</li>
<li> .decl Stats_Simple_Application_PotentiallyFailingCast(?type:Type, ?from:Var, ?to:Var)</li>
<li> .decl Stats_Simple_Application_ReachableCast(?inmethod:Method, ?type:Type, ?to:Var, ?from:Var)</li>
<li> .decl Stats_Simple_Application_ReachableMethod(?method:Method)</li>
<li> .decl Stats_Simple_Application_ReachableVirtualMethodInvocation(?invocation:MethodInvocation)</li>
<li> .decl Stats_Simple_Application_TaintedVarPointsTo(?value:Value, ?ctx:mainAnalysis.configuration.Context, ?var:Var)</li>
<li> .decl Stats_Simple_Application_VarPointsTo(?hctx:mainAnalysis.configuration.HContext, ?value:Value, ?ctx:mainAnalysis.configuration.Context, ?var:Var)</li>
<li> .decl Stats_Simple_Application_VirtualMethodInvocation(?invocation:MethodInvocation)</li>
<li> .decl Stats_Simple_AssignedVariable(?var:Var)</li>
<li> .decl Stats_Simple_Class_newInstance(?invocation:MethodInvocation)</li>
<li> .decl Stats_Simple_Constructor_newInstance(?invocation:MethodInvocation)</li>
<li> .decl Stats_Simple_ContextInsensitiveMethodsVPT(?hctx:mainAnalysis.configuration.HContext, ?value:Value, ?ctx:mainAnalysis.configuration.Context, ?var:Var)</li>
<li> .decl Stats_Simple_EmptyVirtualMethodInvocation(?invocation:MethodInvocation)</li>
<li> .decl Stats_Simple_InsensArrayIndexPointsTo(?value:Value, ?basevalue:Value)</li>
<li> .decl Stats_Simple_InsensCallGraphEdge(?from:MethodInvocation, ?to:Method)</li>
<li> .decl Stats_Simple_InsensDynamicArrayIndexPointsTo(?heap:HeapAllocation, ?baseHeap:HeapAllocation)</li>
<li> .decl Stats_Simple_InsensDynamicCallGraphEdge(?fromMeth:Method, ?invocation:MethodInvocation, ?toMeth:Method)</li>
<li> .decl Stats_Simple_InsensDynamicInstanceFieldPointsTo(?fld:Field, ?heap:HeapAllocation, ?baseHeap:HeapAllocation)</li>
<li> .decl Stats_Simple_InsensDynamicStaticFieldPointsTo(?fld:Field, ?heap:HeapAllocation)</li>
<li> .decl Stats_Simple_InsensInstanceFieldPointsTo(?value:Value, ?sig:Field, ?basevalue:Value)</li>
<li> .decl Stats_Simple_InsensReachableApplicationMethod(?method:Method)</li>
<li> .decl Stats_Simple_InsensReachableVar(?var:Var)</li>
<li> .decl Stats_Simple_InsensStaticFieldPointsTo(?value:Value, ?sig:Field)</li>
<li> .decl Stats_Simple_InsensTaintedVarPointsTo(?value:Value, ?var:Var)</li>
<li> .decl Stats_Simple_InsensVarPointsTo(?value:Value, ?var:Var)</li>
<li> .decl Stats_Simple_JavaUtilInsensVarPointsTo(?value:Value, ?var:Var)</li>
<li> .decl Stats_Simple_JavaUtilVarPointsTo(?hctx:mainAnalysis.configuration.HContext, ?value:Value, ?ctx:mainAnalysis.configuration.Context, ?var:Var)</li>
<li> .decl Stats_Simple_LeakingTaintedInformation(?invocation:MethodInvocation, ?objStr:symbol)</li>
<li> .decl Stats_Simple_NonReachableAndroidApplicationConcreteMethod(?method:Method)</li>
<li> .decl Stats_Simple_NonReachableApplicationConcreteMethod(?method:Method)</li>
<li> .decl Stats_Simple_NullVirtualMethodInvocation(?invocation:MethodInvocation)</li>
<li> .decl Stats_Simple_OriginalTaintedValue(?id:symbol)</li>
<li> .decl Stats_Simple_PolymorphicCallSite(?invocation:MethodInvocation)</li>
<li> .decl Stats_Simple_PotentiallyFailingCast(?type:Type, ?from:Var, ?to:Var)</li>
<li> .decl Stats_Simple_ReachableApplicationMethod(?ctx:mainAnalysis.configuration.Context, ?method:Method)</li>
<li> .decl Stats_Simple_ReachableCast(?inmethod:Method, ?type:Type, ?to:Var, ?from:Var)</li>
<li> .decl Stats_Simple_ReachableVar(?ctx:mainAnalysis.configuration.Context, ?var:Var)</li>
<li> .decl Stats_Simple_ReachableVirtualMethodInvocation(?invocation:MethodInvocation)</li>
<li> .decl Stats_Simple_Reflection_ArrayIndexPointsTo(?hctx:mainAnalysis.configuration.HContext, ?value:Value, ?basehctx:mainAnalysis.configuration.HContext, ?basevalue:Value)</li>
<li> .decl Stats_Simple_Reflection_InsensArrayIndexPointsTo(?value:Value, ?basevalue:Value)</li>
<li> .decl Stats_Simple_Reflection_InsensInstanceFieldPointsTo(?value:Value, ?sig:Field, ?basevalue:Value)</li>
<li> .decl Stats_Simple_Reflection_InsensVarPointsTo(?value:Value, ?var:Var)</li>
<li> .decl Stats_Simple_Reflection_InstanceFieldPointsTo(?hctx:mainAnalysis.configuration.HContext, ?value:Value, ?sig:Field, ?basehctx:mainAnalysis.configuration.HContext, ?basevalue:Value)</li>
<li> .decl Stats_Simple_Reflection_VarPointsTo(?hctx:mainAnalysis.configuration.HContext, ?value:Value, ?ctx:mainAnalysis.configuration.Context, ?var:Var)</li>
<li> .decl Stats_Simple_TwoObjectMethodsVPT(?hctx:mainAnalysis.configuration.HContext, ?value:Value, ?ctx:mainAnalysis.configuration.Context, ?var:Var)</li>
<li> .decl Stats_Simple_VirtualCallGraphEdge(?from:MethodInvocation, ?to:Method)</li>
<li> .decl Stats_Simple_VirtualTargets(?invocation:MethodInvocation, ?c:number)</li>
<li> .decl Stats_Simple_forName(?invocation:MethodInvocation)</li>
</ul>
<h2> addons/statistics/statistics-simple.dl </h2>
<ul>
<li> .decl Stats_Simple_Application_DynamicCallGraphEdge(?invocation:Instruction, ?toMeth:Method)</li>
<li> .decl Stats_Simple_Application_InsensCallGraphEdge(?invocation:Instruction, ?toMeth:Method)</li>
</ul>
<h2> addons/symbolic-reasoning/arithmetic-reasoning.dl </h2>
<ul>
<li> .decl Transitive(?expr: Expr)</li>
</ul>
<h2> addons/symbolic-reasoning/declarations.dl </h2>
<ul>
<li> .decl AssignBinaryConstConst(?insn:Instruction, ?var: Var, ?meth: Method, ?right1: NumConstant, ?right2: NumConstant, ?op: Operator)</li>
<li> .decl AssignBinaryConstVar(?insn:Instruction, ?var: Var, ?meth: Method, ?right1: NumConstant, ?right2: Var, ?op: Operator)</li>
<li> .decl AssignBinaryVarConst(?insn:Instruction, ?var: Var, ?meth: Method, ?right1: Var, ?right2: NumConstant, ?op: Operator)</li>
<li> .decl AssignBinaryVarVar(?insn:Instruction, ?var: Var, ?meth: Method, ?right1: Var, ?right2: Var, ?op: Operator)</li>
<li> .decl BuildPathExprBefore(?meth:Method, prev:Instruction, ?exprBase: Expr, ?insn:Instruction)</li>
<li> .decl ExprImpliesOther(?expr: Expr, ?exprOther: Expr)</li>
<li> .decl ExprIsAlwaysFalse(?expr: Expr)</li>
<li> .decl ExprIsAlwaysTrue(?expr: Expr)</li>
<li> .decl ExprIsNegationOfOther(?expr: Expr, ?exprOther: Expr)</li>
<li> .decl Expression_Method(?expr: Expr, ?meth: Method)</li>
<li> .decl FirstIfInsnInMethod(?insn: Instruction, ?meth: Method)</li>
<li> .decl FirstOfMultiplePredsOfInsnInMethod(?pred: Instruction, ?insn: Instruction, ?meth: Method)</li>
<li> .decl FirstPredOfInsnInMethod(?meth: Method, ?first: Instruction, ?insn: Instruction)</li>
<li> .decl FirstPredOfInsnInMethodOrdinal(?meth: Method, ?first: number, ?insn: Instruction)</li>
<li> .decl IfVarConst(?insn: Instruction, ?var: Var, ?meth: Method, ?right1: Var, ?right2: NumConstant, ?op: Operator)</li>
<li> .decl IfVarVar(?insn: Instruction, ?var: Var, ?meth: Method, ?right1: Var, ?right2: Var, ?op: Operator)</li>
<li> .decl IfsInMethod(?insn: Instruction, ?meth: Method)</li>
<li> .decl LastOfMultiplePredsOfInsnInMethod(?pred: Instruction, ?insn: Instruction, ?meth: Method)</li>
<li> .decl LastPredOfInsnInMethod(?meth: Method, ?first: Instruction, ?insn: Instruction)</li>
<li> .decl LastPredOfInsnInMethodOrdinal(?meth: Method, ?first: number, ?insn: Instruction)</li>
<li> .decl LeftExpr(?var: Var, ?op: Operator, ?constL: Expr)</li>
<li> .decl NegateOp(after: Operator, before: Operator)</li>
<li> .decl NegationOfConditionAtIfInsn(cond: Expr, negatedCond: Expr, ?insn: Instruction)</li>
<li> .decl NextOfMultiplePredsOfInsnInMethod(?next: Instruction, ?prev: Instruction, ?insn: Instruction, ?meth: Method)</li>
<li> .decl NextPredOfInsnInMethod(?meth: Method, ?prev: Instruction, ?next: Instruction, ?insn:Instruction)</li>
<li> .decl NotNextPredOfInsnInMethod(?meth: Method, ?prev: Instruction, ?next: Instruction, ?insn: Instruction)</li>
<li> .decl PathExpressionAfterFalse(?meth: Method, ?insn: Instruction, ?pathExpr: Expr)</li>
<li> .decl PathExpressionAfterTrue(?meth: Method, ?insn: Instruction, ?pathExpr: Expr)</li>
<li> .decl PathExpressionBefore(?meth:Method, ?insn: Instruction, ?pathExpr: Expr)</li>
<li> .decl ResolveExpr(?meth: Method, ?var: symbol, ?expr: Expr)</li>
<li> .decl RightExpr(?var: Var, ?op: Operator, ?constR: Expr)</li>
<li> .decl Sanity(?expr: Expr)</li>
<li> .decl SinglePredOfInsnInMethod(?pred: Instruction, ?insn: Instruction, ?meth: Method)</li>
<li> .decl ToString(?expr: Expr, ?out: symbol)</li>
<li> .decl isArithmeticExpr(?expr: Expr)</li>
<li> .decl isBooleanExpr(?expr: Expr)</li>
<li> .decl isBooleanExprLeftRight(?exprOther: Expr, ?exprX: Expr, ?exprY: Expr, ?op: Operator)</li>
<li> .decl isBooleanExprLeftRightInMethod(?expr: Expr, ?exprX: Expr, ?exprZ: Expr, ?op: Operator, ?meth: Method)</li>
<li> .decl isExpr(?expr: Expr)</li>
<li> .decl isOperator(?op: Operator)</li>
<li> .decl isReferenceExpr(?expr: Expr)</li>
<li> .decl isRelationalOperator(?op: Operator)</li>
<li> .decl isSymbolicInput(?symbInput: SymbolicInput)</li>
<li> .decl isTransitiveBooleanConjunction(?expr: Expr, ?exprX: Expr, ?exprZ: Expr, ?op: Operator)</li>
</ul>
<h2> addons/tamiflex/declarations.dl </h2>
<ul>
<li> .decl Tamiflex_Array_NewInstance(?invocation:MethodInvocation, ?value:Value)</li>
<li> .decl Tamiflex_Class_NewInstance(?invocation:MethodInvocation, ?value:Value)</li>
<li> .decl Tamiflex_Constructor_NewInstance(?invocation:MethodInvocation, ?constructor:Method, ?value:Value)</li>
<li> .decl Tamiflex_Invoke(?callerCtx:configuration.Context, ?invocation:MethodInvocation, ?method:Method)</li>
<li> .decl Tamiflex_ReifiedField(?fld:Field, ?value:Value, ?invocation:MethodInvocation)</li>
<li> .decl Tamiflex_ReifiedFieldArray(?type:Type, ?value:Value, ?invocation:MethodInvocation)</li>
<li> .decl Tamiflex_ReifiedMethod(?method:Method, ?value:Value, ?invocation:MethodInvocation)</li>
<li> .decl Tamiflex_ReifiedMethodArray(?type:Type, ?value:Value, ?invocation:MethodInvocation)</li>
</ul>
<h2> addons/tamiflex/fact-declarations.dl </h2>
<ul>
<li> .decl Tamiflex_ReflectionData(?classStr:symbol, ?methodStr:symbol, ?mapped:symbol, ?inClassStr:symbol, ?inMethodStr:symbol, ?lineNumber:number)</li>
<li> .decl Tamiflex_ReflectionMap(?mapped:symbol, ?invocation:MethodInvocation)</li>
</ul>
<h2> addons/tamiflex/import.dl </h2>
<ul>
<li> .decl _Tamiflex_ReflectionData(?classStr:symbol, ?methodStr:symbol, ?mapped:symbol, ?inClassStr:symbol, ?inMethodStr:symbol, ?lineNumber:number)</li>
<li> .decl _Tamiflex_ToDoopFormat(?orig:symbol, ?formatted:symbol)</li>
</ul>
<h2> addons/tamiflex/rules.dl </h2>
<ul>
<li> .decl OptForNameInvocation(?invocation:MethodInvocation, ?inmethod:Method)</li>
<li> .decl TamiflexCallGraphEdge(?callerCtx:configuration.Context, ?invocation:MethodInvocation, ?calleeCtx:configuration.Context, ?callee:Method)</li>
<li> .decl TamiflexConstructorCallGraphEdge(?callerCtx:configuration.Context, ?invocation:MethodInvocation, ?calleeCtx:configuration.Context, ?callee:Method)</li>
<li> .decl TamiflexInvocationArgumentArrayValue(?calleeCtx:configuration.Context, ?formal:Var, ?basehctx:configuration.HContext, ?basevalue:Value)</li>
<li> .decl TamiflexInvocationFirstParam(?calleeCtx:configuration.Context, ?formal:Var, ?callerCtx:configuration.Context, ?argsParam:Var)</li>
</ul>
<h2> addons/testing/AndroidTests_TypesOnly_androidterm.dl </h2>
<ul>
<li> .decl TestId(?id:symbol)</li>
</ul>
<h2> addons/testing/TestInvokedynamic.dl </h2>
<ul>
<li> .decl TestId(?id:symbol)</li>
</ul>
<h2> addons/testing/TestReflection.dl </h2>
<ul>
<li> .decl TestId(?id:symbol)</li>
</ul>
<h2> addons/testing/test-discovery.dl </h2>
<ul>
<li> .decl EvoSuiteEntryPoint(?m:Method)</li>
<li> .decl JUnitAnnotatedMethod(?m:Method)</li>
<li> .decl JUnitGenerator(?m:Method)</li>
<li> .decl JUnitTestMethod(?m:Method, ?tInstance:Value)</li>
<li> .decl TestNGAnnotatedMethod(?m:Method)</li>
</ul>
<h2> analyses/1-call-site-sensitive+heap/analysis.dl </h2>
<ul>
<li> .decl StartupInvocation(?invocation:MethodInvocation)</li>
</ul>
<h2> analyses/1-call-site-sensitive/analysis.dl </h2>
<ul>
<li> .decl StartupInvocation(?invocation:MethodInvocation)</li>
</ul>
<h2> analyses/1-object-sensitive/analysis.dl </h2>
<ul>
<li> .decl ContextToHContext(?ctx:Context, ?hctx:HContext)</li>
</ul>
<h2> analyses/2-call-site-sensitive+2-heap/analysis.dl </h2>
<ul>
<li> .decl StartupInvocation(?startupInvocation:MethodInvocation)</li>
</ul>
<h2> analyses/2-call-site-sensitive+heap/analysis.dl </h2>
<ul>
<li> .decl StartupInvocation(?startupInvocation:MethodInvocation)</li>
</ul>
<h2> analyses/adaptive-2-object-sensitive+heap/analysis.dl </h2>
<ul>
<li> .decl EntryContextMethod(?method:Method)</li>
<li> .decl InsensitiveMethod(?method:Method)</li>
<li> .decl MethodCallsOthers(?method:Method)</li>
<li> .decl MethodCantBenefitFromCS(?method:Method)</li>
<li> .decl MethodContext(?method: Method, ?ctx1: Value, ?ctx2: Value)</li>
<li> .decl MethodContext(?method: Method, ?ctx1: Value, ?ctx2: Value)</li>
<li> .decl MethodDoesStores(?method:Method)</li>
<li> .decl MethodDoesntCallOthers(?method:Method)</li>
<li> .decl MethodDoesntDoStores(?method:Method)</li>
<li> .decl MethodDoesntPassReferences(?method:Method)</li>
<li> .decl MethodDoesntReturnReference(?method:Method)</li>
<li> .decl MethodPassesReferences(?method:Method)</li>
<li> .decl MethodReturnsReference(?method:Method)</li>
<li> .decl MethodTotalVPT(?method:Method, Y:number)</li>
<li> .decl MethodTotalVPT(?method:Method, Y:number)</li>
<li> .decl Method_NumberOfContexts(?method:Method, ?n:number)</li>
<li> .decl Method_NumberOfContexts(?method:Method, ?n:number)</li>
<li> .decl SensitivityViolation(?method:Method)</li>
<li> .decl SpecialContextMethod(?method:Method)</li>
<li> .decl StickyContextMethod(?method:Method)</li>
<li> .decl VPTCountPerMethodVariable(?method:Method, ?var:Var, ?n:number)</li>
<li> .decl VPTCountPerMethodVariable(?method:Method, ?var:Var, ?n:number)</li>
</ul>
<h2> analyses/context-insensitive-plus/analysis.dl </h2>
<ul>
<li> .decl UContext(?ctx:UniqueContext)</li>
<li> .decl UHContext(?hctx:HContext)</li>
<li> .decl _InOutFlowMethod(?method:Method)</li>
</ul>
<h2> analyses/context-insensitive-plusplus/analysis.dl </h2>
<ul>
<li> .decl UContext(?ctx:UniqueContext)</li>
<li> .decl UHContext(?hctx:UniqueHContext)</li>
</ul>
<h2> analyses/data-flow/analysis.dl </h2>
<ul>
<li> .decl Flows(x:Var, y:Var)</li>
<li> .decl FlowsIntoConstArrayIndex(x:Var, arr:Var, index:number)</li>
<li> .decl FlowsIntoInstanceFieldBase(x:Var, base:Var)</li>
<li> .decl FlowsIntoStaticField(x:Var, fld:Field)</li>
<li> .decl Flows_EXT(x:Var, y:Var)</li>
<li> .decl OptBaseFlows(x:Var, y:Var)</li>
<li> .decl OptMethodRetFormal(m:Method, nth:number)</li>
<li> .decl PointerFlows(x:Var, y:Var)</li>
<li> .decl ResolveCall(stmt: MethodInvocation, method: Method)</li>
<li> .decl SelfFlows(x:Var)</li>
</ul>
<h2> analyses/data-flow/setup.dl </h2>
<ul>
<li> .decl ACTUAL_PARAM(stmt: MethodInvocation, pos: number, param: Var)</li>
<li> .decl ACTUAL_RET(stmt: MethodInvocation, to: Var)</li>
<li> .decl ALLOC(stmt: AssignHeapAllocation_Insn, to: Var, h: HeapAllocation)</li>
<li> .decl ALOAD(stmt: LoadArrayIndex_Insn, to: Var, arr: Var)</li>
<li> .decl ALOAD_NUM(stmt: LoadArrayIndex_Insn, to: Var, arr: Var, i: number)</li>
<li> .decl ALOAD_VAR(stmt: LoadArrayIndex_Insn, to: Var, arr: Var, i: Var)</li>
<li> .decl ASTORE(stmt: StoreArrayIndex_Insn, arr: Var, from: Var)</li>
<li> .decl ASTORE_NUM(stmt: StoreArrayIndex_Insn, arr: Var, i: number, from: Var)</li>
<li> .decl ASTORE_VAR(stmt: StoreArrayIndex_Insn, arr: Var, i: Var, from: Var)</li>
<li> .decl AllocArray(stmt: AssignHeapAllocation_Insn, arr: Var, types: Type)</li>
<li> .decl AllocArraySize_NUM(stmt: Instruction, pos: number, size: number)</li>
<li> .decl AllocArraySize_VAR(stmt: Instruction, pos: number, sizeVar: Var)</li>
<li> .decl BINOP(stmt: AssignBinop_Insn, to: Var, op: symbol)</li>
<li> .decl CAST(stmt: AssignCast_Insn, to: Var, type: Type, from: Var)</li>
<li> .decl FORMAL_PARAM(m: Method, pos: number, param: Var)</li>
<li> .decl FORMAL_RET(stmt: ReturnNonvoid_Insn, ret: Var)</li>
<li> .decl GOTO(stmt: Goto_Insn, label: number)</li>
<li> .decl IF(stmt: If_Insn, op: symbol, label: number)</li>
<li> .decl ILOAD(stmt: LoadInstanceField_Insn, to: Var, base: Var, fld: Field)</li>
<li> .decl INIT_VAR(stmt: AssignNumConstant_Insn, to: Var, value: NumConstant)</li>
<li> .decl ISTORE(stmt: StoreInstanceField_Insn, base: Var, fld: Field, from: Var)</li>
<li> .decl InterestingMethod(method: Method)</li>
<li> .decl InterestingStmt(stmt: Instruction)</li>
<li> .decl MOVE(stmt: AssignLocal_Insn, to: Var, from: Var)</li>
<li> .decl OPERAND_NUM(stmt: Instruction, pos: number, oper: number)</li>
<li> .decl OPERAND_VAR(stmt: Instruction, pos: number, oper: Var)</li>
<li> .decl RET(stmt: ReturnInstruction)</li>
<li> .decl SCALL(stmt: StaticMethodInvocation_Insn, m: Method)</li>
<li> .decl SLOAD(stmt: LoadStaticField_Insn, to: Var, fld: Field)</li>
<li> .decl SPCALL(stmt: SpecialMethodInvocation_Insn, base: Var, m: Method)</li>
<li> .decl SSTORE(stmt: StoreStaticField_Insn, fld: Field, from: Var)</li>
<li> .decl UNOP(stmt: AssignUnop_Insn, to: Var, op: symbol)</li>
<li> .decl VCALL(stmt: VirtualMethodInvocation_Insn, base: Var, m: Method)</li>
<li> .decl __Operand_ValidStr(stmt: Instruction, pos: number, oper: symbol)</li>
<li> .decl __OperatorAt(stmt: Instruction, op: symbol)</li>
</ul>
<h2> analyses/dependency-analysis/declarations.dl </h2>
<ul>
<li> .decl AllCtxDependentStoreHeapFld(?fld: Field, ?hctx: mainAnalysis.configuration.HContext, ?value: Value)</li>
<li> .decl CFGLeaf(?headInsn: Instruction, ?method: Method)</li>
<li> .decl CallReturnDependency(?nextCtx: mainAnalysis.configuration.Context, ?next: Instruction, ?prevCtx: mainAnalysis.configuration.Context, ?prev: Instruction)</li>
<li> .decl DependencySourceInstruction(?insn: Instruction)</li>
<li> .decl DependentInstruction(?ctx: mainAnalysis.configuration.Context, ?insn: Instruction)</li>
<li> .decl DoesNotPostDominate(?postDomCandidate: Instruction, ?insn: Instruction)</li>
<li> .decl InstructionDefinesVar(?instruction: Instruction, ?var: Var)</li>
<li> .decl InstructionUsesVar(?instruction: Instruction, ?var: Var)</li>
<li> .decl IntraProceduralBlockControlDep(?nextBlock: Instruction, ?prev: Instruction)</li>
<li> .decl IntraProceduralControlDep(?next: Instruction, ?prev: Instruction)</li>
<li> .decl IntraProceduralDataDep(?next: Instruction, ?prev: Instruction)</li>
<li> .decl IntraProceduralDependency(?prev: Instruction, ?next: Instruction)</li>
<li> .decl IntraProceduralDependencyBase(?next: Instruction, ?prev: Instruction)</li>
<li> .decl LoadArrayHeapInsn(?ctx: mainAnalysis.configuration.Context, ?insn: Instruction, ?hctx: mainAnalysis.configuration.HContext, ?value: Value)</li>
<li> .decl LoadFldFrom(?insn: Instruction, ?base: Var, ?fld: Field)</li>
<li> .decl PostDominates(?dominator: Instruction, ?insn: Instruction)</li>
<li> .decl SecureInstruction(?insn: Instruction)</li>
<li> .decl SecureMethod(?meth: Method)</li>
<li> .decl StoreFldTo(?base: Var, ?fld: Field, ?insn: Instruction)</li>
<li> .decl TaintedLoad(?ctx: mainAnalysis.configuration.Context, ?insn: Instruction)</li>
</ul>
<h2> analyses/dependency-context/2objH-micro.dl </h2>
<ul>
<li> .decl ActualParam(?index:number, ?invocation:MethodInvocation, ?var:Var)</li>
<li> .decl ApplicationClass(?ref:ReferenceType)</li>
<li> .decl ArgValuesUpToActual(?callerCtx:Context, ?invocation:MethodInvocation, ?calleeCtx:Context, ?tomethod:Method, ?i:number)</li>
<li> .decl Assign(?toCtx:Context, ?to:Var, ?fromCtx:Context, ?from:Var)</li>
<li> .decl AssignCast(?type:Type, ?from:Var, ?to:Var, ?inmethod:Method)</li>
<li> .decl AssignCast_From(?insn:AssignCast_Insn, ?from:Var)</li>
<li> .decl AssignCast_Type(?insn:AssignCast_Insn, ?type:Type)</li>
<li> .decl AssignHeapAllocation(?heap:HeapAllocation, ?to:Var, ?inmethod:Method)</li>
<li> .decl AssignHeapAllocation_Heap(?insn:AssignHeapAllocation_Insn, ?heap:HeapAllocation)</li>
<li> .decl AssignInstruction_To(?insn:AssignInstruction, ?to:Var)</li>
<li> .decl AssignLocal(?from:Var, ?to:Var, ?inmethod:Method)</li>
<li> .decl AssignLocal_From(?insn:AssignLocal_Insn, ?from:Var)</li>
<li> .decl AssignReturnValue(?invocation:MethodInvocation, ?to:Var)</li>
<li> .decl CallGraphEdge(?callerCtx:Context, ?invocation:MethodInvocation, ?calleeCtx:Context, ?meth:Method)</li>
<li> .decl ClassInitializer(?type:Type, ?method:Method)</li>
<li> .decl ComponentType(?arrayType:ArrayType, ?componentType:Type)</li>
<li> .decl DirectSubclass(?a:Type, ?c:Type)</li>
<li> .decl DirectSuperclass(?class:ClassType, ?superclass:ClassType)</li>
<li> .decl DirectSuperinterface(?ref:ReferenceType, ?interface:InterfaceType)</li>
<li> .decl EmptyContext(?ctx:Context)</li>
<li> .decl EmptyHContext(?hctx:HeapAllocation)</li>
<li> .decl FieldInstruction_Signature(?insn:FieldInstruction, ?sign:Field)</li>
<li> .decl Field_DeclaringType(?field:Field, ?declaringClass:ReferenceType)</li>
<li> .decl FormalParam(?index:number, ?method:Method, ?var:Var)</li>
<li> .decl HeapAllocation_Type(?heap:HeapAllocation, ?type:Type)</li>
<li> .decl InitializedClass(?classOrInterface:Type)</li>
<li> .decl InsensCallGraphEdge(?invo:MethodInvocation, ?tomethod:Method)</li>
<li> .decl InsensVPT(?var:Var, ?heap:HeapAllocation)</li>
<li> .decl InstanceFieldPointsTo(?hctx:HContext, ?heap:HeapAllocation , ?fld:Field, ?baseHCtx:HContext, ?baseheap:HeapAllocation)</li>
<li> .decl Instruction_Method(?insn:Instruction, ?inMethod:Method)</li>
<li> .decl LoadArrayIndex(?base:Var, ?to:Var, ?inmethod:Method)</li>
<li> .decl LoadArrayIndex_Base(?insn:LoadArrayIndex_Insn, ?var:Var)</li>
<li> .decl LoadArrayIndex_To(?insn:LoadArrayIndex_Insn, var:Var)</li>
<li> .decl LoadInstanceField(?base:Var, ?sig:Field, ?to:Var, ?inmethod:Method)</li>
<li> .decl LoadInstanceField_Base(?insn:LoadInstanceField_Insn, ?var:Var)</li>
<li> .decl LoadInstanceField_To(?insn:LoadInstanceField_Insn, ?var:Var)</li>
<li> .decl LoadStaticField(?sig:Field, ?to:Var, ?inmethod:Method)</li>
<li> .decl LoadStaticField_To(?insn:LoadStaticField_Insn, ?var:Var)</li>
<li> .decl MainClass(?class:ClassType)</li>
<li> .decl MainMethodArgArray(?heap:HeapAllocation)</li>
<li> .decl MainMethodArgArrayContent(?heap:HeapAllocation)</li>
<li> .decl MainMethodDeclaration(?method:Method)</li>
<li> .decl MethodImplemented(?simplename:symbol, ?descriptor:MethodDescriptor, ?type:Type, ?method:Method)</li>
<li> .decl MethodInvocation_Base(?invocation:MethodInvocation, ?base:Var)</li>
<li> .decl MethodInvocation_Method(?invocation:MethodInvocation, ?signature:Method)</li>
<li> .decl MethodLookup(?simplename:symbol, ?descriptor:MethodDescriptor, ?type:Type, ?method:Method)</li>
<li> .decl Method_DeclaringType(?method:Method, ?declaringType:ReferenceType)</li>
<li> .decl Method_Descriptor(?method:Method, ?descriptor:MethodDescriptor)</li>
<li> .decl Method_Modifier(?mod:Modifier, ?method:Method)</li>
<li> .decl Method_ParamTypes(?method:Method, ?params:symbol)</li>
<li> .decl Method_ReturnType(?method:Method, ?returnType:Type)</li>
<li> .decl Method_SimpleName(?method:Method, ?simpleName:symbol)</li>
<li> .decl NextActualParam(?invocation:MethodInvocation, ?i:number, ?next:Var)</li>
<li> .decl Reachable(?method:Method)</li>
<li> .decl ReachableContext(?ctx:Context, ?method:Method)</li>
<li> .decl ReturnNonvoid_Var(?return:ReturnNonvoid_Insn, ?var:Var)</li>
<li> .decl ReturnVar(?var:Var, ?method:Method)</li>
<li> .decl SpecialMethodInvocation_Base(?invocation:MethodInvocation, ?base:Var)</li>
<li> .decl StaticFieldPointsTo(?hctx:HContext, ?heap:HeapAllocation, ?fld:Field)</li>
<li> .decl StaticMethodInvocation(?invocation:MethodInvocation, ?signature:Method, ?inmethod:Method)</li>
<li> .decl StoreArrayIndex(?from:Var, ?base:Var, ?inmethod:Method)</li>
<li> .decl StoreArrayIndex_Base(?insn:StoreArrayIndex_Insn, ?var:Var)</li>
<li> .decl StoreArrayIndex_From(?insn:StoreArrayIndex_Insn, ?var:Var)</li>
<li> .decl StoreInstanceField(?from:Var, ?base:Var, ?signature:Field, ?inmethod:Method)</li>
<li> .decl StoreInstanceField_Base(?insn:StoreInstanceField_Insn, ?var:Var)</li>
<li> .decl StoreInstanceField_From(?insn:StoreInstanceField_Insn, ?var:Var)</li>
<li> .decl StoreStaticField(?from:Var, ?signature:Field, ?inmethod:Method)</li>
<li> .decl StoreStaticField_From(?insn:StoreStaticField_Insn, ?var:Var)</li>
<li> .decl Subclass(?c:Type, ?a:Type)</li>
<li> .decl SubtypeOf(?subtype:Type, ?type:Type)</li>
<li> .decl SubtypeOfDifferent(?subtype:Type, ?type:Type)</li>
<li> .decl Superclass(?c:Type, ?a:Type)</li>
<li> .decl Superinterface(?k:Type, ?c:Type)</li>
<li> .decl SupertypeOf(?supertype:Type, ?type:Type)</li>
<li> .decl TentativeCallGraphEdge(?callerCtx:Context, ?invocation:MethodInvocation, ?calleeCtx:Context, ?meth:Method)</li>
<li> .decl ThisVar(?method:Method, ?var:Var)</li>
<li> .decl VarOfReferenceType(?var:Var)</li>
<li> .decl VarPointsTo(?hctx:HContext, ?heap:HeapAllocation, ?ctx:Context, ?var:Var)</li>
<li> .decl Var_DeclaringMethod(?var:Var, ?method:Method)</li>
<li> .decl Var_Type(?var:Var, ?type:Type)</li>
<li> .decl VirtualMethodInvocation_Base(?invocation:VirtualMethodInvocation_Insn, ?base:Var)</li>
<li> .decl VirtualMethodInvocation_Descriptor(?invocation:MethodInvocation, ?descriptor:MethodDescriptor)</li>
<li> .decl VirtualMethodInvocation_SimpleName(?invocation:MethodInvocation, ?simplename:symbol)</li>
<li> .decl _ApplicationClass(?type:symbol)</li>
<li> .decl _ArrayType(?arrayType:symbol)</li>
<li> .decl _AssignCast(?instruction:symbol, ?index:number, ?from:symbol, ?to:symbol, ?type:symbol, ?inmethod:symbol)</li>
<li> .decl _AssignHeapAllocation(?instruction:symbol, ?index:number, ?heap:symbol, ?to:symbol, ?inmethod:symbol, ?linenumber:number)</li>
<li> .decl _AssignLocal(?instruction:symbol, ?index:number, ?from:symbol, ?to:symbol, ?inmethod:symbol)</li>
<li> .decl _ClassType(?class:symbol)</li>
<li> .decl _Field(?signature:symbol, ?declaringClass:symbol, ?simplename:symbol, ?type:symbol)</li>
<li> .decl _InterfaceType(?interface:symbol)</li>
<li> .decl _LoadArrayIndex(?instruction:symbol, ?index:number, ?to:symbol, ?base:symbol, ?method:symbol)</li>
<li> .decl _LoadInstanceField(?instruction:symbol, ?index:number, ?to:symbol, ?base:symbol, ?signature:symbol, ?method:symbol)</li>
<li> .decl _LoadStaticField(?instruction:symbol, ?index:number, ?to:symbol, ?signature:symbol, ?method:symbol)</li>
<li> .decl _Method(?method:symbol, ?simplename:symbol, ?descriptor:symbol, ?declaringType:symbol, ?returnType:symbol, ?jvmDescriptor:symbol, ?arity:number)</li>
<li> .decl _NormalHeap(?id:symbol, ?type:symbol)</li>
<li> .decl _Return(?instruction:symbol, ?index:number, ?var:symbol, ?method:symbol)</li>
<li> .decl _SpecialMethodInvocation(?instruction:symbol, ?index:number, ?signature:symbol, ?base:symbol, ?method:symbol)</li>
<li> .decl _StaticMethodInvocation(?instruction:symbol, ?index:number, ?signature:symbol, ?method:symbol)</li>
<li> .decl _StoreArrayIndex(?instruction:symbol, ?index:number, ?from:symbol, ?base:symbol, ?method:symbol)</li>
<li> .decl _StoreInstanceField(?instruction:symbol, ?index:number, ?from:symbol, ?base:symbol, ?signature:symbol, ?method:symbol)</li>
<li> .decl _StoreStaticField(?instruction:symbol, ?index:number, ?from:symbol, ?signature:symbol, ?method:symbol)</li>
<li> .decl _StringConstant(?id:symbol)</li>
<li> .decl _ThisVar(?method:symbol, ?var:symbol)</li>
<li> .decl _Var_DeclaringMethod(?var:symbol, ?method:symbol)</li>
<li> .decl _VirtualMethodInvocation(?instruction:symbol, ?index:number, ?signature:symbol, ?base:symbol, ?method:symbol)</li>
<li> .decl isArrayType(?t:ArrayType)</li>
<li> .decl isClassType(?t:ClassType)</li>
<li> .decl isInterfaceType(?t:InterfaceType)</li>
<li> .decl isReferenceType(?t:ReferenceType)</li>
<li> .decl isStaticMethodInvocation_Insn(?insn:StaticMethodInvocation_Insn)</li>
<li> .decl isType(?t:Type)</li>
<li> .decl isVirtualMethodInvocation_Insn(?insn:VirtualMethodInvocation_Insn)</li>
</ul>
<h2> analyses/dependency-context/deco.dl </h2>
<ul>
<li> .decl ActualParam(?index:number, ?invocation:MethodInvocation, ?var:Var)</li>
<li> .decl ApplicationClass(?ref:ReferenceType)</li>
<li> .decl AssignCast(?type:Type, ?from:Var, ?to:Var, ?inmethod:Method)</li>
<li> .decl AssignCast_From(?insn:AssignCast_Insn, ?from:Var)</li>
<li> .decl AssignCast_Type(?insn:AssignCast_Insn, ?type:Type)</li>
<li> .decl AssignHeapAllocation(?heap:HeapAllocation, ?to:Var, ?inmethod:Method)</li>
<li> .decl AssignHeapAllocation_Heap(?insn:AssignHeapAllocation_Insn, ?heap:HeapAllocation)</li>
<li> .decl AssignInstruction_To(?insn:AssignInstruction, ?to:Var)</li>
<li> .decl AssignLocal(?from:Var, ?to:Var, ?inmethod:Method)</li>
<li> .decl AssignLocal_From(?insn:AssignLocal_Insn, ?from:Var)</li>
<li> .decl AssignReturnValue(?invocation:MethodInvocation, ?to:Var)</li>
<li> .decl AuxDependenciesUpToArgWithNext(caller:MethodInvocation, tomethod:Method, argNext:IndexedArg, callerLDeps:Dependencies, calleeLDeps:Dependencies, globalDeps:Dependencies)</li>
<li> .decl AuxLoadPointsTo(baseheap:HeapAllocation, fld:Field, to:Var, apText:symbol, lDeps:Dependencies, gDeps:Dependencies)</li>
<li> .decl AuxLocalDependenciesForArgEquivalenceClass(caller:MethodInvocation, method:Method, argRepr:IndexedArg, calleeLDeps:Dependencies)</li>
<li> .decl AuxPointsToOfActualWithFormal(caller:MethodInvocation, method:Method, arg:IndexedArg, obj:HeapAllocation, deltaCallerLDeps:Dependencies, deltaGlobalDeps:Dependencies, formal:Var)</li>
<li> .decl AuxPointsToRelationshipToTest(caller:MethodInvocation, method:Method, argRepr:IndexedArg, formal:Var)</li>
<li> .decl AuxStoredObjectIntoField(heap:HeapAllocation, fld:Field, base:Var, fLDeps:Dependencies, fGDeps:Dependencies)</li>
<li> .decl CallGraphEdge(invocation:MethodInvocation, meth:Method)</li>
<li> .decl ClassInitializer(type:Type, method:Method)</li>
<li> .decl ComponentType(?arrayType:ArrayType, ?componentType:Type)</li>
<li> .decl DecomposeIndexedArg(caller:MethodInvocation, arg:IndexedArg, var:Var, i:number)</li>
<li> .decl DependenciesExistUpToArgEquivalenceClass(caller:MethodInvocation, tomethod:Method, argRepr:IndexedArg)</li>
<li> .decl DependenciesForAllArgEquivalenceClasses(caller:MethodInvocation, tomethod:Method)</li>
<li> .decl DependenciesForArgEquivalenceClass(caller:MethodInvocation, tomethod:Method, argRepr:IndexedArg, callerLDeps:Dependencies, calleeLDeps:Dependencies, globalDeps:Dependencies)</li>
<li> .decl DependenciesForArgEquivalenceClassUpToArg(caller:MethodInvocation, tomethod:Method, arg:IndexedArg, callerLDeps:Dependencies, calleeLDeps:Dependencies, globalDeps:Dependencies)</li>
<li> .decl DependentVars(var1:Var, var2:Var)</li>
<li> .decl DirectSubclass(?a:Type, ?c:Type)</li>
<li> .decl DirectSuperclass(?class:ClassType, ?superclass:ClassType)</li>
<li> .decl DirectSuperinterface(?ref:ReferenceType, ?interface:InterfaceType)</li>
<li> .decl EmptyDependencies(dep: number)</li>
<li> .decl FieldInstruction_Signature(?insn:FieldInstruction, ?sign:Field)</li>
<li> .decl Field_DeclaringType(?field:Field, ?declaringClass:ReferenceType)</li>
<li> .decl FieldsOfSameClass(field1:Field, field2:Field)</li>
<li> .decl FirstActualArgEquivalenceClass(caller:MethodInvocation, method:Method, argRepr:IndexedArg)</li>
<li> .decl FirstActualArgInArgEquivalenceClass(caller:MethodInvocation, method:Method, arg:IndexedArg)</li>
<li> .decl FirstArgEquivalenceClass(argRepr:Var)</li>
<li> .decl FirstArgInArgEquivalenceClass(arg:Var)</li>
<li> .decl FormalParam(?index:number, ?method:Method, ?var:Var)</li>
<li> .decl FormalReturnVPT(method:Method, obj:HeapAllocation, lDeps:Dependencies, gDeps:Dependencies)</li>
<li> .decl HeapAllocation_Type(?heap:HeapAllocation, ?type:Type)</li>
<li> .decl IndexToActual(method:MethodInvocation, i:number, actual:Var)</li>
<li> .decl InitDependentVars(arg1:Var, arg2:Var)</li>
<li> .decl InitializedClass(classOrInterface:Type)</li>
<li> .decl InsensVarPointsTo(var:Var, heap:HeapAllocation)</li>
<li> .decl InstanceFieldPointsTo(baseObj:HeapAllocation, fld:Field, obj:HeapAllocation, globalDeps:Dependencies)</li>
<li> .decl Instruction_Method(?insn:Instruction, ?inMethod:Method)</li>
<li> .decl LastActualArgEquivalenceClass(caller:MethodInvocation, method:Method, argRepr:IndexedArg)</li>
<li> .decl LastActualArgInArgEquivalenceClass(caller:MethodInvocation, method:Method, arg:IndexedArg)</li>
<li> .decl LastArgEquivalenceClass(argRepr:Var)</li>
<li> .decl LastArgInArgEquivalenceClass(arg:Var)</li>
<li> .decl LaterActualArgEquivalenceClass(caller:MethodInvocation, method:Method, argRepr:IndexedArg, argReprLater:IndexedArg)</li>
<li> .decl LaterArgEquivalenceClass(argRepr:Var, argReprLater:Var)</li>
<li> .decl LaterArgInArgEquivalenceClass(arg:Var, argLater:Var)</li>
<li> .decl LaterArgInSameMethod(arg:Var, argLater:Var)</li>
<li> .decl LoadArrayIndex_Base(?insn:LoadArrayIndex_Insn, ?var:Var)</li>
<li> .decl LoadArrayIndex_To(?insn:LoadArrayIndex_Insn, var:Var)</li>
<li> .decl LoadInstanceField(?base:Var, ?sig:Field, ?to:Var, ?inmethod:Method)</li>
<li> .decl LoadInstanceField_Base(?insn:LoadInstanceField_Insn, ?var:Var)</li>
<li> .decl LoadInstanceField_To(?insn:LoadInstanceField_Insn, ?var:Var)</li>
<li> .decl LoadStaticField(?sig:Field, ?to:Var, ?inmethod:Method)</li>
<li> .decl LoadStaticField_To(?insn:LoadStaticField_Insn, ?var:Var)</li>
<li> .decl MainClass(?class:ClassType)</li>
<li> .decl MainMethodArgArray(?heap:HeapAllocation)</li>
<li> .decl MainMethodArgArrayContent(?heap:HeapAllocation)</li>
<li> .decl MainMethodDeclaration(?method:Method)</li>
<li> .decl MapActualToFormal(caller:MethodInvocation, actual:IndexedArg, method:Method, formal:Var)</li>
<li> .decl MethodHasReferenceParameters(method:Method)</li>
<li> .decl MethodImplemented(?simplename:symbol, ?descriptor:MethodDescriptor, ?type:Type, ?method:Method)</li>
<li> .decl MethodInvocation_Base(?invocation:MethodInvocation, ?base:Var)</li>
<li> .decl MethodInvocation_Method(?invocation:MethodInvocation, ?signature:Method)</li>
<li> .decl MethodLookup(?simplename:symbol, ?descriptor:MethodDescriptor, ?type:Type, ?method:Method)</li>
<li> .decl Method_DeclaringType(?method:Method, ?declaringType:ReferenceType)</li>
<li> .decl Method_Descriptor(?method:Method, ?descriptor:MethodDescriptor)</li>
<li> .decl Method_Modifier(?mod:Modifier, ?method:Method)</li>
<li> .decl Method_ParamTypes(?method:Method, ?params:symbol)</li>
<li> .decl Method_ReturnType(?method:Method, ?returnType:Type)</li>
<li> .decl Method_SimpleName(?method:Method, ?simpleName:symbol)</li>
<li> .decl NextActualArgEquivalenceClass(caller:MethodInvocation, method:Method, argRepr:IndexedArg, argReprLater:IndexedArg)</li>
<li> .decl NextActualArgInArgEquivalenceClass(caller:MethodInvocation, method:Method, arg:IndexedArg, argNext:IndexedArg)</li>
<li> .decl NextArgEquivalenceClass(argRepr:Var, argReprLater:Var)</li>
<li> .decl NextArgInArgEquivalenceClass(arg:Var, argNext:Var)</li>
<li> .decl NoReferencesPassedToCall(caller:MethodInvocation)</li>
<li> .decl NotNextArgEquivalenceClass(argRepr:Var, argReprLater:Var)</li>
<li> .decl NotNextArgInArgEquivalenceClass(arg:Var, argLater:Var)</li>
<li> .decl Object_Allocation(obj:symbol, heap:HeapAllocation)</li>
<li> .decl OneOfMultipleRelatedLoads(to:Var)</li>
<li> .decl PrevArgInArgEquivalenceClass(arg:Var, argPrev:Var)</li>
<li> .decl Reachable(meth:Method)</li>
<li> .decl RepresentativeOfActualArgInArgEquivalenceClass(caller:MethodInvocation, method:Method, arg:IndexedArg, argRepr:IndexedArg)</li>
<li> .decl RepresentativeOfArgInArgEquivalenceClass(arg:Var, argRepr:Var)</li>
<li> .decl ReturnNonvoid_Var(?return:ReturnNonvoid_Insn, ?var:Var)</li>
<li> .decl ReturnVar(?var:Var, ?method:Method)</li>
<li> .decl SpecialMethodInvocation_Base(?invocation:MethodInvocation, ?base:Var)</li>
<li> .decl StaticFieldPointsTo(fld:Field, heap:HeapAllocation, globalDeps:Dependencies)</li>
<li> .decl StaticMethodInvocation(?invocation:MethodInvocation, ?signature:Method, ?inmethod:Method)</li>
<li> .decl StoreArrayIndex_Base(?insn:StoreArrayIndex_Insn, ?var:Var)</li>
<li> .decl StoreArrayIndex_From(?insn:StoreArrayIndex_Insn, ?var:Var)</li>
<li> .decl StoreInstanceField(?from:Var, ?base:Var, ?signature:Field, ?inmethod:Method)</li>
<li> .decl StoreInstanceField_Base(?insn:StoreInstanceField_Insn, ?var:Var)</li>
<li> .decl StoreInstanceField_From(?insn:StoreInstanceField_Insn, ?var:Var)</li>
<li> .decl StoreStaticField(?from:Var, ?signature:Field, ?inmethod:Method)</li>
<li> .decl StoreStaticField_From(?insn:StoreStaticField_Insn, ?var:Var)</li>
<li> .decl Subclass(?c:Type, ?a:Type)</li>
<li> .decl SubtypeOf(?subtype:Type, ?type:Type)</li>
<li> .decl SubtypeOfDifferent(?subtype:Type, ?type:Type)</li>
<li> .decl Superclass(?c:Type, ?a:Type)</li>
<li> .decl Superinterface(?k:Type, ?c:Type)</li>
<li> .decl SupertypeOf(?supertype:Type, ?type:Type)</li>
<li> .decl TentativeCallGraphEdge(invocation:MethodInvocation, meth:Method)</li>
<li> .decl TentativeDependenciesForArgEquivalenceClass(caller:MethodInvocation, tomethod:Method, argRepr:IndexedArg, callerLDeps:Dependencies, calleeLDeps:Dependencies, globalDeps:Dependencies)</li>
<li> .decl TextDependenciesForArgEquivalenceClass(caller:MethodInvocation, tomethod:Method, argRepr:symbol, callerLDeps:symbol, calleeLDeps:symbol, globalDeps:symbol)</li>
<li> .decl TextDependenciesForArgEquivalenceClassUpToArg(caller:MethodInvocation, tomethod:Method, arg:symbol, callerLDeps:symbol, calleeLDeps:symbol, globalDeps:symbol)</li>
<li> .decl TextInstanceFieldPointsTo(baseObj:HeapAllocation, fld:Field, obj:HeapAllocation, textGlobalDeps:symbol)</li>
<li> .decl TextVarPointsTo(var:Var, heap:HeapAllocation, textLocalDeps:symbol, textGlobalDeps:symbol)</li>
<li> .decl ThisVar(?method:Method, ?var:Var)</li>
<li> .decl TriviallyCompatibleDependencies(deps1:Dependencies, deps2:Dependencies, resultDeps:Dependencies)</li>
<li> .decl TriviallyReachable(meth:Method)</li>
<li> .decl ValidReturnValue(caller:MethodInvocation, method:Method, callerLDeps:Dependencies, globalDeps:Dependencies, obj:HeapAllocation)</li>
<li> .decl VarDependsOnMethodArgument(var:Var, arg:Var)</li>
<li> .decl VarOfReferenceType(var:Var)</li>
<li> .decl VarPointsTo(var:Var, heap:HeapAllocation, localDeps:Dependencies, globalDeps:Dependencies)</li>
<li> .decl Var_DeclaringMethod(?var:Var, ?method:Method)</li>
<li> .decl Var_Type(?var:Var, ?type:Type)</li>
<li> .decl VarsInSameArgEquivalenceClass(var1:Var, var2:Var)</li>
<li> .decl VirtualMethodInvocation_Base(?invocation:VirtualMethodInvocation_Insn, ?base:Var)</li>
<li> .decl VirtualMethodInvocation_Descriptor(?invocation:MethodInvocation, ?descriptor:MethodDescriptor)</li>
<li> .decl VirtualMethodInvocation_SimpleName(?invocation:MethodInvocation, ?simplename:symbol)</li>
<li> .decl _ApplicationClass(?type:symbol)</li>
<li> .decl _ArrayType(?arrayType:symbol)</li>
<li> .decl _AssignCast(?instruction:symbol, ?index:number, ?from:symbol, ?to:symbol, ?type:symbol, ?inmethod:symbol)</li>
<li> .decl _AssignHeapAllocation(?instruction:symbol, ?index:number, ?heap:symbol, ?to:symbol, ?inmethod:symbol, ?linenumber:number)</li>
<li> .decl _AssignLocal(?instruction:symbol, ?index:number, ?from:symbol, ?to:symbol, ?inmethod:symbol)</li>
<li> .decl _ClassType(?class:symbol)</li>
<li> .decl _Field(?signature:symbol, ?declaringClass:symbol, ?simplename:symbol, ?type:symbol)</li>
<li> .decl _InterfaceType(?interface:symbol)</li>
<li> .decl _LoadArrayIndex(?instruction:symbol, ?index:number, ?to:symbol, ?base:symbol, ?method:symbol)</li>
<li> .decl _LoadInstanceField(?instruction:symbol, ?index:number, ?to:symbol, ?base:symbol, ?signature:symbol, ?method:symbol)</li>
<li> .decl _LoadStaticField(?instruction:symbol, ?index:number, ?to:symbol, ?signature:symbol, ?method:symbol)</li>
<li> .decl _Method(?method:symbol, ?simplename:symbol, ?descriptor:symbol, ?declaringType:symbol, ?returnType:symbol, ?jvmDescriptor:symbol, ?arity:number)</li>
<li> .decl _NormalHeap(?id:symbol, ?type:symbol)</li>
<li> .decl _Return(?instruction:symbol, ?index:number, ?var:symbol, ?method:symbol)</li>
<li> .decl _SpecialMethodInvocation(?instruction:symbol, ?index:number, ?signature:symbol, ?base:symbol, ?method:symbol)</li>
<li> .decl _StaticMethodInvocation(?instruction:symbol, ?index:number, ?signature:symbol, ?method:symbol)</li>
<li> .decl _StoreArrayIndex(?instruction:symbol, ?index:number, ?from:symbol, ?base:symbol, ?method:symbol)</li>
<li> .decl _StoreInstanceField(?instruction:symbol, ?index:number, ?from:symbol, ?base:symbol, ?signature:symbol, ?method:symbol)</li>
<li> .decl _StoreStaticField(?instruction:symbol, ?index:number, ?from:symbol, ?signature:symbol, ?method:symbol)</li>
<li> .decl _StringConstant(?id:symbol)</li>
<li> .decl _ThisVar(?method:symbol, ?var:symbol)</li>
<li> .decl _Var_DeclaringMethod(?var:symbol, ?method:symbol)</li>
<li> .decl _VirtualMethodInvocation(?instruction:symbol, ?index:number, ?signature:symbol, ?base:symbol, ?method:symbol)</li>
<li> .decl isArrayType(?t:ArrayType)</li>
<li> .decl isClassType(?t:ClassType)</li>
<li> .decl isInterfaceType(?t:InterfaceType)</li>
<li> .decl isReferenceType(?t:ReferenceType)</li>
<li> .decl isStaticMethodInvocation_Insn(?insn:StaticMethodInvocation_Insn)</li>
<li> .decl isType(?t:Type)</li>
<li> .decl isVirtualMethodInvocation_Insn(?insn:VirtualMethodInvocation_Insn)</li>
</ul>
<h2> analyses/dependency-context/self-contained.dl </h2>
<ul>
<li> .decl ActualParam(?index:number, ?invocation:MethodInvocation, ?var:Var)</li>
<li> .decl ApplicationClass(?ref:ReferenceType)</li>
<li> .decl ArrayIndexPointsTo(?baseheap:HeapAllocation, ?heap:HeapAllocation)</li>
<li> .decl Assign(?to:Var, ?from:Var)</li>
<li> .decl AssignCast(?type:Type, ?from:Var, ?to:Var, ?inmethod:Method)</li>
<li> .decl AssignCast_From(?insn:AssignCast_Insn, ?from:Var)</li>
<li> .decl AssignCast_Type(?insn:AssignCast_Insn, ?type:Type)</li>
<li> .decl AssignHeapAllocation(?heap:HeapAllocation, ?to:Var, ?inmethod:Method)</li>
<li> .decl AssignHeapAllocation_Heap(?insn:AssignHeapAllocation_Insn, ?heap:HeapAllocation)</li>
<li> .decl AssignInstruction_To(?insn:AssignInstruction, ?to:Var)</li>
<li> .decl AssignLocal(?from:Var, ?to:Var, ?inmethod:Method)</li>
<li> .decl AssignLocal_From(?insn:AssignLocal_Insn, ?from:Var)</li>
<li> .decl AssignReturnValue(?invocation:MethodInvocation, ?to:Var)</li>
<li> .decl CallGraphEdge(?invocation:MethodInvocation, ?meth:Method)</li>
<li> .decl ClassInitializer(?type:Type, ?method:Method)</li>
<li> .decl ComponentType(?arrayType:ArrayType, ?componentType:Type)</li>
<li> .decl DirectSubclass(?a:Type, ?c:Type)</li>
<li> .decl DirectSuperclass(?class:ClassType, ?superclass:ClassType)</li>
<li> .decl DirectSuperinterface(?ref:ReferenceType, ?interface:InterfaceType)</li>
<li> .decl FieldInstruction_Signature(?insn:FieldInstruction, ?sign:Field)</li>
<li> .decl Field_DeclaringType(?field:Field, ?declaringClass:ReferenceType)</li>
<li> .decl FormalParam(?index:number, ?method:Method, ?var:Var)</li>
<li> .decl HeapAllocation_Type(?heap:HeapAllocation, ?type:Type)</li>
<li> .decl InitializedClass(?classOrInterface:Type)</li>
<li> .decl InstanceFieldPointsTo(?heap:HeapAllocation , ?fld:Field, ?baseheap:HeapAllocation)</li>
<li> .decl Instruction_Method(?insn:Instruction, ?inMethod:Method)</li>
<li> .decl LoadArrayIndex(?base:Var, ?to:Var, ?inmethod:Method)</li>
<li> .decl LoadArrayIndex_Base(?insn:LoadArrayIndex_Insn, ?var:Var)</li>
<li> .decl LoadArrayIndex_To(?insn:LoadArrayIndex_Insn, var:Var)</li>
<li> .decl LoadInstanceField(?base:Var, ?sig:Field, ?to:Var, ?inmethod:Method)</li>
<li> .decl LoadInstanceField_Base(?insn:LoadInstanceField_Insn, ?var:Var)</li>
<li> .decl LoadInstanceField_To(?insn:LoadInstanceField_Insn, ?var:Var)</li>
<li> .decl LoadStaticField(?sig:Field, ?to:Var, ?inmethod:Method)</li>
<li> .decl LoadStaticField_To(?insn:LoadStaticField_Insn, ?var:Var)</li>
<li> .decl MainClass(?class:ClassType)</li>
<li> .decl MainMethodArgArray(?heap:HeapAllocation)</li>
<li> .decl MainMethodArgArrayContent(?heap:HeapAllocation)</li>
<li> .decl MainMethodDeclaration(?method:Method)</li>
<li> .decl MethodImplemented(?simplename:symbol, ?descriptor:MethodDescriptor, ?type:Type, ?method:Method)</li>
<li> .decl MethodInvocation_Base(?invocation:MethodInvocation, ?base:Var)</li>
<li> .decl MethodInvocation_Method(?invocation:MethodInvocation, ?signature:Method)</li>
<li> .decl MethodLookup(?simplename:symbol, ?descriptor:MethodDescriptor, ?type:Type, ?method:Method)</li>
<li> .decl Method_DeclaringType(?method:Method, ?declaringType:ReferenceType)</li>
<li> .decl Method_Descriptor(?method:Method, ?descriptor:MethodDescriptor)</li>
<li> .decl Method_Modifier(?mod:Modifier, ?method:Method)</li>
<li> .decl Method_ParamTypes(?method:Method, ?params:symbol)</li>
<li> .decl Method_ReturnType(?method:Method, ?returnType:Type)</li>
<li> .decl Method_SimpleName(?method:Method, ?simpleName:symbol)</li>
<li> .decl Reachable(?method:Method)</li>
<li> .decl ReturnNonvoid_Var(?return:ReturnNonvoid_Insn, ?var:Var)</li>
<li> .decl ReturnVar(?var:Var, ?method:Method)</li>
<li> .decl SpecialMethodInvocation_Base(?invocation:MethodInvocation, ?base:Var)</li>
<li> .decl StaticFieldPointsTo(?heap:HeapAllocation, ?fld:Field)</li>
<li> .decl StaticMethodInvocation(?invocation:MethodInvocation, ?signature:Method, ?inmethod:Method)</li>
<li> .decl StoreArrayIndex(?from:Var, ?base:Var, ?inmethod:Method)</li>
<li> .decl StoreArrayIndex_Base(?insn:StoreArrayIndex_Insn, ?var:Var)</li>
<li> .decl StoreArrayIndex_From(?insn:StoreArrayIndex_Insn, ?var:Var)</li>
<li> .decl StoreInstanceField(?from:Var, ?base:Var, ?signature:Field, ?inmethod:Method)</li>
<li> .decl StoreInstanceField_Base(?insn:StoreInstanceField_Insn, ?var:Var)</li>
<li> .decl StoreInstanceField_From(?insn:StoreInstanceField_Insn, ?var:Var)</li>
<li> .decl StoreStaticField(?from:Var, ?signature:Field, ?inmethod:Method)</li>
<li> .decl StoreStaticField_From(?insn:StoreStaticField_Insn, ?var:Var)</li>
<li> .decl Subclass(?c:Type, ?a:Type)</li>
<li> .decl SubtypeOf(?subtype:Type, ?type:Type)</li>
<li> .decl SubtypeOfDifferent(?subtype:Type, ?type:Type)</li>
<li> .decl Superclass(?c:Type, ?a:Type)</li>
<li> .decl Superinterface(?k:Type, ?c:Type)</li>
<li> .decl SupertypeOf(?supertype:Type, ?type:Type)</li>
<li> .decl ThisVar(?method:Method, ?var:Var)</li>
<li> .decl VarPointsTo(?heap:HeapAllocation, ?var:Var)</li>
<li> .decl Var_DeclaringMethod(?var:Var, ?method:Method)</li>
<li> .decl Var_Type(?var:Var, ?type:Type)</li>
<li> .decl VirtualMethodInvocation_Base(?invocation:VirtualMethodInvocation_Insn, ?base:Var)</li>
<li> .decl VirtualMethodInvocation_Descriptor(?invocation:MethodInvocation, ?descriptor:MethodDescriptor)</li>
<li> .decl VirtualMethodInvocation_SimpleName(?invocation:MethodInvocation, ?simplename:symbol)</li>
<li> .decl _ApplicationClass(?type:symbol)</li>
<li> .decl _ArrayType(?arrayType:symbol)</li>
<li> .decl _AssignCast(?instruction:symbol, ?index:number, ?from:symbol, ?to:symbol, ?type:symbol, ?inmethod:symbol)</li>
<li> .decl _AssignHeapAllocation(?instruction:symbol, ?index:number, ?heap:symbol, ?to:symbol, ?inmethod:symbol, ?linenumber:number)</li>
<li> .decl _AssignLocal(?instruction:symbol, ?index:number, ?from:symbol, ?to:symbol, ?inmethod:symbol)</li>
<li> .decl _ClassType(?class:symbol)</li>
<li> .decl _Field(?signature:symbol, ?declaringClass:symbol, ?simplename:symbol, ?type:symbol)</li>
<li> .decl _InterfaceType(?interface:symbol)</li>
<li> .decl _LoadArrayIndex(?instruction:symbol, ?index:number, ?to:symbol, ?base:symbol, ?method:symbol)</li>
<li> .decl _LoadInstanceField(?instruction:symbol, ?index:number, ?to:symbol, ?base:symbol, ?signature:symbol, ?method:symbol)</li>
<li> .decl _LoadStaticField(?instruction:symbol, ?index:number, ?to:symbol, ?signature:symbol, ?method:symbol)</li>
<li> .decl _Method(?method:symbol, ?simplename:symbol, ?descriptor:symbol, ?declaringType:symbol, ?returnType:symbol, ?jvmDescriptor:symbol, ?arity:number)</li>
<li> .decl _NormalHeap(?id:symbol, ?type:symbol)</li>
<li> .decl _Return(?instruction:symbol, ?index:number, ?var:symbol, ?method:symbol)</li>
<li> .decl _SpecialMethodInvocation(?instruction:symbol, ?index:number, ?signature:symbol, ?base:symbol, ?method:symbol)</li>
<li> .decl _StaticMethodInvocation(?instruction:symbol, ?index:number, ?signature:symbol, ?method:symbol)</li>
<li> .decl _StoreArrayIndex(?instruction:symbol, ?index:number, ?from:symbol, ?base:symbol, ?method:symbol)</li>
<li> .decl _StoreInstanceField(?instruction:symbol, ?index:number, ?from:symbol, ?base:symbol, ?signature:symbol, ?method:symbol)</li>
<li> .decl _StoreStaticField(?instruction:symbol, ?index:number, ?from:symbol, ?signature:symbol, ?method:symbol)</li>
<li> .decl _StringConstant(?id:symbol)</li>
<li> .decl _ThisVar(?method:symbol, ?var:symbol)</li>
<li> .decl _Var_DeclaringMethod(?var:symbol, ?method:symbol)</li>
<li> .decl _VirtualMethodInvocation(?instruction:symbol, ?index:number, ?signature:symbol, ?base:symbol, ?method:symbol)</li>
<li> .decl isArrayType(?t:ArrayType)</li>
<li> .decl isClassType(?t:ClassType)</li>
<li> .decl isInterfaceType(?t:InterfaceType)</li>
<li> .decl isReferenceType(?t:ReferenceType)</li>
<li> .decl isStaticMethodInvocation_Insn(?insn:StaticMethodInvocation_Insn)</li>
<li> .decl isType(?t:Type)</li>
<li> .decl isVirtualMethodInvocation_Insn(?insn:VirtualMethodInvocation_Insn)</li>
</ul>
<h2> analyses/fully-guided-context-sensitive/analysis.dl </h2>
<ul>
<li> .decl ContextInsensitiveMethod(?method:Method)</li>
<li> .decl HContextElement(elem:symbol)</li>
<li> .decl MethodContext(?method: Method, ?ctx1: ContextComponent, ?ctx2: ContextComponent)</li>
<li> .decl MethodCostPredictionViolation(?method:Method, ?predictedCost:number, ?actualCost:number)</li>
<li> .decl MethodTotalVPT(?method:Method, Y:number)</li>
<li> .decl Method_NumberOfContexts(?method:Method, ?n:number)</li>
<li> .decl NoSensitivityViolation(?method:Method)</li>
<li> .decl OneTypeMethod(?method:Method)</li>
<li> .decl SpecialContextElement(value:symbol)</li>
<li> .decl SpecialContextSensitivityMethod(?method:Method, ?sensivity:symbol, ?predictedWorstCaseContexts:number, ?predictedWorstCaseVPT:number)</li>
<li> .decl SpecialContextSensitivityMethodNotPresentViolation(?method:Method)</li>
<li> .decl ToTypeString(valueOrType:symbol, type:symbol)</li>
<li> .decl TwoObjectMethod(?method:Method)</li>
<li> .decl TwoTypeMethod(?method:Method)</li>
<li> .decl VPTCountPerMethodVariable(?method:Method, ?var:Var, ?n:number)</li>
</ul>
<h2> analyses/micro/analysis.dl </h2>
<ul>
<li> .decl ArrayIndexPointsTo(?baseheap:HeapAllocation, ?heap:HeapAllocation)</li>
<li> .decl Assign(?to:Var, ?from:Var)</li>
<li> .decl CallGraphEdge(?invocation:MethodInvocation, ?meth:Method)</li>
<li> .decl InstanceFieldPointsTo(?heap:HeapAllocation , ?fld:Field, ?baseheap:HeapAllocation)</li>
<li> .decl Reachable(?method:Method)</li>
<li> .decl StaticFieldPointsTo(?heap:HeapAllocation, ?fld:Field)</li>
<li> .decl VarPointsTo(?heap:HeapAllocation, ?var:Var)</li>
</ul>
<h2> analyses/micro/self-contained.dl </h2>
<ul>
<li> .decl ActualParam(?index:number, ?invocation:MethodInvocation, ?var:Var)</li>
<li> .decl ApplicationClass(?ref:ReferenceType)</li>
<li> .decl ArrayIndexPointsTo(?baseheap:HeapAllocation, ?heap:HeapAllocation)</li>
<li> .decl Assign(?to:Var, ?from:Var)</li>
<li> .decl AssignCast(?type:Type, ?from:Var, ?to:Var, ?inmethod:Method)</li>
<li> .decl AssignCast_From(?insn:AssignCast_Insn, ?from:Var)</li>
<li> .decl AssignCast_Type(?insn:AssignCast_Insn, ?type:Type)</li>
<li> .decl AssignHeapAllocation(?heap:HeapAllocation, ?to:Var, ?inmethod:Method)</li>
<li> .decl AssignHeapAllocation_Heap(?insn:AssignHeapAllocation_Insn, ?heap:HeapAllocation)</li>
<li> .decl AssignInstruction_To(?insn:AssignInstruction, ?to:Var)</li>
<li> .decl AssignLocal(?from:Var, ?to:Var, ?inmethod:Method)</li>
<li> .decl AssignLocal_From(?insn:AssignLocal_Insn, ?from:Var)</li>
<li> .decl AssignReturnValue(?invocation:MethodInvocation, ?to:Var)</li>
<li> .decl CallGraphEdge(?invocation:MethodInvocation, ?meth:Method)</li>
<li> .decl ClassInitializer(?type:Type, ?method:Method)</li>
<li> .decl ComponentType(?arrayType:ArrayType, ?componentType:Type)</li>
<li> .decl DirectSubclass(?a:Type, ?c:Type)</li>
<li> .decl DirectSuperclass(?class:ClassType, ?superclass:ClassType)</li>
<li> .decl DirectSuperinterface(?ref:ReferenceType, ?interface:InterfaceType)</li>
<li> .decl FieldInstruction_Signature(?insn:FieldInstruction, ?sign:Field)</li>
<li> .decl Field_DeclaringType(?field:Field, ?declaringClass:ReferenceType)</li>
<li> .decl FormalParam(?index:number, ?method:Method, ?var:Var)</li>
<li> .decl HeapAllocation_Type(?heap:HeapAllocation, ?type:Type)</li>
<li> .decl InitializedClass(?classOrInterface:Type)</li>
<li> .decl InstanceFieldPointsTo(?heap:HeapAllocation , ?fld:Field, ?baseheap:HeapAllocation)</li>
<li> .decl Instruction_Method(?insn:Instruction, ?inMethod:Method)</li>
<li> .decl LoadArrayIndex(?base:Var, ?to:Var, ?inmethod:Method)</li>
<li> .decl LoadArrayIndex_Base(?insn:LoadArrayIndex_Insn, ?var:Var)</li>
<li> .decl LoadArrayIndex_To(?insn:LoadArrayIndex_Insn, var:Var)</li>
<li> .decl LoadInstanceField(?base:Var, ?sig:Field, ?to:Var, ?inmethod:Method)</li>
<li> .decl LoadInstanceField_Base(?insn:LoadInstanceField_Insn, ?var:Var)</li>
<li> .decl LoadInstanceField_To(?insn:LoadInstanceField_Insn, ?var:Var)</li>
<li> .decl LoadStaticField(?sig:Field, ?to:Var, ?inmethod:Method)</li>
<li> .decl LoadStaticField_To(?insn:LoadStaticField_Insn, ?var:Var)</li>
<li> .decl MainClass(?class:ClassType)</li>
<li> .decl MainMethodArgArray(?heap:HeapAllocation)</li>
<li> .decl MainMethodArgArrayContent(?heap:HeapAllocation)</li>
<li> .decl MainMethodDeclaration(?method:Method)</li>
<li> .decl MethodImplemented(?simplename:symbol, ?descriptor:MethodDescriptor, ?type:Type, ?method:Method)</li>
<li> .decl MethodInvocation_Base(?invocation:MethodInvocation, ?base:Var)</li>
<li> .decl MethodInvocation_Method(?invocation:MethodInvocation, ?signature:Method)</li>
<li> .decl MethodLookup(?simplename:symbol, ?descriptor:MethodDescriptor, ?type:Type, ?method:Method)</li>
<li> .decl Method_DeclaringType(?method:Method, ?declaringType:ReferenceType)</li>
<li> .decl Method_Descriptor(?method:Method, ?descriptor:MethodDescriptor)</li>
<li> .decl Method_Modifier(?mod:Modifier, ?method:Method)</li>
<li> .decl Method_ParamTypes(?method:Method, ?params:symbol)</li>
<li> .decl Method_ReturnType(?method:Method, ?returnType:Type)</li>
<li> .decl Method_SimpleName(?method:Method, ?simpleName:symbol)</li>
<li> .decl Reachable(?method:Method)</li>
<li> .decl ReturnNonvoid_Var(?return:ReturnNonvoid_Insn, ?var:Var)</li>
<li> .decl ReturnVar(?var:Var, ?method:Method)</li>
<li> .decl SpecialMethodInvocation_Base(?invocation:MethodInvocation, ?base:Var)</li>
<li> .decl StaticFieldPointsTo(?heap:HeapAllocation, ?fld:Field)</li>
<li> .decl StaticMethodInvocation(?invocation:MethodInvocation, ?signature:Method, ?inmethod:Method)</li>
<li> .decl StoreArrayIndex(?from:Var, ?base:Var, ?inmethod:Method)</li>
<li> .decl StoreArrayIndex_Base(?insn:StoreArrayIndex_Insn, ?var:Var)</li>
<li> .decl StoreArrayIndex_From(?insn:StoreArrayIndex_Insn, ?var:Var)</li>
<li> .decl StoreInstanceField(?from:Var, ?base:Var, ?signature:Field, ?inmethod:Method)</li>
<li> .decl StoreInstanceField_Base(?insn:StoreInstanceField_Insn, ?var:Var)</li>
<li> .decl StoreInstanceField_From(?insn:StoreInstanceField_Insn, ?var:Var)</li>
<li> .decl StoreStaticField(?from:Var, ?signature:Field, ?inmethod:Method)</li>
<li> .decl StoreStaticField_From(?insn:StoreStaticField_Insn, ?var:Var)</li>
<li> .decl Subclass(?c:Type, ?a:Type)</li>
<li> .decl SubtypeOf(?subtype:Type, ?type:Type)</li>
<li> .decl SubtypeOfDifferent(?subtype:Type, ?type:Type)</li>
<li> .decl Superclass(?c:Type, ?a:Type)</li>
<li> .decl Superinterface(?k:Type, ?c:Type)</li>
<li> .decl SupertypeOf(?supertype:Type, ?type:Type)</li>
<li> .decl ThisVar(?method:Method, ?var:Var)</li>
<li> .decl VarPointsTo(?heap:HeapAllocation, ?var:Var)</li>
<li> .decl Var_DeclaringMethod(?var:Var, ?method:Method)</li>
<li> .decl Var_Type(?var:Var, ?type:Type)</li>
<li> .decl VirtualMethodInvocation_Base(?invocation:VirtualMethodInvocation_Insn, ?base:Var)</li>
<li> .decl VirtualMethodInvocation_Descriptor(?invocation:MethodInvocation, ?descriptor:MethodDescriptor)</li>
<li> .decl VirtualMethodInvocation_SimpleName(?invocation:MethodInvocation, ?simplename:symbol)</li>
<li> .decl _ApplicationClass(?type:symbol)</li>
<li> .decl _ArrayType(?arrayType:symbol)</li>
<li> .decl _AssignCast(?instruction:symbol, ?index:number, ?from:symbol, ?to:symbol, ?type:symbol, ?inmethod:symbol)</li>
<li> .decl _AssignHeapAllocation(?instruction:symbol, ?index:number, ?heap:symbol, ?to:symbol, ?inmethod:symbol, ?linenumber:number)</li>
<li> .decl _AssignLocal(?instruction:symbol, ?index:number, ?from:symbol, ?to:symbol, ?inmethod:symbol)</li>
<li> .decl _ClassType(?class:symbol)</li>
<li> .decl _Field(?signature:symbol, ?declaringClass:symbol, ?simplename:symbol, ?type:symbol)</li>
<li> .decl _InterfaceType(?interface:symbol)</li>
<li> .decl _LoadArrayIndex(?instruction:symbol, ?index:number, ?to:symbol, ?base:symbol, ?method:symbol)</li>
<li> .decl _LoadInstanceField(?instruction:symbol, ?index:number, ?to:symbol, ?base:symbol, ?signature:symbol, ?method:symbol)</li>
<li> .decl _LoadStaticField(?instruction:symbol, ?index:number, ?to:symbol, ?signature:symbol, ?method:symbol)</li>
<li> .decl _Method(?method:symbol, ?simplename:symbol, ?descriptor:symbol, ?declaringType:symbol, ?returnType:symbol, ?jvmDescriptor:symbol, ?arity:number)</li>
<li> .decl _NormalHeap(?id:symbol, ?type:symbol)</li>
<li> .decl _Return(?instruction:symbol, ?index:number, ?var:symbol, ?method:symbol)</li>
<li> .decl _SpecialMethodInvocation(?instruction:symbol, ?index:number, ?signature:symbol, ?base:symbol, ?method:symbol)</li>
<li> .decl _StaticMethodInvocation(?instruction:symbol, ?index:number, ?signature:symbol, ?method:symbol)</li>
<li> .decl _StoreArrayIndex(?instruction:symbol, ?index:number, ?from:symbol, ?base:symbol, ?method:symbol)</li>
<li> .decl _StoreInstanceField(?instruction:symbol, ?index:number, ?from:symbol, ?base:symbol, ?signature:symbol, ?method:symbol)</li>
<li> .decl _StoreStaticField(?instruction:symbol, ?index:number, ?from:symbol, ?signature:symbol, ?method:symbol)</li>
<li> .decl _StringConstant(?id:symbol)</li>
<li> .decl _ThisVar(?method:symbol, ?var:symbol)</li>
<li> .decl _Var_DeclaringMethod(?var:symbol, ?method:symbol)</li>
<li> .decl _VirtualMethodInvocation(?instruction:symbol, ?index:number, ?signature:symbol, ?base:symbol, ?method:symbol)</li>
<li> .decl isArrayType(?t:ArrayType)</li>
<li> .decl isClassType(?t:ClassType)</li>
<li> .decl isInterfaceType(?t:InterfaceType)</li>
<li> .decl isReferenceType(?t:ReferenceType)</li>
<li> .decl isStaticMethodInvocation_Insn(?insn:StaticMethodInvocation_Insn)</li>
<li> .decl isType(?t:Type)</li>
<li> .decl isVirtualMethodInvocation_Insn(?insn:VirtualMethodInvocation_Insn)</li>
</ul>
<h2> analyses/partitioned-2-object-sensitive+heap/analysis.dl </h2>
<ul>
<li> .decl InvocationInNoPartition(invo: MethodInvocation)</li>
<li> .decl InvocationInNonPrimaryPartition(invo: Instruction)</li>
<li> .decl InvocationInPrimaryPartition(invo: Instruction)</li>
<li> .decl MethodInNoPartition(method: Method)</li>
<li> .decl MethodInNonPrimaryPartition(method: Method)</li>
<li> .decl MethodInPrimaryPartition(method: Method)</li>
<li> .decl PartitionId(?partitionId: number)</li>
<li> .decl PartitionName(?partitionName: symbol)</li>
<li> .decl PrimaryPartitionId(?partitionId: number)</li>
<li> .decl PrimaryPartitionName(?partitionRepresentativeType: symbol)</li>
<li> .decl TypeInNoPartition(type: Type)</li>
<li> .decl TypeInNonPrimaryPartition(type: Type)</li>
<li> .decl TypeInPrimaryPartition(type: Type)</li>
<li> .decl TypeToPartitionId(?type: Type, ?id: number)</li>
<li> .decl TypeToPartitionName(?type: Type, ?partitionRepresentativeType: symbol)</li>
<li> .decl VarInNoPartition(var: Var)</li>
<li> .decl VarInNonPrimaryPartition(var: Var)</li>
<li> .decl VarInPrimaryPartition(var: Var)</li>
</ul>
<h2> analyses/partitioned-2-object-sensitive+heap/partitioning.dl </h2>
<ul>
<li> .decl CountOfTypesPerSCC(id: Partition, cnt: number)</li>
<li> .decl IdTypeOfGenericPartition(id: Partition)</li>
<li> .decl NumberOfRelevantTypes(cnt: number)</li>
<li> .decl PartitionedType(type: Type)</li>
<li> .decl TypeInGenericPartition(type: Type)</li>
<li> .decl TypeRefersToOther(typeFrom: Type, typeTo: Type)</li>
<li> .decl TypeToSCCId(type: Type, id: Partition)</li>
<li> .decl TypeTransitivelyRefersToOther(typeFrom: Type, typeTo: Type)</li>
<li> .decl TypesInSameSCC(type1: Type, type2: Type)</li>
</ul>
<h2> analyses/sound-may-point-to/analysis.dl </h2>
<ul>
<li> .decl AccessPathMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ap:AccessPath, ?ctx:MayContext, ?insn:Instruction)</li>
<li> .decl AccessPathMayPointToAtSomePredecessor(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ap:AccessPath, ?ctx:MayContext, ?insn:Instruction)</li>
<li> .decl AccessPathRebasedForCall(?newAp:AccessPath, ?ap:AccessPath, ?callerCtx:MayContext, ?invo:MethodInvocation)</li>
<li> .decl AccessPathRebasedForReturn(?callerAp:AccessPath, ?calleeAp:AccessPath, ?callerCtx:MayContext, ?invo:MethodInvocation)</li>
<li> .decl AccessPathRelevantToMethod(?ap:AccessPath, ?meth:Method)</li>
<li> .decl AccessPathShouldBeRebased(?ap:AccessPath, ?from:Var, ?to:Var)</li>
<li> .decl AccessPathUnaffectedByPredecessorBB(?ap:AccessPath, ?pred:Instruction)</li>
<li> .decl AccessPath_BaseVar(?ap:AccessPath, ?var:Var)</li>
<li> .decl AccessPath_ContainsField(?fld:Field, ?ap:AccessPath)</li>
<li> .decl AccessPath_ContainsStaticField(?ap:AccessPath, ?fld:Field)</li>
<li> .decl AccessPath_IsCollection(?ap:AccessPath)</li>
<li> .decl AccessPath_IsComposite(?ap:AccessPath)</li>
<li> .decl AccessPath_IsFinalStaticField(?ap:AccessPath)</li>
<li> .decl AccessPath_IsSimple(?ap:AccessPath)</li>
<li> .decl AccessPath_Length(?ap:AccessPath, ?len:number)</li>
<li> .decl AccessPath_MaxLength(?maxLen:number)</li>
<li> .decl AllCallee_ReturnAccessPathMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?calleeAp:AccessPath, ?calleeCtx:MayContext, ?meth:Method)</li>
<li> .decl AllCallee_ReturnMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?calleeCtx:MayContext, ?meth:Method)</li>
<li> .decl AllCtxIntraproceduralMustPointToInMethod(?hctx:MayHeapContext, ?heap:HeapAllocation, ?var:Var, ?method:Method)</li>
<li> .decl AllInstanceFieldStoresHasNoExternalSideEffects(?meth:Method)</li>
<li> .decl AllInstanceFieldStoresHasNoSideEffects(?meth:Method)</li>
<li> .decl AllInvocationsMethodHasNoExternalSideEffects(?ctx:MayContext, ?meth:Method)</li>
<li> .decl AllInvocationsMethodHasNoSideEffects(?ctx:MayContext, ?meth:Method)</li>
<li> .decl AllParamsCalleeHasNoExternalSideEffects(?callerCtx:MayContext, ?invocation:MethodInvocation, ?calleeCtx:MayContext, ?toMeth:Method)</li>
<li> .decl AllParamsCalleeHasNoSideEffects(?callerCtx:MayContext, ?invocation:MethodInvocation, ?calleeCtx:MayContext, ?toMeth:Method)</li>
<li> .decl AllRelevantPredecessors_HasAccessPathMayPointTo(?ap:AccessPath, ?ctx:MayContext, ?insn:Instruction)</li>
<li> .decl AllReturn_AccessPathMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ap:AccessPath, ?ctx:MayContext, ?m:Method)</li>
<li> .decl AllReturn_MayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ctx:MayContext, ?method:Method)</li>
<li> .decl AllReturn_SameRetVar(?method:Method, ?var:Var)</li>
<li> .decl AppAllCtxIntraproceduralMustPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?var:Var)</li>
<li> .decl AppAllCtxMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?var:Var)</li>
<li> .decl AppMainMethod(?mainMeth:Method)</li>
<li> .decl BBHeadIsFirstInstruction(?firstInsn:Instruction)</li>
<li> .decl BasicBlockContainsCall(?headInsn:Instruction)</li>
<li> .decl BasicBlockContainsUnresolvedCall(?headInsn:Instruction)</li>
<li> .decl BasicBlockMayAffectField(?fld:Field, ?headInsn:Instruction)</li>
<li> .decl Before_AccessPathMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ap:AccessPath, ?ctx:MayContext, ?insn:Instruction)</li>
<li> .decl CalleeFromSameCallsite(?calleeCtx:MayContext, ?meth1:Method, ?meth2:Method)</li>
<li> .decl CalleeHasUnresolvedInvocation(?ctx:MayContext, ?insn:Instruction)</li>
<li> .decl CalleeMayAssignField(?fld:Field, ?ctx:MayContext, ?insn:Instruction)</li>
<li> .decl ClinitMethodOfClass(?meth:Method, ?class:Type)</li>
<li> .decl CollectionStoreFromVarMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ctx:MayContext, ?insn:Instruction)</li>
<li> .decl ComputedAccessPath(?ap:AccessPath)</li>
<li> .decl ComputedContext(?ctx:MayContext)</li>
<li> .decl ComputedFieldList(?fldList:AccessPathSuffix)</li>
<li> .decl ConstructorOfClassOfField(?fld:Field, ?consMeth:Method)</li>
<li> .decl ConstructorOfClassOfFieldHasUnresolvedInvocation(?fld:Field)</li>
<li> .decl DoubleFieldAccessPath(?fld1:Field, ?fld2:Field, ?ap:AccessPath)</li>
<li> .decl EmptyHeapContext(?hctx:MayHeapContext)</li>
<li> .decl ExistsNextPredecessorToSameBB(?pred:Instruction, ?insn:Instruction)</li>
<li> .decl ExistsNextReturn(?ret:Instruction)</li>
<li> .decl FieldListContains(?fld:Field, ?fldList:AccessPathSuffix)</li>
<li> .decl FieldList_Length(?fldList:AccessPathSuffix, ?len:number)</li>
<li> .decl FinalFieldMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?fld:Field)</li>
<li> .decl FirstCalleeFromCallsite(?calleeCtx:MayContext, ?meth:Method)</li>
<li> .decl FirstInstanceStoreInMethod(?storeInsn:Instruction, ?meth:Method)</li>
<li> .decl FirstInstructionOfMethod(?meth:Method, ?firstInsn:Instruction)</li>
<li> .decl FirstInvocationInMethod(?invo:Instruction, ?meth:Method)</li>
<li> .decl HasAccessPathMayPointToUpToRelevantPredecessor(?pred:Instruction, ?ap:AccessPath, ?ctx:MayContext, ?insn:Instruction)</li>
<li> .decl IgnorableForNonCollectionsMethodInvocation(?invo:MethodInvocation)</li>
<li> .decl IgnorableForStaticsMethodInvocation(?invo:MethodInvocation)</li>
<li> .decl IgnorableMethodInvocation(?invo:MethodInvocation)</li>
<li> .decl InitialComputedAccessPath(?ap:AccessPath)</li>
<li> .decl InitialMayContext(?ctx:MayContext)</li>
<li> .decl InitialRootMethodForMayAnalysis(?meth:Method)</li>
<li> .decl InstanceStoreInSameMethod(?storeInsn1:Instruction, ?storeInsn2:Instruction, ?meth:Method)</li>
<li> .decl IntraproceduralCertainMethodBase(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ctx:MayContext, ?invo:MethodInvocation)</li>
<li> .decl IntraproceduralMustPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ctx:MayContext, ?var:Var)</li>
<li> .decl IntraproceduralMustPointToUpToPhiInstruction(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ctx:MayContext, ?insn:Instruction)</li>
<li> .decl InvocationActualFormalAssignment(?calleeCtx:MayContext, ?formal:Var, ?callerCtx:MayContext, ?actual:Var)</li>
<li> .decl InvocationHasNoExternalSideEffects(?callerCtx:MayContext, ?invo:MethodInvocation)</li>
<li> .decl InvocationHasNoSideEffects(?callerCtx:MayContext, ?invo:MethodInvocation)</li>
<li> .decl InvocationInSameMethod(?invo1:Instruction, ?invo2:Instruction, ?meth:Method)</li>
<li> .decl InvocationSiteFullyResolved(?ctx: MayContext, ?invo:Instruction)</li>
<li> .decl LibraryCollectionLoadOperation(?invo:MethodInvocation)</li>
<li> .decl LibraryCollectionRoot(?type:Type)</li>
<li> .decl LibraryCollectionStoreOperation(?invo:MethodInvocation)</li>
<li> .decl LibraryCollectionType(?type:Type)</li>
<li> .decl LoadCollection_Base(?insn:Instruction, ?to:Var)</li>
<li> .decl LoadCollection_To(?insn:Instruction, ?to:Var)</li>
<li> .decl MaxMayContextDepth(?num:number)</li>
<li> .decl MayCallGraphEdge(?ctx:MayContext, ?meth:Method, ?callerCtx:MayContext, ?invo:MethodInvocation)</li>
<li> .decl MayCallGraphEdge_Prev(?ctx:MayContext, ?meth:Method, ?callerCtx:MayContext, ?invo:MethodInvocation)</li>
<li> .decl MayContextDepth(?ctx:MayContext, ?depth:number)</li>
<li> .decl MayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ctx:MayContext, ?var:Var)</li>
<li> .decl MayPointToUpToPhiInstruction(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ctx:MayContext, ?lastInsn:Instruction)</li>
<li> .decl MayReachableMayContext(?ctx:MayContext)</li>
<li> .decl MayReachableMethodUnderMayContext(?ctx:MayContext, ?inMeth:Method)</li>
<li> .decl MayReachableMethodUnderMayContext(?ctx:MayContext, ?meth:Method)</li>
<li> .decl MayReachableMethodUnderMayContext_Prev(?ctx:MayContext, ?meth:Method)</li>
<li> .decl MethodCanCallOther(?ctxFrom:MayContext, ?method:Method, ?ctxTo:MayContext, ?toMethod:Method)</li>
<li> .decl MethodHasInvocationSite(?invo:Instruction, ?method:Method)</li>
<li> .decl MethodHasNoExternalSideEffects(?callerCtx:MayContext, ?meth:Method)</li>
<li> .decl MethodHasNoSideEffects(?callerCtx:MayContext, ?meth:Method)</li>
<li> .decl MethodHasOverridingMethodWithExternalSideEffects(?methodSuper:Method)</li>
<li> .decl MethodHasOverridingMethodWithSideEffects(?methodSuper:Method)</li>
<li> .decl MethodHasUnresolvedInvocation(?ctx: MayContext, ?toMethod:Method)</li>
<li> .decl MethodMayAssignField(?fld:Field, ?ctx: MayContext, ?toMethod:Method)</li>
<li> .decl MethodReachableFromConstructorOfClassOfField(?fld:Field, ?consMeth:Method)</li>
<li> .decl NextCalleeFromCallsite(?calleeCtx:MayContext, ?meth:Method, ?methNext:Method)</li>
<li> .decl NextInstanceStoreInSameMethod(?storeInsn1:Instruction, ?storeInsn2:Instruction, ?meth:Method)</li>
<li> .decl NextInvocationInSameMethod(?invo1:Instruction, ?invo2:Instruction, ?meth:Method)</li>
<li> .decl NotNextCalleeFromCallsite(?calleeCtx:MayContext, ?meth:Method, ?methNext:Method)</li>
<li> .decl NotNextInstanceStoreInSameMethod(?storeInsn1:Instruction, ?storeInsn2:Instruction, ?meth:Method)</li>
<li> .decl NotNextInvocationInSameMethod(?invo1:Instruction, ?invo2:Instruction, ?meth:Method)</li>
<li> .decl OptAccessPathUnaffectedByInsnPredecessorBB(?pred:Instruction, ?insn:Instruction, ?ap:AccessPath)</li>
<li> .decl OptHasAccessPathPointToAtPredecessor(?pred:Instruction, ?ap:AccessPath, ?ctx:MayContext, ?insn:Instruction)</li>
<li> .decl OptPotentialSpecialMethodBase(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ctx:MayContext, ?invo:MethodInvocation)</li>
<li> .decl OptPotentialVirtualMethodBase(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ctx:MayContext, ?invo:MethodInvocation)</li>
<li> .decl OptVirtualOrSpecialMethodInvocation_Base(?invo:MethodInvocation, ?base:Var)</li>
<li> .decl Output_MethodHasNoExternalSideEffects(?meth:Method)</li>
<li> .decl Output_MethodHasNoSideEffects(?meth:Method)</li>
<li> .decl PhiNodeVarWithResolvedMayPointTo(?ctx:MayContext, ?var:Var)</li>
<li> .decl RebaseCompositeAccessPath(?ap:AccessPath, ?from:Var, ?to:Var, ?newAp:AccessPath)</li>
<li> .decl RepresentativeAccessPathMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?var:Var, ?fld:Field, ?ctx:MayContext, ?insn:Instruction)</li>
<li> .decl ReturnValueOfResolvedCallAssignedTo(?callerCtx:MayContext, ?to:Var, ?calleeCtx:MayContext, ?toMethod:Method)</li>
<li> .decl RootMethodForMayAnalysis(?meth:Method)</li>
<li> .decl SingleFieldAccessPath(?fld:Field, ?ap:AccessPath)</li>
<li> .decl SomePathBetweenBasicBlocksContainsCall(?prev:Instruction, ?next:Instruction)</li>
<li> .decl SomePathBetweenBasicBlocksContainsUnresolvedCall(?prev:Instruction, ?next:Instruction)</li>
<li> .decl SomePathBetweenBasicBlocksMayAffectField(?prev:Instruction, ?next:Instruction, ?fld:Field)</li>
<li> .decl SomePathFromFirstInstructionContainsCall(?blockHead:Instruction)</li>
<li> .decl SomePathFromFirstInstructionContainsUnresolvedCall(?blockHead:Instruction)</li>
<li> .decl SomePathFromFirstInstructionMayAffectField(?blockHead:Instruction, ?fld:Field)</li>
<li> .decl StaticFinalFieldMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?fld:Field)</li>
<li> .decl StaticOrSpecialInvocationInMethod(?invo:MethodInvocation, ?inMeth:Method)</li>
<li> .decl StaticStoreFromVarMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ctx:MayContext, ?insn:Instruction)</li>
<li> .decl StoreCollection_Base(?insn:Instruction, ?from:Var)</li>
<li> .decl StoreCollection_From(?insn:Instruction, ?from:Var)</li>
<li> .decl StoreFromVarMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ctx:MayContext, ?insn:Instruction)</li>
<li> .decl StoreInstruction(?insn:Instruction)</li>
<li> .decl Temp1(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ap:AccessPath, ?ctx:MayContext, ?insn:Instruction)</li>
<li> .decl Temp2(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ap:AccessPath, ?ctx:MayContext, ?insn:Instruction)</li>
<li> .decl TempMayPointTo(?heap:HeapAllocation, ?ctx:MayContext, ?to:Var)</li>
<li> .decl TentativeCollectionBaseApMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ap:AccessPath, ?ctx:MayContext, ?insn:Instruction)</li>
<li> .decl ThisVarOfConstructor(?method:Method, ?this:Var)</li>
<li> .decl UpToCallee_CallHasNoExternalSideEffects(?callerCtx:MayContext, ?invocation:MethodInvocation, ?calleeCtx:MayContext, ?toMeth:Method)</li>
<li> .decl UpToCallee_CallHasNoSideEffects(?callerCtx:MayContext, ?invocation:MethodInvocation, ?calleeCtx:MayContext, ?toMeth:Method)</li>
<li> .decl UpToCallee_ReturnAccessPathMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?calleeAp:AccessPath, ?calleeCtx:MayContext, ?meth:Method)</li>
<li> .decl UpToCallee_ReturnMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?calleeCtx:MayContext, ?meth:Method)</li>
<li> .decl UpToInstanceFieldStoreHasNoExternalSideEffects(?meth:Method, ?storeInsn:Instruction)</li>
<li> .decl UpToInstanceFieldStoreHasNoSideEffects(?meth:Method, ?storeInsn:Instruction)</li>
<li> .decl UpToInvocationMethodHasNoExternalSideEffects(?callerCtx:MayContext, ?invo:MethodInvocation, ?meth:Method)</li>
<li> .decl UpToInvocationMethodHasNoSideEffects(?callerCtx:MayContext, ?invo:MethodInvocation, ?meth:Method)</li>
<li> .decl UpToParamCalleeHasNoExternalSideEffects(?index:number, ?callerCtx:MayContext, ?invocation:MethodInvocation, ?calleeCtx:MayContext, ?toMeth:Method)</li>
<li> .decl UpToParamCalleeHasNoSideEffects(?index:number, ?callerCtx:MayContext, ?invocation:MethodInvocation, ?calleeCtx:MayContext, ?toMeth:Method)</li>
<li> .decl UpToReturnAccessPathMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ap:AccessPath, ?ctx:MayContext, ?ret:Instruction)</li>
<li> .decl UpToReturnMayPointTo(?hctx:MayHeapContext, ?heap:HeapAllocation, ?ctx:MayContext, ?return:Instruction)</li>
<li> .decl UpToReturnSameRetVar(?return:Instruction, ?var:Var)</li>
<li> .decl VarHasNoExternalSideEffects(?var:Var)</li>
<li> .decl VarHasNoExternalSideEffectsUpToPhiInstruction(?insn:Instruction)</li>
<li> .decl VarHasNoSideEffects(?var:Var)</li>
<li> .decl VarHasNoSideEffectsUpToPhiInstruction(?insn:Instruction)</li>
<li> .decl _InvocationsPerMethod(?meth:Method, ?n:number)</li>
<li> .decl _MethodHasSideEffectInstruction(?meth:Method)</li>
<li> .decl _MethodIsNative(?meth:Method)</li>
<li> .decl _ReasonableMethod(?meth:Method)</li>
<li> .decl _StoreInstanceFieldInMethod(?storeInsn:Instruction, ?meth:Method)</li>
</ul>
<h2> analyses/sound-may-point-to/must-alias.dl </h2>
<ul>
<li> .decl AllRelevantPredecessorsMustAlias(?ap1:AccessPath, ?ap2:AccessPath, ?ctx:MayContext, ?insn:Instruction)</li>
<li> .decl Before_MustAlias(?ap1:AccessPath, ?ap2:AccessPath, ?ctx:MayContext, ?insn:Instruction)</li>
<li> .decl Before_MustAlias(?ap1:AccessPath, ?ap2:AccessPath, ?ctx:MayContext, ?insn:Instruction)</li>
<li> .decl MustAlias(?ap1:AccessPath, ?ap2:AccessPath, ?ctx:MayContext, ?insn:Instruction)</li>
<li> .decl MustAlias(?ap1:AccessPath, ?ap2:AccessPath, ?ctx:MayContext, ?insn:Instruction)</li>
<li> .decl MustAliasAtPredecessor(?pred:Instruction, ?ap1:AccessPath, ?ap2:AccessPath, ?ctx:MayContext, ?insn:Instruction)</li>
<li> .decl MustAliasBaseInvalidated(?ap1:AccessPath, ?ap2:AccessPath, ?insn:Instruction)</li>
<li> .decl MustAliasUpToRelevantPredecessor(?pred:Instruction, ?ap1:AccessPath, ?ap2:AccessPath, ?ctx:MayContext, ?insn:Instruction)</li>
</ul>
<h2> analyses/sound-may-point-to/must-point-to.dl </h2>
<ul>
<li> .decl AllCallee_FieldMustPointTo(?hctxBase:MayHeapContext, ?heapBase:MustAbstractObject, ?fld:Field, ?hctx:MayHeapContext, ?heap:MustAbstractObject, ?calleeCtx:MayContext, ?meth:Method)</li>
<li> .decl AllCallee_ReturnMustPointTo(?hctx:MayHeapContext, ?heap:MustAbstractObject, ?calleeCtx:MayContext, ?meth:Method)</li>
<li> .decl AllReturn_FieldMustPointTo(?hctxBase:MayHeapContext, ?heapBase:MustAbstractObject, ?fld:Field, ?hctx:MayHeapContext, ?heap:MustAbstractObject, ?ctx:MayContext, ?method:Method)</li>
<li> .decl AllReturn_MustPointTo(?hctx:MayHeapContext, ?heap:MustAbstractObject, ?ctx:MayContext, ?method:Method)</li>
<li> .decl Before_FieldMustPointTo(?hctxBase:MayHeapContext, ?heapBase:MustAbstractObject, ?fld:Field, ?hctx:MayHeapContext, ?heap:MustAbstractObject, ?ctx:MayContext, ?insn:Instruction)</li>
<li> .decl Before_FieldMustPointTo(?hctxBase:MayHeapContext, ?heapBase:MustAbstractObject, ?fld:Field, ?hctx:MayHeapContext, ?heap:MustAbstractObject, ?ctx:MayContext, ?insn:Instruction)</li>
<li> .decl FieldMustPointTo(?hctxBase:MayHeapContext, ?heapBase:MustAbstractObject, ?fld:Field, ?hctx:MayHeapContext, ?heap:MustAbstractObject, ?ctx:MayContext, ?insn:Instruction)</li>
<li> .decl FieldMustPointTo(?hctxBase:MayHeapContext, ?heapBase:MustAbstractObject, ?fld:Field, ?hctx:MayHeapContext, ?heap:MustAbstractObject, ?ctx:MayContext, ?insn:Instruction)</li>
<li> .decl MustPointTo(?hctx:MayHeapContext, ?heap:MustAbstractObject, ?ctx:MayContext, ?var:Var)</li>
<li> .decl MustPointTo(?hctx:MayHeapContext, ?heap:MustAbstractObject, ?ctx:MayContext, ?var:Var)</li>
<li> .decl MustPointToUpToPhiInstruction(?hctx:MayHeapContext, ?heap:MustAbstractObject, ?ctx:MayContext, ?lastInsn:Instruction)</li>
<li> .decl UpToCalleeFieldMustPointTo(?hctxBase:MayHeapContext, ?heapBase:MustAbstractObject, ?fld:Field, ?hctx:MayHeapContext, ?heap:MustAbstractObject, ?ctx:MayContext, ?meth:Method)</li>
<li> .decl UpToCalleeReturnMustPointTo(?hctx:MayHeapContext, ?heap:MustAbstractObject, ?calleeCtx:MayContext, ?meth:Method)</li>
<li> .decl UpToReturnFieldMustPointTo(?hctxBase:MayHeapContext, ?heapBase:MustAbstractObject, ?fld:Field, ?hctx:MayHeapContext, ?heap:MustAbstractObject, ?ctx:MayContext, ?insn:Instruction)</li>
<li> .decl UpToReturnMustPointTo(?hctx:MayHeapContext, ?heap:MustAbstractObject, ?ctx:MayContext, ?return:Instruction)</li>
<li> .decl VarMustAlias(?var1:Var, ?var2:Var, ?ctx:MayContext)</li>
<li> .decl VarMustAlias(?var1:Var, ?var2:Var, ?ctx:MayContext)</li>
<li> .decl VarMustAliasAP(?var:Var, ?ap:AccessPath, ?ctx:MayContext, ?insn:Instruction)</li>
<li> .decl VarMustAliasAP(?var:Var, ?ap:AccessPath, ?ctx:MayContext, ?insn:Instruction)</li>
<li> .decl VarMustAliasRepresentative(?var:Var, ?varRepr:Var, ?ctx:MayContext)</li>
<li> .decl VarMustAliasRepresentative(?var:Var, ?varRepr:Var, ?ctx:MayContext)</li>
<li> .decl VarMustAliasThis(?var1:Var, ?method:Method, ?ctx:MayContext)</li>
<li> .decl VarMustAliasThis(?var1:Var, ?method:Method, ?ctx:MayContext)</li>
</ul>
<h2> analyses/sticky-2-object-sensitive/analysis.dl </h2>
<ul>
<li> .decl ApplicationInvo(?invocation:MethodInvocation)</li>
<li> .decl DataStructureClass(?class:Type)</li>
<li> .decl DataStructureInvo(?invocation:MethodInvocation)</li>
<li> .decl DataStructureMethod(?method:Method)</li>
<li> .decl LibraryOrDependencyMethod(?method:Method)</li>
</ul>
<h2> analyses/types-only/analysis.dl </h2>
<ul>
<li> .decl OptReachableTypeResolveInvocation(?invocation:MethodInvocation, ?tomethod:Method)</li>
</ul>
<h2> analyses/xtractor/analysis.dl </h2>
<ul>
<li> .decl ArrayHasExprSymbol(out1: symbol, index: symbol, out2: symbol)</li>
<li> .decl FldHasExprSymbol(base: symbol, fld: symbol, out: symbol)</li>
<li> .decl HeapHasExprSymbol(heap: symbol, fld: symbol, out: symbol)</li>
<li> .decl TEST_ToSymbolConflict(expr1: Expr, expr2: Expr, out: symbol)</li>
<li> .decl TEST_ToSymbolMissing(expr: Expr)</li>
<li> .decl TEST_WrongSizedExpr(out: symbol, size: number)</li>
<li> .decl VarHasExprSymbol(loc: symbol, out: symbol)</li>
<li> .decl rel##Symbol(out1: symbol, out2: symbol)</li>
<li> .decl rel##Symbol(out: symbol)</li>
</ul>
<h2> analyses/xtractor/arrays.dl </h2>
<ul>
<li> .decl ArrayDimIterated(array: Var, dim: number, indexVar: Var, loopHead: Instruction)</li>
<li> .decl ArrayDims(array: Var, dim: number, size: number)</li>
<li> .decl ArrayInitializedInLoop(array: Var, loopHead: Instruction, value: AccessPath)</li>
<li> .decl ArrayUsedInLoop(array: Var, indexVar: Var, loopHead: Instruction)</li>
<li> .decl ArrayWrite_AUX(ap: AccessPath)</li>
<li> .decl MainArrayVar(array: Var, name: symbol, types: symbol)</li>
<li> .decl OUT_ArrayInitialized(array: Var, value: symbol)</li>
<li> .decl OUT_ArrayWrite(out: symbol)</li>
</ul>
<h2> analyses/xtractor/common.dl </h2>
<ul>
<li> .decl API_ResultMethod(method: Method)</li>
<li> .decl AccessPathStr(ap: AccessPath, out: symbol)</li>
<li> .decl ArrayVar(var: Var)</li>
<li> .decl FlippedCondition(op: symbol, flippedOp: symbol)</li>
<li> .decl IVALUE_ArrayIndex(stmt: Instruction, index: number)</li>
<li> .decl IVALUE_ArraySize_EXT(stmt: Instruction, size: number)</li>
<li> .decl IVALUE_OPERAND(stmt: Instruction, pos: number, value: number)</li>
<li> .decl IVALUE_Var(var: Var, value: number)</li>
<li> .decl IVALUE_Var_EXT(var: Var, value: number)</li>
<li> .decl NonArrayVar(var: Var)</li>
<li> .decl ReverseCondition(op: symbol, reverseOp: symbol)</li>
<li> .decl VarHasAP(var: Var, ap: AccessPath)</li>
<li> .decl VarSymbolicValue(var: Var, value: symbol)</li>
<li> .decl isAccessPath(ap: AccessPath)</li>
</ul>
<h2> analyses/xtractor/conditions.dl </h2>
<ul>
<li> .decl CondStr(cond: Cond, out: symbol)</li>
<li> .decl GroupCondStr(cond: GroupCond, out: symbol)</li>
<li> .decl IfBothGotoSame_AUX(ifStmt1: Instruction, ifStmt2: Instruction, index1: number, index2: number, label: number)</li>
<li> .decl IfCondition(ifStmt: Instruction, cond: Cond)</li>
<li> .decl IfGroupCondition(ifStmt: Instruction, cond: GroupCond)</li>
<li> .decl IfGroup_AUX(ifStmt: Instruction, method: Method, index: number)</li>
<li> .decl IfInGroup_AUX(ifStmt1: Instruction, ifStmt2: Instruction, index1: number, index2: number)</li>
<li> .decl IfJumpToDifferentInBetween_AUX(ifStmt1: Instruction, ifStmt2: Instruction)</li>
<li> .decl IfOperand(stmt: Instruction, pos: number, ap: AccessPath)</li>
<li> .decl IfReturns(ifStmt: Instruction, retStmt: Instruction, ap: AccessPath)</li>
<li> .decl Next_IfGroup(ifStmt1: Instruction, ifStmt2: Instruction)</li>
<li> .decl Next_IfInGroup(ifStmt1: Instruction, ifStmt2: Instruction)</li>
<li> .decl NoIfReturns(method: Method, ap: AccessPath)</li>
<li> .decl OUT_IfGroupConditionStr(ifStmt: Instruction, methodName: symbol, out: symbol)</li>
<li> .decl OUT_IfReturnsStr(ifStmt: Instruction, out: symbol)</li>
<li> .decl OUT_NoIfReturnsStr(method: Method, retType: Type, out: symbol)</li>
<li> .decl isCond(cond: Cond)</li>
<li> .decl isGroupCond(cond: GroupCond)</li>
</ul>
<h2> analyses/xtractor/constant-folding.dl </h2>
<ul>
<li> .decl API_RequestConstantFold1(op: Operator, arg: symbol)</li>
<li> .decl API_RequestConstantFold2(op: Operator, left: symbol, right: symbol)</li>
<li> .decl API_RespondConstantFold1(op: Operator, arg: symbol, folded: symbol)</li>
<li> .decl API_RespondConstantFold2(op: Operator, left: symbol, right: symbol, folded: symbol)</li>
</ul>
<h2> analyses/xtractor/expr-client.dl </h2>
<ul>
<li> .decl ArrayHasExpr(arrExpr: Expr, index: symbol, expr: Expr)</li>
<li> .decl FldHasExpr(base: symbol, fld: Field, expr: Expr)</li>
<li> .decl FormalToActualExpr(x:MethodInvocation, formal: Var, actualExpr: Expr)</li>
<li> .decl HeapHasExpr(heapExpr: Expr, fld: Field, expr: Expr)</li>
<li> .decl InputMethod(method: Method)</li>
<li> .decl InterestingConstrStmt(x: Instruction, method: Method)</li>
<li> .decl MapOperator(op: Operator, mapped: Operator)</li>
<li> .decl MarkedForMapping(x:MethodInvocation, base: Var, fld: Field, expr: Expr)</li>
<li> .decl OperandExpr(stmt: Instruction, pos: number, expr: Expr, size: number, var: Var)</li>
<li> .decl OutputMethod(method: Method)</li>
<li> .decl PassThroughMethod(method: Method, pos: number)</li>
<li> .decl REQ_Mapping(x:Instruction, expr: Expr)</li>
<li> .decl RES_Mapping(x:Instruction, expr: Expr, mapped: Expr)</li>
<li> .decl RequestExpr_BINOP(to: Var, op: Operator, left: Expr, right: Expr, leftVar: Var, rightVar: Var, lrSize: number)</li>
<li> .decl VarHasExpr(loc: Var, expr: Expr)</li>
<li> .decl isEffectivelyEmptyConstructor(m: Method)</li>
<li> .decl isRefHeapExpr(heap: HeapAllocation, expr: Expr)</li>
</ul>
<h2> analyses/xtractor/loops.dl </h2>
<ul>
<li> .decl BlockInStructuredLoop(bb: Instruction, loopHead: Instruction)</li>
<li> .decl ChangeByOne(stmt: Instruction, to: Var, var: Var)</li>
<li> .decl ContainsInnerStructuredLoop(loopHead: Instruction, innerloopHead: Instruction)</li>
<li> .decl InductionVariable(var: Var, loopHead: Instruction)</li>
<li> .decl InnermostStructuredLoop(loopHead: Instruction)</li>
<li> .decl LocalBlockEdge(fromBB: Instruction, toBB: Instruction)</li>
<li> .decl LoopExitCond(condVar: Var, op: symbol, rhs: number, loopHead: Instruction)</li>
<li> .decl LoopExitCond_Stmt(jumpStmt: Instruction, loopHead: Instruction)</li>
<li> .decl LoopInitialValue(condVar: Var, value: number, loopHead: Instruction)</li>
<li> .decl LoopMainExitCond(jumpStmt: Instruction)</li>
<li> .decl StmtInStructuredLoop(stmt: Instruction, loopHead: Instruction)</li>
<li> .decl StructuredLoopBackEdge(fromBB: Instruction, toBB: Instruction)</li>
<li> .decl StructuredloopHead(bb: Instruction)</li>
</ul>
<h2> analyses/xtractor/out-schema.dl </h2>
<ul>
<li> .decl OUT_ClassInfo(class: symbol, kind: symbol, field: symbol, fieldType: symbol)</li>
</ul>
<h2> analyses/xtractor/symbolic.dl </h2>
<ul>
<li> .decl API_IsBoundVar(expr: Expr)</li>
<li> .decl API_IsFreeVar(expr: Expr)</li>
<li> .decl API_IsInitialConstantExpr(const: Expr)</li>
<li> .decl API_IsInitialExpr(expr: Expr)</li>
<li> .decl AbsorbingOperators(op1: Operator, op2: Operator)</li>
<li> .decl AssociativeOperator(op: Operator)</li>
<li> .decl CancelingOperator(op: Operator, const: Expr)</li>
<li> .decl CommutativeOperator(op: Operator)</li>
<li> .decl CommutativePairOperators(op1: Operator, op2: Operator)</li>
<li> .decl DeMorganOperators(op1: Operator, op2: Operator)</li>
<li> .decl DecomposeExpr(expr: Expr, base: Base, left: Expr, right: Expr)</li>
<li> .decl DualAssociativeOperators(op1: Operator, op2: Operator)</li>
<li> .decl ExprHasBoundVar(expr: Expr)</li>
<li> .decl ExprHasFreeVar(expr: Expr)</li>
<li> .decl ExprHasNoFreeVar(expr: Expr)</li>
<li> .decl ExprSize(expr: Expr, size: number)</li>
<li> .decl ExprSymbol(out: symbol)</li>
<li> .decl IdempotentOperator(op: Operator)</li>
<li> .decl InfixSymbol(op: Operator, out: symbol)</li>
<li> .decl IsArithmeticOperator(op: Operator)</li>
<li> .decl IsBinaryOperator(op: Operator)</li>
<li> .decl IsConstantExpr(expr: Expr, const: PrimitiveExpr)</li>
<li> .decl IsExpr(expr: Expr)</li>
<li> .decl IsLogicalExpr(expr: Expr)</li>
<li> .decl IsLogicalOperator(op: Operator)</li>
<li> .decl IsOperator(op: Operator)</li>
<li> .decl IsUnaryOperator(op: Operator)</li>
<li> .decl LeftAnnihilator(op: Operator, const: Expr, result: Expr)</li>
<li> .decl LeftIdentityElement(op: Operator, id: Expr)</li>
<li> .decl MaybeLogicalOperator(op: Operator)</li>
<li> .decl MutuallyExclusiveOperators(op1: Operator, op2: Operator)</li>
<li> .decl RightAnnihilator(op: Operator, const: Expr, result: Expr)</li>
<li> .decl RightIdentityElement(op: Operator, id: Expr)</li>
<li> .decl SelfInverseOperator(op: Operator)</li>
<li> .decl ToSymbol(expr: Expr, out: symbol)</li>
<li> .decl UnarySymbol(op: Operator, out: symbol)</li>
</ul>
<h2> analyses/xtractor/theorem-prover.dl </h2>
<ul>
<li> .decl API_EqualityCheckRequest(expr1: Expr, expr2: Expr)</li>
<li> .decl API_InequalityCheckRequest(op: Operator, expr1: Expr, expr2: Expr)</li>
<li> .decl CompareOperator(op: Operator)</li>
<li> .decl EqualityCheckResponse(expr1: Expr, expr2: Expr, result: Expr)</li>
<li> .decl Equals(expr1: Expr, expr2: Expr)</li>
<li> .decl EqualsToNotLarger(expr1: Expr, size1: number, expr2: Expr, size2: number)</li>
<li> .decl EqualsToSmallerExt(expr1: Expr, expr2: Expr)</li>
<li> .decl ExprGreaterThan(expr1: Expr, expr2: Expr)</li>
<li> .decl ExprRequestFold1(expr: Expr, op: symbol, const: symbol)</li>
<li> .decl ExprRequestFold2(expr: Expr, op: symbol, leftConst: symbol, rightConst: symbol)</li>
<li> .decl Implies(expr1: Expr, expr2: Expr)</li>
<li> .decl InequalityCheckResponse(op: Operator, expr1: Expr, expr2: Expr, result: Expr)</li>
<li> .decl LinearSolvableExpression(expr: Expr, op: Operator, left: Expr, right: Expr)</li>
<li> .decl NegatedExpr(expr: Expr, negExpr: Expr)</li>
<li> .decl NonReducedExpr(expr: Expr)</li>
<li> .decl Normalize(expr: Expr, norm: Expr)</li>
<li> .decl NormalizedLogicalExpr(expr: Expr)</li>
<li> .decl OptBaseEquals(expr1: Expr, expr2: Expr)</li>
<li> .decl OptBaseImplies(expr1: Expr, expr2: Expr)</li>
<li> .decl PreNormalize(expr: Expr, norm: Expr)</li>
<li> .decl RequestDistributivityEQ(expr1: Expr, op1Size: number, expr2: Expr)</li>
<li> .decl ValueForFreeVar(freeVar: Expr, expr: Expr, exprSolved: Expr)</li>
</ul>
<h2> basic/basic.dl </h2>
<ul>
<li> .decl MainMethodDeclaration(?method:Method)</li>
</ul>
<h2> basic/classes-scc.dl </h2>
<ul>
<li> .decl CountOfApplicationClassesTransitivelyKnownBySCC(?idType:number, ?num:number)</li>
<li> .decl CountOfReferencesBetweenSCCs(?sccFrom:number, ?sccTo:number, ?cnt:number)</li>
<li> .decl CountOfTypesPerSCC(?idType:number, ?num:number)</li>
<li> .decl MaxCountOfApplicationClassesTransitivelyKnownBySCC(?maxNum:number)</li>
<li> .decl MaxCountOfTypesPerSCC(?maxNum:number)</li>
<li> .decl NumberOfRelevantTypes(?num:number)</li>
<li> .decl SCCKnowsAboutOther(?sccFrom:number, ?sccTo:number)</li>
<li> .decl SCCPerCountOfTypes(?idType:number, ?num:number)</li>
<li> .decl SCCRefersToType(?typeTo:Type, ?sccidFrom:number, ?scciTo:number)</li>
<li> .decl SCCTransitivelyKnowsAboutApplicationClass(?class:ClassType, ?sccFrom:number)</li>
<li> .decl SCCTransitivelyKnowsAboutOther(?sccFrom:number, ?sccTo:number)</li>
<li> .decl SCCType(?type:Type)</li>
<li> .decl SCCTypesInSameSCC(?type:Type, ?type:Type)</li>
<li> .decl SCCWithMaxCountOfTransitivelyKnownApplicationClasses(?idType:number)</li>
<li> .decl SCCWithMaxCountOfTypes(?idType:number)</li>
<li> .decl SpecialLibrary(?class:ClassType)</li>
<li> .decl TypeRefersToOther(typeFrom: Type, typeTo: Type)</li>
<li> .decl TypeToPartitionId(?inClass:Type, ?sccId:number)</li>
<li> .decl TypeToSCCId(?type:Type, ?idType:number)</li>
<li> .decl TypeTransitivelyRefersToOther(typeFrom: Type, typeTo: Type)</li>
</ul>
<h2> basic/finalization-declarations.dl </h2>
<ul>
<li> .decl AllocatedObjectSupportsFinalize(?heap:HeapAllocation, ?inmethod:Method)</li>
<li> .decl OverridesFinalize(?class:Type)</li>
</ul>
<h2> basic/method-lookup.dl </h2>
<ul>
<li> .decl CovariantMethods(?meth1:Method, ?meth2:Method)</li>
<li> .decl DuplicateMethodImplemented(?simplename:symbol, ?descriptor:MethodDescriptor, ?type:ReferenceType, ?method1:Method, ?method2:Method)</li>
<li> .decl DuplicateMethodLookup(?simplename:symbol, ?descriptor:MethodDescriptor, ?type:ReferenceType, ?method1:Method, ?method2:Method)</li>
<li> .decl MethodImplemented(?simplename:symbol, ?descriptor:MethodDescriptor, ?type:ReferenceType, ?method:Method)</li>
<li> .decl MethodImplementedModuloCovariance(?simplename:symbol, ?descriptor:MethodDescriptor, ?type:ReferenceType, ?method:Method)</li>
<li> .decl MethodLookup(?simplename:symbol, ?descriptor:MethodDescriptor, ?type:ReferenceType, ?method:Method)</li>
<li> .decl MethodMightBeCovariantBridge(?bridge:Method, ?meth:Method)</li>
<li> .decl MethodNotCovariantBridge(?meth1:Method, ?meth2:Method)</li>
<li> .decl MethodOverridesOther(?methodSub:Method, ?methodSuper:Method)</li>
<li> .decl Method_CovariantBridge(?bridge:Method, ?cometh:Method)</li>
<li> .decl _BridgeMethod(?bridge:Method, ?name:symbol, ?type:Type)</li>
<li> .decl _MethodLookup_ClassResolution(?simplename:symbol, ?descriptor:MethodDescriptor, ?type:ReferenceType, ?method:Method)</li>
<li> .decl _MethodLookup_ClosestInterface(?simplename:symbol, ?descriptor:MethodDescriptor, ?type:ReferenceType, ?method:Method)</li>
<li> .decl _MethodLookup_ImpossibleClosest(?simplename:symbol, ?descriptor:MethodDescriptor, ?type:ReferenceType, ?method:Method)</li>
<li> .decl _MethodLookup_MoreThanOne(?simplename:symbol, ?descriptor:MethodDescriptor, ?type:ReferenceType)</li>
<li> .decl _MethodLookup_MultiClosestInterfaces(?simplename:symbol, ?descriptor:MethodDescriptor, ?type:ReferenceType)</li>
<li> .decl _MethodLookup_WithLen(?simplename:symbol, ?descriptor:MethodDescriptor, ?type:ReferenceType, ?method:Method, ?len:number)</li>
</ul>
<h2> basic/method-resolution.dl </h2>
<ul>
<li> .decl ConcreteMethodDeclared(?meth:Method, ?class:ClassType)</li>
<li> .decl MethodDeclaredOrInherited(?meth:Method, ?class:ReferenceType)</li>
<li> .decl MethodsOfSameNonSDKType(?method1:Method, ?method2:Method, ?class:Type)</li>
<li> .decl MethodsOfSameOrSuperType(?method1:Method, ?method2:Method)</li>
<li> .decl ResolveInvocation(?type:Type, ?invocation:MethodInvocation, ?tomethod:Method)</li>
<li> .decl VirtualMethodInvocation_BaseType(?invocation:MethodInvocation, ?type:Type)</li>
</ul>
<h2> basic/native-strings.dl </h2>
<ul>
<li> .decl JNIMethod_NativeId(?javaMethod:Method, ?nativeId:symbol)</li>
<li> .decl OverloadedJNIMethod(?javaMethod:Method, ?type:ReferenceType, ?name:symbol, ?descriptor:symbol)</li>
<li> .decl PossibleNativeCodeTargetMethod(?method:Method, ?function:symbol, ?file:symbol)</li>
<li> .decl PossibleNativeCodeTargetMethodLocalized(?method:Method, ?function:symbol, ?file:symbol)</li>
</ul>
<h2> basic/partitioning.dl </h2>
<ul>
<li> .decl CountOfTypesPerSCC(id: Partition, cnt: number)</li>
<li> .decl IdTypeOfGenericPartition(id: Partition)</li>
<li> .decl NumberOfRelevantTypes(cnt: number)</li>
<li> .decl PartitionedType(type: Type)</li>
<li> .decl TypeInGenericPartition(type: Type)</li>
<li> .decl TypeRefersToOther(typeFrom: Type, typeTo: Type)</li>
<li> .decl TypeToPartition(type: Type, partitionName: Type)</li>
<li> .decl TypeToPartitionId(type: Type, id: Partition)</li>
<li> .decl TypeToSCCId(type: Type, id: Partition)</li>
<li> .decl TypeTransitivelyRefersToOther(typeFrom: Type, typeTo: Type)</li>
<li> .decl TypesInSameSCC(type1: Type, type2: Type)</li>
<li> .decl isPartition(partition: Partition)</li>
</ul>
<h2> basic/type-hierarchy.dl </h2>
<ul>
<li> .decl ClassConstructor(?method:Method, ?type:ClassType)</li>
<li> .decl Class_InterestingSubtype(?class:ReferenceType, ?subClass:ReferenceType)</li>
<li> .decl DirectSubclass(?a:ClassType, ?c:ClassType)</li>
<li> .decl Subclass(?c:ClassType, ?a:ClassType)</li>
<li> .decl Subclassable(?type:ReferenceType)</li>
<li> .decl SubtypeOf(?subtype:Type, ?type:Type)</li>
<li> .decl SubtypeOfDifferent(?subtype:Type, ?type:Type)</li>
<li> .decl Superclass(?c:ClassType, ?a:ClassType)</li>
<li> .decl Superinterface(?k:InterfaceType, ?c:ReferenceType)</li>
<li> .decl SupertypeOf(?supertype:Type, ?type:Type)</li>
<li> .decl Unsubclassable(?type:ReferenceType)</li>
<li> .decl _Valid_Type(?type:ReferenceType)</li>
</ul>
<h2> facts/android.dl </h2>
<ul>
<li> .decl Activity(?x:ReferenceType)</li>
<li> .decl AndroidApplication(?t:ClassType)</li>
<li> .decl AndroidCallbackMethodName(?methodName:symbol)</li>
<li> .decl AndroidEntryPoint(?m:Method)</li>
<li> .decl AndroidId(?file:symbol, ?nodeId:symbol, ?value:symbol, ?prefix:symbol, ?id:symbol)</li>
<li> .decl AndroidIncludeXML(?file:symbol, ?nodeId:symbol, ?value:symbol)</li>
<li> .decl ArrayInitialValueFromConst(?instruction:Instruction, ?index:number, ?to:Var, ?arrayIndex:number, ?const:symbol, ?baseHeap:HeapAllocation, ?method:Method)</li>
<li> .decl ArrayInitialValueFromLocal(?instruction:Instruction, ?index:number, ?to:Var, ?arrayIndex:number, ?from:Var, ?baseHeap:HeapAllocation, ?method:Method)</li>
<li> .decl BroadcastReceiver(?x:ReferenceType)</li>
<li> .decl ContentProvider(?x:ReferenceType)</li>
<li> .decl FieldInitialValue(?fld:Field, ?valueString:symbol)</li>
<li> .decl LayoutControl(?id:symbol, ?type:ReferenceType, ?parent:symbol)</li>
<li> .decl LayoutControl0(?id:symbol, ?typename:ReferenceType, ?parent:symbol)</li>
<li> .decl SensitiveLayoutControl(?id:symbol, ?type:ReferenceType, ?parent:symbol)</li>
<li> .decl SensitiveLayoutControl0(?id:symbol, ?typename:ReferenceType, ?parent:symbol)</li>
<li> .decl Service(?x:ReferenceType)</li>
</ul>
<h2> facts/flow-insensitive-facts.dl </h2>
<ul>
<li> .decl AssignCast(?type:Type, ?from:Var, ?to:Var, ?inmethod:Method)</li>
<li> .decl AssignHeapAllocation(?heap:HeapAllocation, ?to:Var, ?inmethod:Method)</li>
<li> .decl AssignLocal(?from:Var, ?to:Var, ?inmethod:Method)</li>
<li> .decl AssignNull(?to:Var, ?inmethod:Method)</li>
<li> .decl LoadArrayIndex(?base:Var, ?to:Var, ?inmethod:Method)</li>
<li> .decl LoadInstanceField(?base:Var, ?sig:Field, ?to:Var, ?inmethod:Method)</li>
<li> .decl LoadStaticField(?sig:Field, ?to:Var, ?inmethod:Method)</li>
<li> .decl MethodInvocation_SimpleName(?invocation:Instruction, ?simpleName:symbol)</li>
<li> .decl ReturnVar(?var:Var, ?method:Method)</li>
<li> .decl StaticMethodInvocation(?invocation:MethodInvocation, ?signature:Method, ?inmethod:Method)</li>
<li> .decl StoreArrayIndex(?from:Var, ?base:Var, ?inmethod:Method)</li>
<li> .decl StoreInstanceField(?from:Var, ?base:Var, ?signature:Field, ?inmethod:Method)</li>
<li> .decl StoreStaticField(?from:Var, ?signature:Field, ?inmethod:Method)</li>
<li> .decl SuperMethodInvocation(?invocation:MethodInvocation, ?signature:Method, ?inmethod:Method)</li>
<li> .decl Throw(?insn:Throw_Insn, ?var:Var)</li>
<li> .decl VirtualMethodInvocation(?invocation:MethodInvocation, ?signature:Method, ?inmethod:Method)</li>
</ul>
<h2> facts/flow-sensitive-schema.dl </h2>
<ul>
<li> .decl ActualParam(?index:number, ?invocation:MethodInvocation, ?var:Var)</li>
<li> .decl AnnotationElement(?annotationKind:symbol, ?element:symbol, ?parentId:symbol, ?id:symbol, ?name:symbol, ?value1:symbol, ?value2:symbol)</li>
<li> .decl ApplicationAllocation(?allocation:HeapAllocation)</li>
<li> .decl ApplicationClass(?ref:ReferenceType)</li>
<li> .decl ApplicationField(?field:Field)</li>
<li> .decl ApplicationInvocation(?invocation:MethodInvocation)</li>
<li> .decl ApplicationMethod(?method:Method)</li>
<li> .decl ApplicationVar(?var:Var)</li>
<li> .decl ArrayAllocation(?insn:Instruction, ?pos:number, ?sizeVar:Var)</li>
<li> .decl ArrayInsnIndex(?insn:Instruction, ?index:Var)</li>
<li> .decl ArrayNumIndex(?insn:Instruction, ?index:number)</li>
<li> .decl AssignCastNumConstant_Id(?insn:AssignCastNumConstant_Insn, ?const:symbol)</li>
<li> .decl AssignCast_From(?insn:AssignCast_Insn, ?from:Var)</li>
<li> .decl AssignCast_Type(?insn:AssignCast_Insn, ?type:Type)</li>
<li> .decl AssignHeapAllocation_Heap(?insn:AssignHeapAllocation_Insn, ?heap:HeapAllocation)</li>
<li> .decl AssignInstanceOf_From(?insn:AssignInstanceOf_Insn, ?from:Var)</li>
<li> .decl AssignInstanceOf_Type(?insn:AssignInstanceOf_Insn, ?type:Type)</li>
<li> .decl AssignInstruction_To(?insn:AssignInstruction, ?to:Var)</li>
<li> .decl AssignLocal_From(?insn:AssignLocal_Insn, ?from:Var)</li>
<li> .decl AssignNumConstant_Id(?insn:AssignNumConstant_Insn, ?const:symbol)</li>
<li> .decl AssignOper_From(?insn:AssignOper_Insn, ?pos:number, ?from:Var)</li>
<li> .decl AssignOper_FromConstant(?insn:AssignOper_Insn, ?pos: number, ?from:NumConstant)</li>
<li> .decl AssignReturnValue(?invocation:MethodInvocation, ?to:Var)</li>
<li> .decl BootstrapParam(?index:number, ?invocation:DynamicMethodInvocation_Insn, ?var:Var)</li>
<li> .decl ClassHeap_InstanceType(?classHeap:ClassHeap, ?instanceType:ReferenceType)</li>
<li> .decl ClassModifier(?mod:Modifier, ?class:ReferenceType)</li>
<li> .decl ComponentType(?arrayType:ArrayType, ?componentType:Type)</li>
<li> .decl ConcreteClass(?ref:ClassType)</li>
<li> .decl DirectSuperclass(?class:ClassType, ?superclass:ClassType)</li>
<li> .decl DirectSuperinterface(?ref:ReferenceType, ?interface:InterfaceType)</li>
<li> .decl DummyIf_Var(?insn:If_Insn, ?Var:Var)</li>
<li> .decl DynamicMethodInvocation_Bootstrap(?invocation:DynamicMethodInvocation_Insn, ?bootSignature:Method)</li>
<li> .decl DynamicMethodInvocation_DynArity(?invocation:DynamicMethodInvocation_Insn, ?dynArity:number)</li>
<li> .decl DynamicMethodInvocation_DynName(?invocation:DynamicMethodInvocation_Insn, ?dynName:symbol)</li>
<li> .decl DynamicMethodInvocation_DynParamTypes(?invocation:DynamicMethodInvocation_Insn, ?dynParamTypes:symbol)</li>
<li> .decl DynamicMethodInvocation_DynReturnType(?invocation:DynamicMethodInvocation_Insn, ?dynRetType:Type)</li>
<li> .decl DynamicMethodInvocation_HandleTag(?instruction:DynamicMethodInvocation_Insn, ?tag:number)</li>
<li> .decl EnterMonitor_Var(?insn:EnterMonitor_Insn, ?var:Var)</li>
<li> .decl ExceptionHandler_Begin(?handler:ExceptionHandler, ?index:number)</li>
<li> .decl ExceptionHandler_End(?handler:ExceptionHandler, ?index:number)</li>
<li> .decl ExceptionHandler_FormalParam(?handler:ExceptionHandler, ?var:Var)</li>
<li> .decl ExceptionHandler_Index(?handler:ExceptionHandler, ?index:number)</li>
<li> .decl ExceptionHandler_Method(?handler:ExceptionHandler, ?inmethod:Method)</li>
<li> .decl ExceptionHandler_Previous(?handler:ExceptionHandler, ?previous:ExceptionHandler)</li>
<li> .decl ExceptionHandler_Type(?handler:ExceptionHandler, ?type:Type)</li>
<li> .decl ExitMonitor_Var(?insn:ExitMonitor_Insn, ?var:Var)</li>
<li> .decl FieldInstruction_Signature(?insn:FieldInstruction, ?sign:Field)</li>
<li> .decl Field_Annotation(?fld:Field, ?annotation:Annotation)</li>
<li> .decl Field_DeclaringType(?field:Field, ?declaringClass:ReferenceType)</li>
<li> .decl Field_Modifier(?mod:Modifier, ?field:Field)</li>
<li> .decl Field_SimpleName(?field:Field, ?simpleName:symbol)</li>
<li> .decl Field_Type(?field:Field, ?type:Type)</li>
<li> .decl FormalParam(?index:number, ?method:Method, ?var:Var)</li>
<li> .decl Goto_Target(?insn:Goto_Insn, ?index:number)</li>
<li> .decl HeapAllocation_EmptyArray(?heap:HeapAllocation)</li>
<li> .decl HeapAllocation_Null(?null:HeapAllocation)</li>
<li> .decl HeapAllocation_Type(?heap:HeapAllocation, ?type:ReferenceType)</li>
<li> .decl If_Constant(?insn:If_Insn, ?pos: number, ?cons: NumConstant)</li>
<li> .decl If_Target(?insn:If_Insn, ?index:number)</li>
<li> .decl If_Var(?insn:If_Insn, ?pos:number, ?var:Var)</li>
<li> .decl Instruction_Index(?insn:Instruction, ?index:number)</li>
<li> .decl Instruction_Line(?insn:Instruction, ?index:number)</li>
<li> .decl Instruction_Method(?insn:Instruction, ?inMethod:Method)</li>
<li> .decl LoadArrayIndex_Base(?insn:LoadArrayIndex_Insn, ?var:Var)</li>
<li> .decl LoadArrayIndex_To(?insn:LoadArrayIndex_Insn, var:Var)</li>
<li> .decl LoadInstanceField_Base(?insn:LoadInstanceField_Insn, ?var:Var)</li>
<li> .decl LoadInstanceField_To(?insn:LoadInstanceField_Insn, ?var:Var)</li>
<li> .decl LoadStaticField_To(?insn:LoadStaticField_Insn, ?var:Var)</li>
<li> .decl MainClass(?class:ClassType)</li>
<li> .decl MainMethodArgArray(?heap:HeapAllocation)</li>
<li> .decl MainMethodArgArrayContent(?heap:HeapAllocation)</li>
<li> .decl MethodHandleConstant_Arity(?heap:MethodHandleConstant, ?arity:number)</li>
<li> .decl MethodHandleConstant_Method(?heap:MethodHandleConstant, ?method:Method)</li>
<li> .decl MethodHandleConstant_ParamTypes(?heap:MethodHandleConstant, ?paramTypes:symbol)</li>
<li> .decl MethodHandleConstant_ReturnType(?heap:MethodHandleConstant, ?retType:Type)</li>
<li> .decl MethodInvocation_Base(?invocation:MethodInvocation, ?base:Var)</li>
<li> .decl MethodInvocation_Line(?invocation:MethodInvocation, ?line:number)</li>
<li> .decl MethodInvocation_Method(?invocation:MethodInvocation, ?signature:Method)</li>
<li> .decl MethodTypeConstant_Arity(?heap:MethodTypeConstant, ?arity:number)</li>
<li> .decl MethodTypeConstant_ParamTypes(?heap:MethodTypeConstant, ?paramTypes:symbol)</li>
<li> .decl MethodTypeConstant_ReturnType(?heap:MethodTypeConstant, ?retType:Type)</li>
<li> .decl Method_Annotation(?method:Method, ?annotation:Annotation)</li>
<li> .decl Method_Arity(?method:Method, ?arity:number)</li>
<li> .decl Method_DeclaresException(?exceptionType:ReferenceType, ?method:Method)</li>
<li> .decl Method_DeclaringType(?method:Method, ?declaringType:ReferenceType)</li>
<li> .decl Method_Descriptor(?method:Method, ?descriptor:MethodDescriptor)</li>
<li> .decl Method_JVMDescriptor(?method:Method, ?descriptor:JVMDescriptor)</li>
<li> .decl Method_Modifier(?mod:Modifier, ?method:Method)</li>
<li> .decl Method_ParamTypes(?method:Method, ?params:symbol)</li>
<li> .decl Method_ReturnType(?method:Method, ?returnType:Type)</li>
<li> .decl Method_SimpleName(?method:Method, ?simpleName:symbol)</li>
<li> .decl Modifier_abstract(?mod:Modifier)</li>
<li> .decl Modifier_final(?mod:Modifier)</li>
<li> .decl Modifier_private(?mod:Modifier)</li>
<li> .decl Modifier_public(?mod:Modifier)</li>
<li> .decl Modifier_static(?mod:Modifier)</li>
<li> .decl NativeReturnVar(?var:Var, ?method:Method)</li>
<li> .decl OriginalHeapAllocation_Type(?heap:HeapAllocation, ?type:ReferenceType)</li>
<li> .decl Param_Annotation(?method:Method, ?index:number, ?annotation:Annotation)</li>
<li> .decl Properties(?path:StringConstant, ?key:StringConstant, ?value:StringConstant)</li>
<li> .decl ReturnNonvoid_Var(?return:ReturnNonvoid_Insn, ?var:Var)</li>
<li> .decl SpecialMethodInvocation_Base(?invocation:SpecialMethodInvocation_Insn, ?base:Var)</li>
<li> .decl SpecialMethodInvocation_Descriptor(?invocation:MethodInvocation, ?descriptor:MethodDescriptor)</li>
<li> .decl SpecialMethodInvocation_SimpleName(?invocation:MethodInvocation, ?simplename:symbol)</li>
<li> .decl StaticMethodInvocation_Descriptor(?invocation:MethodInvocation, ?descriptor:MethodDescriptor)</li>
<li> .decl StaticMethodInvocation_SimpleName(?invocation:MethodInvocation, ?simplename:symbol)</li>
<li> .decl Stats_Metrics(order:symbol, msg:symbol, c:number)</li>
<li> .decl StoreArrayIndex_Base(?insn:StoreArrayIndex_Insn, ?var:Var)</li>
<li> .decl StoreArrayIndex_From(?insn:StoreArrayIndex_Insn, ?var:Var)</li>
<li> .decl StoreInstanceField_Base(?insn:StoreInstanceField_Insn, ?var:Var)</li>
<li> .decl StoreInstanceField_From(?insn:StoreInstanceField_Insn, ?var:Var)</li>
<li> .decl StoreStaticField_From(?insn:StoreStaticField_Insn, ?var:Var)</li>
<li> .decl SuperMethodInvocation_Base(?invocation:SuperMethodInvocation_Insn, ?base:Var)</li>
<li> .decl SuperMethodInvocation_Descriptor(?invocation:MethodInvocation, ?descriptor:MethodDescriptor)</li>
<li> .decl SuperMethodInvocation_SimpleName(?invocation:MethodInvocation, ?simplename:symbol)</li>
<li> .decl Switch_DefaultTarget(?insn:Switch_Insn, ?index:number)</li>
<li> .decl Switch_Key(?insn:Switch_Insn, ?key:Var)</li>
<li> .decl Switch_Target(?insn:Switch_Insn, ?value:number, ?index:number)</li>
<li> .decl ThisVar(?method:Method, ?var:Var)</li>
<li> .decl Throw_Var(?insn:Throw_Insn, ?var:Var)</li>
<li> .decl Type_Annotation(?type:ReferenceType, ?annotation:Annotation)</li>
<li> .decl Type_boolean(?t:PrimitiveType)</li>
<li> .decl Type_byte(?t:PrimitiveType)</li>
<li> .decl Type_char(?t:PrimitiveType)</li>
<li> .decl Type_double(?t:PrimitiveType)</li>
<li> .decl Type_float(?t:PrimitiveType)</li>
<li> .decl Type_int(?t:PrimitiveType)</li>
<li> .decl Type_long(?t:PrimitiveType)</li>
<li> .decl Type_null(?t:NullType)</li>
<li> .decl Type_object(?t:ReferenceType)</li>
<li> .decl Type_short(?t:PrimitiveType)</li>
<li> .decl Type_void(?t:Type)</li>
<li> .decl Var_DeclaringMethod(?var:Var, ?method:Method)</li>
<li> .decl Var_SimpleName(?var:Var, ?simplename:symbol)</li>
<li> .decl Var_Type(?var:Var, ?type:Type)</li>
<li> .decl VirtualMethodInvocation_Base(?invocation:VirtualMethodInvocation_Insn, ?base:Var)</li>
<li> .decl VirtualMethodInvocation_Descriptor(?invocation:MethodInvocation, ?descriptor:MethodDescriptor)</li>
<li> .decl VirtualMethodInvocation_SimpleName(?invocation:MethodInvocation, ?simplename:symbol)</li>
<li> .decl isAnnotation(?a:Annotation)</li>
<li> .decl isArrayInstruction(?insn:ArrayInstruction)</li>
<li> .decl isArrayType(?t:ArrayType)</li>
<li> .decl isAssignBinop_Insn(?insn:AssignBinop_Insn)</li>
<li> .decl isAssignCastNull_Insn(?insn:AssignCastNull_Insn)</li>
<li> .decl isAssignCastNumConstant_Insn(?insn:AssignCastNumConstant_Insn)</li>
<li> .decl isAssignCast_Insn(?insn:AssignCast_Insn)</li>
<li> .decl isAssignHeapAllocation_Insn(?insn:AssignHeapAllocation_Insn)</li>
<li> .decl isAssignInstanceOf_Insn(?insn:AssignInstanceOf_Insn)</li>
<li> .decl isAssignInstruction(?insn:AssignInstruction)</li>
<li> .decl isAssignLocal_Insn(?insn:AssignLocal_Insn)</li>
<li> .decl isAssignNull_Insn(?insn:AssignNull_Insn)</li>
<li> .decl isAssignNumConstant_Insn(?insn:AssignNumConstant_Insn)</li>
<li> .decl isAssignOper_Insn(?insn:AssignOper_Insn)</li>
<li> .decl isAssignPhantomInvoke(?insn:AssignPhantomInvoke)</li>
<li> .decl isAssignUnop_Insn(?insn:AssignUnop_Insn)</li>
<li> .decl isBreakpointStmt(?insn:BreakpointStmt)</li>
<li> .decl isClassHeap(?h:ClassHeap)</li>
<li> .decl isClassType(?t:ClassType)</li>
<li> .decl isDynamicMethodInvocation_Insn(?insn:DynamicMethodInvocation_Insn)</li>
<li> .decl isEnterMonitor_Insn(?insn:EnterMonitor_Insn)</li>
<li> .decl isExceptionHandler(?handler:ExceptionHandler)</li>
<li> .decl isExitMonitor_Insn(?insn:ExitMonitor_Insn)</li>
<li> .decl isField(?field:Field)</li>
<li> .decl isFieldInstruction(?insn:FieldInstruction)</li>
<li> .decl isGoto_Insn(?insn:Goto_Insn)</li>
<li> .decl isHeapAllocation(?h:HeapAllocation)</li>
<li> .decl isIf_Insn(?insn:If_Insn)</li>
<li> .decl isInstruction(?insn:Instruction)</li>
<li> .decl isIntegerType(?type:Type)</li>
<li> .decl isInterfaceType(?t:InterfaceType)</li>
<li> .decl isJVMDescriptor(?jvmd:JVMDescriptor)</li>
<li> .decl isLoadArrayIndex_Insn(?insn:LoadArrayIndex_Insn)</li>
<li> .decl isLoadInstanceField_Insn(?insn:LoadInstanceField_Insn)</li>
<li> .decl isLoadStaticField_Insn(?insn:LoadStaticField_Insn)</li>
<li> .decl isLookupSwitch_Insn(?insn:LookupSwitch_Insn)</li>
<li> .decl isMethod(?m:Method)</li>
<li> .decl isMethodDescriptor(?md:MethodDescriptor)</li>
<li> .decl isMethodHandleConstant(?h:MethodHandleConstant)</li>
<li> .decl isMethodInvocation(?insn:MethodInvocation)</li>
<li> .decl isMethodTypeConstant(?h:MethodTypeConstant)</li>
<li> .decl isModifier(?m:Modifier)</li>
<li> .decl isMonitorInstruction(?insn:MonitorInstruction)</li>
<li> .decl isNormalHeap(?h:NormalHeap)</li>
<li> .decl isNullType(?t:ReferenceType)</li>
<li> .decl isNumConstant(?n:NumConstant)</li>
<li> .decl isOpaqueMethod(?m:Method)</li>
<li> .decl isPrimitiveType(?t:PrimitiveType)</li>
<li> .decl isReferenceType(?t:ReferenceType)</li>
<li> .decl isReturnInstruction(?insn:ReturnInstruction)</li>
<li> .decl isReturnNonvoid_Insn(?insn:ReturnNonvoid_Insn)</li>
<li> .decl isReturnVoid_Insn(?insn:ReturnVoid_Insn)</li>
<li> .decl isSpecialMethodInvocation_Insn(?insn:SpecialMethodInvocation_Insn)</li>
<li> .decl isStaticMethodInvocation_Insn(?insn:StaticMethodInvocation_Insn)</li>
<li> .decl isStoreArrayIndex_Insn(?insn:StoreArrayIndex_Insn)</li>
<li> .decl isStoreInstanceField_Insn(?insn:StoreInstanceField_Insn)</li>
<li> .decl isStoreStaticField_Insn(?insn:StoreStaticField_Insn)</li>
<li> .decl isStringConstant(?h:StringConstant)</li>
<li> .decl isStringRaw(?id:symbol)</li>
<li> .decl isSuperMethodInvocation_Insn(?insn:SuperMethodInvocation_Insn)</li>
<li> .decl isSwitch_Insn(?insn:Switch_Insn)</li>
<li> .decl isTableSwitch_Insn(?insn:TableSwitch_Insn)</li>
<li> .decl isThrowNull_Insn(?insn:ThrowNull_Insn)</li>
<li> .decl isThrow_Insn(?insn:Throw_Insn)</li>
<li> .decl isType(?t:Type)</li>
<li> .decl isUnsupportedInstruction(?insn:UnsupportedInstruction)</li>
<li> .decl isValue(?value:Value)</li>
<li> .decl isVar(v:Var)</li>
<li> .decl isVirtualMethodInvocation_Insn(?insn:VirtualMethodInvocation_Insn)</li>
</ul>
<h2> facts/generics.dl </h2>
<ul>
<li> .decl GenericField_DeclaringType(?field:Field, ?declaringClass:ClassType)</li>
<li> .decl GenericField_SimpleName(?field:Field, ?simpleName:symbol)</li>
<li> .decl GenericField_Type(?field:Field, ?type:Type)</li>
<li> .decl GenericTypeParameters(?type:symbol, ?index:number, ?genericParameter:symbol)</li>
<li> .decl GenericType_ErasedType(?genericType:symbol, ?erasedType:Type)</li>
<li> .decl _GenericField(?signature:symbol, ?declaringClass:symbol, ?simplename:symbol, ?type:symbol)</li>
<li> .decl isGenericField(?field:Field)</li>
</ul>
<h2> facts/import-dynamic-facts.dl </h2>
<ul>
<li> .decl DynamicAppCallGraphEdgeFromNative(?toMethod:Method, ?fromMethod:Method)</li>
<li> .decl DynamicAppNativeCodeTarget(?toMethod:Method)</li>
<li> .decl DynamicArrayIndexPointsTo(?ctx:DynamicContext, ?heap:HeapAllocation, ?baseCtx:DynamicContext, ?baseHeap:HeapAllocation)</li>
<li> .decl DynamicCallGraphEdge(?ctxTo:DynamicContext, ?toMethod:Method, ?invocation:Instruction, ?ctxFrom:DynamicContext, ?fromMethod:Method)</li>
<li> .decl DynamicCallGraphEdgeFromNative(?toMethod:Method, ?fromMethod:Method)</li>
<li> .decl DynamicContextHeap1(?heap:HeapAllocation, ?ctx:DynamicContext)</li>
<li> .decl DynamicContextHeap2(?heap:HeapAllocation, ?ctx:DynamicContext)</li>
<li> .decl DynamicHeapAllocation(?representation:symbol, ?heap:HeapAllocation)</li>
<li> .decl DynamicHeapId(?heap:symbol)</li>
<li> .decl DynamicHeapObject(?representation:symbol, ?heap:HeapAllocation, ?dynamicContext:DynamicContext)</li>
<li> .decl DynamicInstanceFieldPointsTo(?fld:Field, ?ctx:DynamicContext, ?heap:HeapAllocation, ?baseCtx:DynamicContext, ?baseHeap:HeapAllocation)</li>
<li> .decl DynamicNativeCodeTarget(?toMethod:Method)</li>
<li> .decl DynamicReachableMethod(?method:Method)</li>
<li> .decl DynamicStaticFieldPointsTo(?fld:Field, ?dynamicContext:DynamicContext, ?heap:HeapAllocation)</li>
<li> .decl DynamicVarPointsTo(?hctx: mainAnalysis.configuration.HContext, ?heap: HeapAllocation, ?ctx: DynamicContext, ?var: Var)</li>
<li> .decl NotSingletonDynamicHeapAllocation(?param4:symbol)</li>
<li> .decl ReconstructedUnmatchedDynamicHeapAllocation(?representation:symbol, ?heap:HeapAllocation)</li>
<li> .decl UnmatchedDynamicNormalHeapAllocation(?type:Type, ?representation:symbol, ?linenumber:number, ?inMethod:Method)</li>
<li> .decl UnmatchedDynamicReachableMethod(?param:symbol)</li>
<li> .decl UnmatchedStaticNormalHeapAllocation(?method:Method, ?lineNumber:number, ?type:Type)</li>
<li> .decl _DynamicArrayIndexPointsTo(?param1:symbol, ?param2:symbol)</li>
<li> .decl _DynamicCallGraphEdge(?param1:symbol, ?param2:number, ?param3:symbol, ?param4:symbol, ?param5:symbol)</li>
<li> .decl _DynamicContext(?representation:symbol, ?heap1rep:symbol, ?heap2rep:symbol, ?site1inMeth:symbol, ?site1line:number, ?site2inMeth:symbol, ?site2line:number)</li>
<li> .decl _DynamicInstanceFieldPointsTo(?param1:symbol, ?param2:symbol, ?param3:symbol, ?param4:symbol)</li>
<li> .decl _DynamicNormalHeapAllocation(?param1:number, ?param2:symbol, ?param3:symbol, ?param4:symbol)</li>
<li> .decl _DynamicNormalHeapObject(?param1:symbol, ?param2:symbol, ?param3:symbol)</li>
<li> .decl _DynamicReachableMethod(?param1:symbol)</li>
<li> .decl _DynamicStaticFieldPointsTo(?param1:symbol, ?param2:symbol, ?param3:symbol)</li>
<li> .decl _DynamicVarPointsTo(?hctx: symbol, ?heap: symbol, ?ctx: symbol, ?var: symbol)</li>
<li> .decl _HeapAllocationInformation(?lineNumber:number, ?method:Method, ?type:Type, ?heap:HeapAllocation)</li>
<li> .decl _InvocationMethodAndLine(?lineNumber:number, ?name:symbol, ?invocation:Instruction, ?fromMethod:Method)</li>
<li> .decl _MatchedHeapAllocation0(?representation:symbol, ?heap:HeapAllocation)</li>
<li> .decl _MatchedHeapAllocation1(?representation:symbol, ?heap:HeapAllocation)</li>
<li> .decl _MatchedHeapAllocation2(?representation:symbol, ?heap:HeapAllocation)</li>
<li> .decl _UnmatchedDynamicNormalHeapAllocation1(?inMethod:Method, ?type:Type, ?representation:symbol)</li>
<li> .decl isDynamicContext(?ctx:DynamicContext)</li>
</ul>
<h2> facts/imports.dl </h2>
<ul>
<li> .decl CreateIntValue(?n:symbol, ?declaringType:ReferenceType)</li>
<li> .decl NumConstantRawInt(?const:symbol)</li>
<li> .decl PhantomBasedMethod(?m:Method)</li>
<li> .decl PhantomMethod(?m:Method)</li>
<li> .decl PhantomType(?t:ReferenceType)</li>
<li> .decl String_toRaw(?id:symbol, ?rawId:symbol)</li>
<li> .decl XMLNode(?file:symbol, ?nodeId:symbol, ?parentNodeId:symbol, ?namespaceURI:symbol, ?localName:symbol, ?qName:symbol)</li>
<li> .decl XMLNodeAttribute(?file:symbol, ?nodeId:symbol, ?index:symbol, ?localName:symbol, ?qName:symbol, ?value:symbol)</li>
<li> .decl XMLNodeData(?file:symbol, ?nodeId:symbol, ?data:symbol)</li>
<li> .decl _ActualParam(?index:number, ?invocation:MethodInvocation, ?var:Var)</li>
<li> .decl _ApplicationClass(?type:ReferenceType)</li>
<li> .decl _ApplicationPackage(?package:symbol)</li>
<li> .decl _ArrayAllocation(?instruction:Instruction, ?pos:number, ?sizeVar:Var)</li>
<li> .decl _ArrayInsnIndex(?instruction:Instruction, ?index:Var)</li>
<li> .decl _ArrayNumIndex(?instruction:Instruction, ?index:number)</li>
<li> .decl _ArrayType(?arrayType:ArrayType)</li>
<li> .decl _AssignBinop(?instruction:AssignBinop_Insn, ?index:number, ?to:Var, ?inmethod:Method)</li>
<li> .decl _AssignCast(?instruction:AssignCast_Insn, ?index:number, ?from:Var, ?to:Var, ?type:Type, ?inmethod:Method)</li>
<li> .decl _AssignCastNull(?instruction:AssignCastNull_Insn, ?index:number, ?to:Var, ?type:Type, ?method:Method)</li>
<li> .decl _AssignCastNumConstant(?instruction:AssignCastNumConstant_Insn, ?index:number, ?const:symbol, ?to:Var, ?type:Type, ?inmethod:Method)</li>
<li> .decl _AssignHeapAllocation(?instruction:AssignHeapAllocation_Insn, ?index:number, ?heap:HeapAllocation, ?to:Var, ?inmethod:Method, ?linenumber:number)</li>
<li> .decl _AssignInstanceOf(?instruction:AssignInstanceOf_Insn, ?index:number, ?from:Var, ?to:Var, ?type:Type, ?inmethod:Method)</li>
<li> .decl _AssignLocal(?instruction:AssignLocal_Insn, ?index:number, ?from:Var, ?to:Var, ?inmethod:Method)</li>
<li> .decl _AssignNull(?instruction:AssignNull_Insn, ?index:number, ?to:Var, ?method:Method)</li>
<li> .decl _AssignNumConstant(?instruction:AssignNumConstant_Insn, ?index:number, ?const:NumConstant, ?to:Var, ?inmethod:Method)</li>
<li> .decl _AssignOperFrom(?instruction:AssignOper_Insn, ?pos: number, ?from:Var)</li>
<li> .decl _AssignOperFromConstant(?instruction:AssignOper_Insn, ?pos: number, ?from:NumConstant)</li>
<li> .decl _AssignPhantomInvoke(?instruction:AssignPhantomInvoke, ?index:number, ?method:Method)</li>
<li> .decl _AssignReturnValue(?invocation:MethodInvocation, ?to:Var)</li>
<li> .decl _AssignUnop(?instruction:AssignUnop_Insn, ?index:number, ?to:Var, ?inmethod:Method)</li>
<li> .decl _BootstrapParam(?index:number, ?invocation:MethodInvocation, ?var:Var)</li>
<li> .decl _BreakpointStmt(?instruction:BreakpointStmt, ?index:number, ?method:Method)</li>
<li> .decl _ClassArtifact(?artifact:symbol, ?className:ReferenceType, ?subArtifact:symbol, ?size:number)</li>
<li> .decl _ClassHeap(?id:ClassHeap, ?instanceType:ReferenceType)</li>
<li> .decl _ClassModifier(?modifier:Modifier, ?class:ReferenceType)</li>
<li> .decl _ClassType(?class:ClassType)</li>
<li> .decl _ComponentType(?arrayType:ArrayType, ?componentType:Type)</li>
<li> .decl _DirectSuperclass(?class:ClassType, ?superclass:ClassType)</li>
<li> .decl _DirectSuperinterface(?class:ReferenceType, ?interface:InterfaceType)</li>
<li> .decl _DummyIfVar(?instruction:If_Insn, ?var:Var)</li>
<li> .decl _DynamicMethodInvocation(?instruction:DynamicMethodInvocation_Insn, ?index:number, ?bootSignature:Method, ?dynName:symbol, ?dynRetType:Type, ?dynArity:number, ?dynParamTypes:symbol, ?tag:number, ?method:Method)</li>
<li> .decl _DynamicMethodInvocation_DynParamType(?invocation:DynamicMethodInvocation_Insn, ?idx:number, ?pType:Type)</li>
<li> .decl _EmptyArray(?id:HeapAllocation)</li>
<li> .decl _EnterMonitor(?instruction:EnterMonitor_Insn, ?index:number, ?var:Var, ?method:Method)</li>
<li> .decl _ExceptionHandler(?handler:ExceptionHandler, ?method:Method, ?index:number, ?type:ReferenceType, ?begin:number, ?end:number)</li>
<li> .decl _ExceptionHandler_Previous(?handler:ExceptionHandler, ?previous:ExceptionHandler)</li>
<li> .decl _ExitMonitor(?instruction:ExitMonitor_Insn, ?index:number, ?var:Var, ?method:Method)</li>
<li> .decl _Field(?signature:Field, ?declaringClass:ReferenceType, ?simplename:symbol, ?type:Type)</li>
<li> .decl _Field_Modifier(?modifier:Modifier, ?field:Field)</li>
<li> .decl _FormalParam(?index:number, ?method:Method, ?var:Var)</li>
<li> .decl _Goto(?instruction:Goto_Insn, ?index:number, ?to:number, ?method:Method)</li>
<li> .decl _If(?instruction:If_Insn, ?index:number, ?to:number, ?method:Method)</li>
<li> .decl _IfConstant(?instruction:If_Insn, ?pos:number, ?cons:NumConstant)</li>
<li> .decl _IfVar(?instruction:If_Insn, ?pos:number, ?var:Var)</li>
<li> .decl _InterfaceType(?interface:InterfaceType)</li>
<li> .decl _LoadArrayIndex(?instruction:LoadArrayIndex_Insn, ?index:number, ?to:Var, ?base:Var, ?method:Method)</li>
<li> .decl _LoadInstanceField(?instruction:LoadInstanceField_Insn, ?index:number, ?to:Var, ?base:Var, ?signature:Field, ?method:Method)</li>
<li> .decl _LoadStaticField(?instruction:LoadStaticField_Insn, ?index:number, ?to:Var, ?signature:Field, ?method:Method)</li>
<li> .decl _LookupSwitch(?instruction:LookupSwitch_Insn, ?index:number, ?key:Var, ?method:Method)</li>
<li> .decl _LookupSwitch_DefaultTarget(?instruction:Switch_Insn, ?target:number)</li>
<li> .decl _LookupSwitch_Target(?instruction:Switch_Insn, ?value:number, ?target:number)</li>
<li> .decl _Method(?method:Method, ?simplename:symbol, ?descriptor:symbol, ?declaringType:ReferenceType, ?returnType:Type, ?jvmDescriptor:JVMDescriptor, ?arity:number)</li>
<li> .decl _MethodHandleConstant(?id:MethodHandleConstant, ?method:Method, ?retType:Type, ?paramTypes:symbol, ?arity:number)</li>
<li> .decl _MethodInvocation_Line(?instruction:MethodInvocation, line:number)</li>
<li> .decl _MethodTypeConstant(?id:MethodTypeConstant, ?arity:number, ?retType:Type, ?paramTypes:symbol)</li>
<li> .decl _MethodTypeConstantParam(?id:MethodTypeConstant, ?idx:number, ?type:Type)</li>
<li> .decl _Method_DeclaresException(?exceptionType:ReferenceType, ?method:Method)</li>
<li> .decl _Method_Modifier(?mod:Modifier, ?method:Method)</li>
<li> .decl _NativeLibEntryPoint(?lib:symbol, ?function:symbol, ?addr:symbol)</li>
<li> .decl _NativeMethodId(?javaMethod:Method, ?nativeId:symbol)</li>
<li> .decl _NativeMethodTypeCandidate(?lib:symbol, ?function:symbol, ?descriptor:symbol, ?offset2:number)</li>
<li> .decl _NativeNameCandidate(?lib:symbol, ?function:symbol, ?name:symbol, ?offset1:number)</li>
<li> .decl _NativeReturnVar(?var:Var, ?method:Method)</li>
<li> .decl _NativeXRef(?string:symbol, ?lib:symbol, ?function:symbol, ?dataAddr:number)</li>
<li> .decl _NormalHeap(?id:NormalHeap, ?type:ReferenceType)</li>
<li> .decl _OperatorAt(?instruction:Instruction, ?operator:symbol)</li>
<li> .decl _PolymorphicInvocation(?invocation:MethodInvocation, ?simpleName:symbol)</li>
<li> .decl _Return(?instruction:ReturnNonvoid_Insn, ?index:number, ?var:Var, ?method:Method)</li>
<li> .decl _ReturnVoid(?instruction:ReturnVoid_Insn, ?index:number, ?method:Method)</li>
<li> .decl _SpecialMethodInvocation(?instruction:SpecialMethodInvocation_Insn, ?index:number, ?signature:Method, ?base:Var, ?method:Method)</li>
<li> .decl _StaticMethodInvocation(?instruction:StaticMethodInvocation_Insn, ?index:number, ?signature:Method, ?method:Method)</li>
<li> .decl _StoreArrayIndex(?instruction:StoreArrayIndex_Insn, ?index:number, ?from:Var, ?base:Var, ?method:Method)</li>
<li> .decl _StoreInstanceField(?instruction:StoreInstanceField_Insn, ?index:number, ?from:Var, ?base:Var, ?signature:Field, ?method:Method)</li>
<li> .decl _StoreStaticField(?instruction:StoreStaticField_Insn, ?index:number, ?from:Var, ?signature:Field, ?method:Method)</li>
<li> .decl _StringConstant(?id:StringConstant)</li>
<li> .decl _StringRaw(?id:symbol, ?rawId:symbol)</li>
<li> .decl _SuperMethodInvocation(?instruction:SuperMethodInvocation_Insn, ?index:number, ?signature:Method, ?base:Var, ?method:Method)</li>
<li> .decl _TableSwitch(?instruction:TableSwitch_Insn, ?index:number, ?key:Var, ?method:Method)</li>
<li> .decl _TableSwitch_DefaultTarget(?instruction:Switch_Insn, ?target:number)</li>
<li> .decl _TableSwitch_Target(?instruction:Switch_Insn, ?value:number, ?target:number)</li>
<li> .decl _ThisVar(?method:Method, ?var:Var)</li>
<li> .decl _Throw(?instruction:Throw_Insn, ?index:number, ?var:Var, ?method:Method)</li>
<li> .decl _ThrowNull(?instruction:ThrowNull_Insn, ?index:number, ?method:Method)</li>
<li> .decl _UnsupportedInstruction(?instruction:UnsupportedInstruction, ?index:number, ?method:Method)</li>
<li> .decl _Var_DeclaringMethod(?var:Var, ?method:Method)</li>
<li> .decl _Var_SimpleName(?var:Var, ?simplename:symbol)</li>
<li> .decl _Var_Type(?var:Var, ?type:Type)</li>
<li> .decl _VirtualMethodInvocation(?instruction:VirtualMethodInvocation_Insn, ?index:number, ?signature:Method, ?base:Var, ?method:Method)</li>
</ul>
<h2> facts/keep.dl </h2>
<ul>
<li> .decl KeepClass(?c:ReferenceType)</li>
<li> .decl KeepClassMembers(?m:Method)</li>
<li> .decl KeepClassesWithMembers(?m:Method)</li>
<li> .decl KeepMethod(?m:Method)</li>
<li> .decl RootCodeElement(?id:symbol)</li>
</ul>
<h2> facts/opaque-methods.dl </h2>
<ul>
<li> .decl ClassLoaderMethod(?method:Method, ?argIdx:number)</li>
<li> .decl MTEntryPoint(?id:number, ?invo:MethodInvocation, ?sig:Method)</li>
<li> .decl isOpaqueInstruction(?insn:OpaqueInstruction)</li>
</ul>
<h2> main/android-declarations.dl </h2>
<ul>
<li> .decl AndroidAppComponent(?type:symbol)</li>
<li> .decl AndroidApplicationClass(?class:ReferenceType)</li>
<li> .decl AndroidApplicationListenerClass(?class:ClassType)</li>
<li> .decl AndroidCallbackMethod(?method:Method, ?type:ReferenceType)</li>
<li> .decl AndroidLibraryListenerType(?type:ReferenceType)</li>
<li> .decl AndroidLibraryType(?type:ReferenceType)</li>
<li> .decl AndroidViewType(?type:ReferenceType)</li>
<li> .decl AppMethodOverridesAndroidLibraryMethod(?meth:Method, ?concreteMeth:Method)</li>
<li> .decl ApplicationObjectFlowingToLibrary(?hctx:configuration.HContext, ?value:Value, ?ofType:Type)</li>
<li> .decl ForcedReachableAndroidContext(?ctx:configuration.Context, ?meth:Method)</li>
<li> .decl FormalOfForcedReachableAndroidContext(?ctx:configuration.Context, ?formal:Var, ?formalType:Type)</li>
<li> .decl FragmentRetrievalByArg0MethodInvocation(?invo:MethodInvocation)</li>
<li> .decl ImplicitlyInstantiatedLibraryType(?type:ReferenceType)</li>
<li> .decl LayoutControlObjectValueFromId(?controlValue:Value, ?numId:symbol)</li>
<li> .decl LibraryReachableAppListenerType(?type:ReferenceType)</li>
<li> .decl ListenerType(?type:ReferenceType)</li>
<li> .decl MultiDimensionalArrayTemp(?value:Value, ?invocation:MethodInvocation, ?type:Type, ?ctx:configuration.Context, ?from:Var)</li>
<li> .decl OverridingProtectedMethodOfComponent(?meth:Method)</li>
<li> .decl OverridingProtectedOnMethodOfLayoutControl(?meth:Method)</li>
<li> .decl OverridingProtectedOnMethodOfReachableListener(?meth:Method)</li>
<li> .decl ProtectedMethodOfComponent(?meth:Method)</li>
<li> .decl ProtectedOnMethodOfLayoutControl(?meth:Method)</li>
<li> .decl ProtectedOnMethodOfReachableListener(?meth:Method)</li>
<li> .decl PublicMethodOfComponent(?meth:Method)</li>
<li> .decl PublicOnMethodOfLayoutControl(?meth:Method)</li>
<li> .decl PublicOnMethodOfReachableListener(?meth:Method)</li>
<li> .decl ReachableApplicationObjectOfType(?hctx:configuration.HContext, ?value:Value, ?type:Type)</li>
<li> .decl ReifiedAndroidObjectValue(?value:Value, ?type:ReferenceType)</li>
<li> .decl ReifiedComponent(?type:ReferenceType, ?value:Value)</li>
<li> .decl ReifiedLayoutControl(?type:ReferenceType, ?id:symbol, ?value:Value)</li>
<li> .decl ReifiedLibraryObject(?type:ReferenceType, ?value:Value)</li>
<li> .decl SensitiveLayoutControlValue(?value:Value)</li>
<li> .decl TypeHasApplicationObjectFlowingToLibrary(?ofType:Type)</li>
<li> .decl TypeHasReachableApplicationObject(?type:Type)</li>
<li> .decl UninitializedArray(?hctx:configuration.HContext, ?value:Value, ?invocation:MethodInvocation, ?type:Type)</li>
<li> .decl VarsAtInvocationRetrievingLayoutControl(?ret:Var, ?var:Var)</li>
<li> .decl ViewRetrievalByArg0MethodInvocation(?invo:MethodInvocation)</li>
<li> .decl WebClientType(?type:Type)</li>
</ul>
<h2> main/android-xml.dl </h2>
<ul>
<li> .decl ActionViewType(?class:ClassType)</li>
<li> .decl Activity_Alias(?activity:ClassType, ?alias:symbol)</li>
<li> .decl Activity_Parent(?type:ClassType, ?parentActivity:ClassType)</li>
<li> .decl ApplicationPackage(?package:symbol)</li>
<li> .decl DisabledActivity(?activityType:ReferenceType)</li>
<li> .decl LauncherActivity(?type:ClassType)</li>
<li> .decl LayoutBehavior(?class:ClassType)</li>
<li> .decl LayoutControl_CallbackMethod(?controlId:symbol, ?method:symbol)</li>
<li> .decl XMLAndroidId(?file:symbol, ?nodeId:symbol, ?parentId:symbol, ?category:symbol, ?id:symbol, ?qClass:ClassType)</li>
<li> .decl XMLAndroidPasswordControl(?file:symbol, ?nodeId: symbol)</li>
<li> .decl XMLFragment_Class(?file:symbol, ?nodeId:symbol, ?qClass:ClassType)</li>
<li> .decl XMLFragment_Id(?file:symbol, ?nodeId:symbol, ?id:symbol)</li>
<li> .decl XMLNode_Id(?file:symbol, ?nodeId:symbol, ?name:symbol, ?value:symbol)</li>
<li> .decl XMLNode_Parent(?file:symbol, ?nodeId:symbol, ?parentFile:symbol, ?parentNodeId:symbol)</li>
</ul>
<h2> main/android.dl </h2>
<ul>
<li> .decl ActivityVar(?var:Var)</li>
<li> .decl ActivityVarInType(?var:Var, ?ctx:configuration.Context, ?type:Type)</li>
<li> .decl AndroidApplicationPackableClass(?class:ClassType)</li>
<li> .decl AndroidApplicationValue(?value:Value, ?ofType:Type)</li>
<li> .decl AndroidLibraryVar(?var:Var)</li>
<li> .decl AndroidOriginalAppComponent(?type:ReferenceType)</li>
<li> .decl AndroidPackableType(?type:ReferenceType)</li>
<li> .decl AndroidReachableLibraryVarOfType(?var:Var, ?varType:Type)</li>
<li> .decl AppClassSubtypesLibClass(?type:ReferenceType, ?libType:ReferenceType)</li>
<li> .decl AppInvoReturningLibraryPackable(?invo:Instruction, ?retType:ReferenceType)</li>
<li> .decl ApplicationPackageRegex(?regex:symbol)</li>
<li> .decl ArgToAddJavascriptInterface(?var:Var)</li>
<li> .decl AsynchTaskExecute(?param:Var, ?base:Var)</li>
<li> .decl BindFragment(?activityThis:Var, ?fragmentParam:Var)</li>
<li> .decl ForcedReachableAndroidClass(?ctx:configuration.Context, ?type:ReferenceType)</li>
<li> .decl ForcedReachableFromJavascriptContext(?ctx:configuration.Context, ?meth:Method)</li>
<li> .decl LibraryMethodReturningPackable(?method:Method, ?retType:ReferenceType)</li>
<li> .decl LibraryReachableAppPackableClass(?class:ClassType)</li>
<li> .decl ListenerClassConstantValue(?classHeap:Value, ?type:ReferenceType)</li>
<li> .decl LookupReturnsAppMethod(?simplename:symbol, ?descriptor:MethodDescriptor, ?type:ReferenceType, ?method:Method)</li>
<li> .decl NonPrivateConcreteMethodOfComponent(?meth:Method)</li>
<li> .decl ObfuscatedApplicationClass(?type:ReferenceType)</li>
<li> .decl ObfuscationOn()</li>
<li> .decl OnEventMethod(?meth:Method)</li>
<li> .decl ReachableAppPackableMethodOverridingLib(?methConcrete:Method)</li>
<li> .decl ReachableLayoutControl(?type:ReferenceType)</li>
<li> .decl RegisterBroadCastReceiverVar(?var:Var)</li>
<li> .decl ReifiedApplicationAndCompatibleVar(?value:Value, ?var:Var)</li>
<li> .decl SpecialMissingPackableValue(?invocation:MethodInvocation, ?value:Value)</li>
<li> .decl UnobfuscatedApplicationClass(?type:ReferenceType)</li>
<li> .decl UnobfuscatedMethod(?meth:Method)</li>
<li> .decl XMLLayoutControl(?file:symbol, ?nodeId:symbol, ?id:symbol)</li>
<li> .decl _NotMostRefinedType(?type:ReferenceType)</li>
</ul>
<h2> main/api-mocking.dl </h2>
<ul>
<li> .decl GetSystemServiceMethod(?method:Method)</li>
<li> .decl MockedMethodReturns(?method:Method, ?alloc:HeapAllocation, ?type:ReferenceType)</li>
<li> .decl SystemService(?type:ReferenceType)</li>
</ul>
<h2> main/basic-context-sensitivity.dl </h2>
<ul>
<li> .decl ZipperPrecisionCriticalMethod(?method:Method)</li>
</ul>
<h2> main/class-initialization-declarations.dl </h2>
<ul>
<li> .decl ClassInitializer(?type:Type, ?method:Method)</li>
<li> .decl InitializedClass(?classOrInterface:Type)</li>
</ul>
<h2> main/configuration.dl </h2>
<ul>
<li> .decl ContextRequest(?ctx:configuration.Context, ?hctx:configuration.HContext, ?invo:MethodInvocation, ?value:Value, ?method:Method, ?createCGE:number)</li>
<li> .decl ContextResponse(?callerCtx:configuration.Context, ?hctx:configuration.HContext, ?invo:MethodInvocation, ?value:Value, ?method:Method, ?calleeCtx:Context)</li>
<li> .decl InitContextRequest(?symbol:symbol)</li>
<li> .decl InitContextResponse(?symbol:symbol, ?context:Context)</li>
<li> .decl InitHContextRequest(?symbol:symbol)</li>
<li> .decl InitHContextResponse(?symbol:symbol, ?hcontext:HContext)</li>
<li> .decl RecordContextRequest(?callerCtx:configuration.Context, ?value:Value, ?var:Var)</li>
<li> .decl RecordContextResponse(?callerCtx:configuration.Context, ?value:Value, ?var:Var, ?hctx:configuration.HContext)</li>
<li> .decl StaticContextRequest(?ctx:configuration.Context, ?invo:MethodInvocation)</li>
<li> .decl StaticContextResponse(?callerCtx:configuration.Context, ?invo:MethodInvocation, ?calleeCtx:Context)</li>
</ul>
<h2> main/context-sensitivity-declarations.dl </h2>
<ul>
<li> .decl ArrayIndexPointsTo(?hctx:configuration.HContext, ?value:Value, ?basehctx:configuration.HContext, ?basevalue:Value)</li>
<li> .decl CallGraphEdge(?callerCtx:configuration.Context, ?invocation:MethodInvocation, ?calleeCtx:configuration.Context, ?method:Method)</li>
<li> .decl CollectionAcceptsValueFallbackType(?mapValue:Value, ?type:Type)</li>
<li> .decl CollectionAcceptsValueType(?value:Value, ?type:Type)</li>
<li> .decl HeapInterproceduralAssign(?toCtx:configuration.Context, ?to:Var, ?fromCtx:configuration.Context, ?from:Var)</li>
<li> .decl InstanceFieldPointsTo(?hctx:configuration.HContext, ?value:Value, ?sig:Field, ?basehctx:configuration.HContext, ?basevalue:Value)</li>
<li> .decl LoadHeapArrayIndex(?ctx:configuration.Context, ?to:Var, ?basehctx:configuration.HContext, ?basevalue:Value)</li>
<li> .decl LoadHeapInstanceField(?ctx:configuration.Context, ?to:Var, ?sig:Field, ?basehctx:configuration.HContext, ?basevalue:Value)</li>
<li> .decl MainThread(?hctx:configuration.HContext, ?value:Value)</li>
<li> .decl MainThreadGroup(?hctx:configuration.HContext, ?value:Value)</li>
<li> .decl MapAcceptsKeyFallbackType(?mapValue:Value, ?type:Type)</li>
<li> .decl MapAcceptsKeyType(?value:Value, ?type:Type)</li>
<li> .decl MapAcceptsValueFallbackType(?mapValue:Value, ?type:Type)</li>
<li> .decl MapAcceptsValueType(?value:Value, ?type:Type)</li>
<li> .decl OpaqueCallGraphEdge(?invocation:MethodInvocation, ?method:Method)</li>
<li> .decl OptArgAssign(?toCtx:configuration.Context, ?to:Var, ?fromCtx:configuration.Context, ?from:Var, ?allowedType:Type)</li>
<li> .decl OptArgVarPointsTo(?hctx:configuration.HContext, ?value:Value, ?ctx:configuration.Context, ?var:Var)</li>
<li> .decl OptInterproceduralAssign(?toCtx:configuration.Context, ?to:Var, ?fromCtx:configuration.Context, ?from:Var)</li>
<li> .decl OptLoadArrayIndex(?to:Var, ?base:Var)</li>
<li> .decl OptRetVarPointsTo(?hctx:configuration.HContext, ?value:Value, ?ctx:configuration.Context, ?var:Var)</li>
<li> .decl OptReturnAssign(?toCtx:configuration.Context, ?to:Var, ?fromCtx:configuration.Context, ?from:Var)</li>
<li> .decl OptStoreArrayIndex(?from:Var, ?base:Var)</li>
<li> .decl Reachable(?method:Method)</li>
<li> .decl ReachableContext(?ctx:configuration.Context, ?method:Method)</li>
<li> .decl StaticFieldPointsTo(?hctx:configuration.HContext, ?value:Value, ?sig:Field)</li>
<li> .decl StoreHeapArrayIndex(?basehctx:configuration.HContext, ?basevalue:Value, ?ctx:configuration.Context, ?from:Var)</li>
<li> .decl StoreHeapInstanceField(?sig:Field, ?basehctx:configuration.HContext, ?basevalue:Value, ?ctx:configuration.Context, ?from:Var)</li>
<li> .decl SystemThreadGroup(?hctx:configuration.HContext, ?value:Value)</li>
<li> .decl VarPointsTo(?hctx:configuration.HContext, ?value:Value, ?ctx:configuration.Context, ?var:Var)</li>
<li> .decl isClinitContext(?ctx:configuration.Context)</li>
<li> .decl isContext(?ctx:configuration.Context)</li>
<li> .decl isHContext(?hctx:configuration.HContext)</li>
<li> .decl isImmutableContext(?ctx:configuration.Context)</li>
<li> .decl isImmutableHContext(?hctx:configuration.HContext)</li>
<li> .decl isInitialContext(?ctx:configuration.Context)</li>
<li> .decl isJVMStartupContext(?ctx:configuration.Context)</li>
<li> .decl isJVMStartupHContext(?hctx:configuration.HContext)</li>
</ul>
<h2> main/context-sensitivity-variable-level.dl </h2>
<ul>
<li> .decl ConstructorVar(?var:Var)</li>
<li> .decl DuplicateContextRequest(?callerCtx:configuration.Context, ?hctx:configuration.HContext, ?invo:MethodInvocation, ?obj:Value, ?meth1:Method, ?meth2:Method)</li>
<li> .decl DuplicateContextResponse(?callerCtx:configuration.Context, ?hctx:configuration.HContext, ?invo:MethodInvocation, ?obj:Value, ?calleeCtx1:configuration.Context, ?calleeCtx2:configuration.Context)</li>
<li> .decl InsensitiveVar(?var:Var)</li>
<li> .decl NoInformationOnSignature(?signature: Field)</li>
<li> .decl NotEmptyArrayValue(?value:Value)</li>
<li> .decl OptAssignCast(?type:Type, ?to:Var, ?from:Var)</li>
<li> .decl OptLoadHeapArrayIndex(?var:Var, ?value:Value)</li>
<li> .decl OptSpecialMethodInvocationBase(?invocation:MethodInvocation, ?base:Var)</li>
<li> .decl OptStoreIntoArray(?hctx:configuration.HContext, ?value:Value, ?basehctx:configuration.HContext, ?basevalue:Value)</li>
<li> .decl OptSuperMethodInvocationBase(?invocation:MethodInvocation, ?base:Var)</li>
<li> .decl OptVirtualMethodInvocationBase(?invocation:MethodInvocation, ?base:Var)</li>
<li> .decl ReachableAnnotationMethod(?method:Method, ?annotation:Annotation)</li>
<li> .decl ReachableLoadArrayIndexBase(?base:Var)</li>
<li> .decl ReachableStoreArrayIndexBase(?base:Var)</li>
<li> .decl ReachableStoreStaticFieldFrom(?from:Var)</li>
<li> .decl ReachableValue(?hctx:configuration.HContext, ?value: Value)</li>
<li> .decl Temp1(?value:Value, ?var:Var)</li>
<li> .decl Temp2(?ctx:configuration.Context, ?var:Var, ?hctx:configuration.HContext, ?value:Value)</li>
<li> .decl TypeHasReachableValue(?valueType: Type)</li>
</ul>
<h2> main/context-sensitivity.dl </h2>
<ul>
<li> .decl AppReachable(?method:Method)</li>
<li> .decl ConstructorVar(?var:Var)</li>
<li> .decl DuplicateContextRequest(?callerCtx:configuration.Context, ?hctx:configuration.HContext, ?invo:MethodInvocation, ?obj:Value, ?meth1:Method, ?meth2:Method)</li>
<li> .decl DuplicateContextResponse(?callerCtx:configuration.Context, ?hctx:configuration.HContext, ?invo:MethodInvocation, ?obj:Value, ?calleeCtx1:configuration.Context, ?calleeCtx2:configuration.Context)</li>
<li> .decl NoInformationOnSignature(?signature: Field)</li>
<li> .decl NotEmptyArrayValue(?value:Value)</li>
<li> .decl OptAssignCast(?type:Type, ?to:Var, ?from:Var)</li>
<li> .decl OptLoadHeapArrayIndex(?var:Var, ?value:Value)</li>
<li> .decl OptSpecialMethodInvocationBase(?invocation:MethodInvocation, ?base:Var)</li>
<li> .decl OptStoreIntoArray(?hctx:configuration.HContext, ?value:Value, ?basehctx:configuration.HContext, ?basevalue:Value)</li>
<li> .decl OptSuperMethodInvocationBase(?invocation:MethodInvocation, ?base:Var)</li>
<li> .decl OptVirtualMethodInvocationBase(?invocation:MethodInvocation, ?base:Var)</li>
<li> .decl ReachableAnnotationMethod(?method:Method, ?annotation:Annotation)</li>
<li> .decl ReachableLoadArrayIndexBase(?base:Var)</li>
<li> .decl ReachableStoreArrayIndexBase(?base:Var)</li>
<li> .decl ReachableStoreStaticFieldFrom(?from:Var)</li>
<li> .decl ReachableValue(?hctx:configuration.HContext, ?value: Value)</li>
<li> .decl Temp1(?value:Value, ?var:Var)</li>
<li> .decl Temp2(?ctx:configuration.Context, ?var:Var, ?hctx:configuration.HContext, ?value:Value)</li>
<li> .decl TypeHasReachableValue(?valueType: Type)</li>
<li> .decl isCollectionAddMethod(?method:Method)</li>
<li> .decl isMapPutMethod(?method:Method)</li>
</ul>
<h2> main/dynamicanalysis.dl </h2>
<ul>
<li> .decl AllDynamicallyReachableMethod(?method:Method)</li>
<li> .decl DynamicContextToContext(?ctx:configuration.Context, ?dctx:DynamicContext)</li>
<li> .decl DynamicContextToHContext(?hctx:configuration.HContext, ?dctx:DynamicContext)</li>
<li> .decl ForcedImplicitReachable(?method:Method)</li>
<li> .decl FromDynamicHeapObject(?hctx:configuration.HContext, ?value:Value, ?dctx:DynamicContext, ?dheap:HeapAllocation)</li>
<li> .decl HeapDLInstanceFieldPointsTo(?hctx:configuration.HContext, ?value:Value, ?sig:Field, ?basehctx:configuration.HContext, ?basevalue:Value)</li>
<li> .decl HighConfidenceLoadFromDynamicInference(?value:Value, ?inmethod:Method)</li>
<li> .decl ImpreciseDynamicCallGraphEdge(?DCTX:DynamicContext, ?toMethod:Method, ?invocation:Instruction, ?DCTX2:DynamicContext, ?fromMethod:Method)</li>
<li> .decl ImpreciseDynamicInstanceFieldPointsTo(?fld:Field, ?immutableDCTX1:DynamicContext,  ?heap:HeapAllocation, ?immutableDCTX2:DynamicContext, ?baseHeap:HeapAllocation)</li>
<li> .decl ImpreciseDynamicStaticFieldPointsTo(?signature:Field, ?immutableDCTX:DynamicContext, ?heap:HeapAllocation)</li>
<li> .decl InsArrayIndexPointsToFromDynamic(?value:Value, ?baseValue:Value)</li>
<li> .decl InsInstanceFieldPointsToFromDynamic(?value:Value, ?fld:Field, ?baseValue:Value)</li>
<li> .decl InsStaticFieldPointsToFromDynamic(?value:Value, ?signature:Field)</li>
<li> .decl MostPreciseDynamicArrayIndexPointsTo(?dctx:DynamicContext, ?heap:HeapAllocation, ?baseDCtx:DynamicContext, ?baseHeap:HeapAllocation)</li>
<li> .decl MostPreciseDynamicCallGraphEdge(?DCTX:DynamicContext, ?toMethod:Method, ?invocation:Instruction, ?DCTX2:DynamicContext, ?fromMethod:Method)</li>
<li> .decl MostPreciseDynamicInstanceFieldPointsTo( ?fld:Field, ?dctx:DynamicContext, ?heap:HeapAllocation, ?baseDCtx:DynamicContext, ?baseHeap:HeapAllocation )</li>
<li> .decl MostPreciseDynamicStaticFieldPointsTo(?signature:Field, ?immutableDCTX:DynamicContext, ?heap:HeapAllocation)</li>
<li> .decl ProbablyReachable(?method:Method)</li>
<li> .decl SanitizedDynamicCallGraphEdge(?DCTX:DynamicContext, ?toMethod:Method, ?invocation:Instruction, ?DCTX2:DynamicContext, ?fromMethod:Method)</li>
<li> .decl SingletonDynamicHeapObject(?type:Type, ?value:Value)</li>
<li> .decl TamiflexDynamicallyReachableMethod(?inmethod:Method)</li>
<li> .decl Value_byDynamicHeap(?heap:HeapAllocation, ?value:Value)</li>
<li> .decl isImmutableDCTX(?dctx:DynamicContext)</li>
</ul>
<h2> main/exceptions-declarations.dl </h2>
<ul>
<li> .decl ExceptionHandler_Before(?before:ExceptionHandler, ?handler:ExceptionHandler)</li>
<li> .decl ExceptionHandler_Impossible(?type:Type, ?h2:ExceptionHandler, ?insn:Instruction)</li>
<li> .decl ExceptionHandler_InRange(?handler:ExceptionHandler, ?instruction:Instruction)</li>
<li> .decl ExceptionHandler_SameBlock_PartialOrder(?repr:ExceptionHandler, ?handler:ExceptionHandler)</li>
<li> .decl ExceptionHandler_SameBlock_Repr(?handler:ExceptionHandler, ?repr:ExceptionHandler)</li>
<li> .decl ExceptionHandler_SameInsn_PartialOrder(?h1:ExceptionHandler, ?h2:ExceptionHandler, ?insn:Instruction)</li>
<li> .decl ExceptionHandler_SameInsn_Repr(?insn:Instruction, ?repr:ExceptionHandler)</li>
<li> .decl ExceptionHandler_TypeIsCaught(?type:Type, ?block:ExceptionHandler)</li>
<li> .decl Instruction_Throws(?hctx:configuration.HContext, ?value:Value, ?ctx:configuration.Context, ?insn:Instruction)</li>
<li> .decl ThrowPointsTo(?hctx:configuration.HContext, ?value:Value, ?ctx:configuration.Context, ?method:Method)</li>
</ul>
<h2> main/exceptions.dl </h2>
<ul>
<li> .decl ProxyNullInvokeResult(?callerCtx:configuration.Context, ?invo:MethodInvocation, ?calleeCtx:configuration.Context)</li>
<li> .decl isProxyCCE(?value:Value)</li>
<li> .decl isProxyNPE(?value:Value)</li>
<li> .decl isProxyUTE(?value:Value)</li>
</ul>
<h2> main/finalization.dl </h2>
<ul>
<li> .decl FinalizeContextRequest(?callerCtx:configuration.Context, ?hctx:configuration.HContext, ?fakeinvo:MethodInvocation, ?heapValue:Value, ?register:Method, ?formal:Var)</li>
</ul>
<h2> main/full-call-graph.dl </h2>
<ul>
<li> .decl AnyCallGraphEdge(?instr:Instruction, ?method:Method)</li>
</ul>
<h2> main/generics-pre-analysis.dl </h2>
<ul>
<li> .decl CollectionAcceptsValueFallbackType(?mapValue:Value, ?type:Type)</li>
<li> .decl CollectionAcceptsValueType(?value:Value, ?type:Type)</li>
<li> .decl CollectionAcceptsValueTypeByDowncast(?mapValue:Value, ?type:Type)</li>
<li> .decl CollectionAcceptsValueTypeByGenericFieldInfo(?value:Value, ?type:Type)</li>
<li> .decl FieldPointsToCollection(?value:Value, ?field:Field)</li>
<li> .decl FieldPointsToMap(?value:Value, ?field:Field)</li>
<li> .decl GenericFieldSignatureViolation(?field:Field)</li>
<li> .decl GetFollowedByDownCast(?invo:MethodInvocation, ?downCastIns:AssignCast_Insn)</li>
<li> .decl GetMethodInvocationBasePointsToCollection(?invo:MethodInvocation,  ?to:Var, ?collectionValue:Value)</li>
<li> .decl GetMethodInvocationBasePointsToMap(?invo:MethodInvocation, ?to:Var, ?mapValue:Value)</li>
<li> .decl GetNotFollowedByDownCast(?invo:MethodInvocation)</li>
<li> .decl InsensitiveMethod(?method:Method)</li>
<li> .decl MapAcceptsKeyFallbackType(?mapValue:Value, ?type:Type)</li>
<li> .decl MapAcceptsKeyType(?value:Value, ?type:Type)</li>
<li> .decl MapAcceptsKeyTypeByGenericFieldInfo(?value:Value, ?type:Type)</li>
<li> .decl MapAcceptsValueFallbackType(?mapValue:Value, ?type:Type)</li>
<li> .decl MapAcceptsValueType(?value:Value, ?type:Type)</li>
<li> .decl MapAcceptsValueTypeByDowncast(?mapValue:Value, ?type:Type)</li>
<li> .decl MapAcceptsValueTypeByGenericFieldInfo(?value:Value, ?type:Type)</li>
<li> .decl NoValueRetrievalFromMap(?mapValue:Value)</li>
<li> .decl SensitiveMethod(?method:Method)</li>
<li> .decl SootFieldToGenericAsmField(?sootField:Field, ?asmField:Field)</li>
<li> .decl isCollectionField(?field:Field)</li>
<li> .decl isCollectionGetMethod(?method:Method)</li>
<li> .decl isCollectionValue(?value:Value)</li>
<li> .decl isMapField(?field:Field)</li>
<li> .decl isMapGetMethod(?method:Method)</li>
<li> .decl isMapValue(?value:Value)</li>
</ul>
<h2> main/implicit-reachable-declarations.dl </h2>
<ul>
<li> .decl ApplicationEntryPoint(?meth:Method)</li>
<li> .decl ForcedReachable(?method:Method)</li>
<li> .decl ImplicitReachable(?sig:Method)</li>
</ul>
<h2> main/implicit-reachable.dl </h2>
<ul>
<li> .decl AllApplicationConcreteImplementations(?class:ClassType, ?type:Type)</li>
<li> .decl ApplicationConcreteType(?type:ClassType)</li>
<li> .decl ExercisedEntryPointMethod(?class:Type, ?method:Method)</li>
<li> .decl ForcedReachableContext(?ctx:configuration.Context, ?meth:Method)</li>
<li> .decl FormalOfForcedReachableContext(?ctx:configuration.Context, ?formal:Var, ?formalType:Type)</li>
<li> .decl MockObjFromOpenProgramEntryPointArg(?value:Value)</li>
<li> .decl MockObjFromOpenProgramEntryPointReceiver(?value:Value)</li>
<li> .decl MockObject(?value:Value, ?class:ReferenceType)</li>
<li> .decl ServletParamType(?paramType:ReferenceType)</li>
<li> .decl SpecialConcreteImplementations(?class:ClassType, ?type:ReferenceType)</li>
<li> .decl TypeHasApplicationConcreteSubtypes(?type:Type)</li>
<li> .decl TypeToConcreteImplementation(?type:ReferenceType, ?class:ClassType)</li>
<li> .decl UnmockableFormalOfForcedReachableContext(?formal:Var, ?formalType:Type)</li>
</ul>
<h2> main/in-out-flow.dl </h2>
<ul>
<li> .decl InFlowTo(?index:number, ?var:Var)</li>
<li> .decl InFlowToReturn(?index:number, ?method:Method)</li>
<li> .decl InOutFlowMethod(?index:number, ?method:Method)</li>
<li> .decl IsInOutFlowMethod(?method:Method)</li>
<li> .decl LocalVarFlow(?to:Var, ?from:Var)</li>
<li> .decl ReturnFlowMethodInvocationParam(?param:Var, ?invo:MethodInvocation)</li>
<li> .decl StoreFlowThroughHeap(?to:Var, from:Var)</li>
</ul>
<h2> main/main.dl </h2>
<ul>
<li> .decl FakeInvocation_RegisterFinalize(?value:Value, ?invo:MethodInvocation)</li>
<li> .decl FakeInvocation_RegisterFinalize0(?heap:HeapAllocation, ?invo:MethodInvocation)</li>
<li> .decl NotSpecialObject(?value:Value)</li>
<li> .decl Value_DeclaringType(?value:Value, ?type:Type)</li>
<li> .decl Value_Null(?null:Value)</li>
<li> .decl Value_Num(?value:Value, ?const:symbol, ?valueType:Type)</li>
<li> .decl Value_Type(?value:Value, ?type:Type)</li>
<li> .decl Value_isHeap(?value:Value)</li>
<li> .decl Value_isMock(?value:Value)</li>
<li> .decl Value_isNonHeap(?value:Value)</li>
</ul>
<h2> main/method-handles.dl </h2>
<ul>
<li> .decl AssignMethodHandleToVarRequest(?method:Method, ?paramTypes:ParamTypes, ?retType:Type, ?hctx:configuration.HContext, ?ctx:configuration.Context, ?ret:Var)</li>
<li> .decl AssignMethodType(?hctx:configuration.HContext, ?mt:MethodType, ?ctx:configuration.Context, ?ret:Var, ?paramTypes:ParamTypes, ?retType:Type, ?arity:number)</li>
<li> .decl BoxAllocation(?value:Value, ?type:Type)</li>
<li> .decl BoxTypeConversion(?original:Type, ?new:Type)</li>
<li> .decl BoxingFunction(?functionType:ReferenceType, ?primType:Type, ?refType:ReferenceType)</li>
<li> .decl CallSiteContents(?invokedynamic:DynamicMethodInvocation_Insn, ?methodHandle:MethodHandle, ?method:Method, ?mt:MethodType, ?ctx:configuration.Context)</li>
<li> .decl CallSiteMatchesMethodHandleType(?invokedynamic:DynamicMethodInvocation_Insn, ?mh:MethodHandle, ?method:Method, ?ctx:configuration.Context)</li>
<li> .decl CalledInstanceImplMethod(?invokedynamic:DynamicMethodInvocation_Insn, ?implMethod:Method, ?this:Var, ?thisType:Type, ?calleeCtx:configuration.Context, ?lambda:Lambda)</li>
<li> .decl Class_getMembers(?sig:Method, ?hctx:configuration.HContext, ?ctx:configuration.Context, ?ret:Var, ?class:Type)</li>
<li> .decl CompatibleTypes(?t:Type, ?tConv:Type)</li>
<li> .decl CreateMHLookup(?type:Type, ?ctx:configuration.Context, ?ret:Var)</li>
<li> .decl CreatePreMethodTypeForMethod(?method:Method, ?mt:MethodType, ?mtConv:MethodType, ?paramTypes:ParamTypes, ?retType:Type, ?arity:number)</li>
<li> .decl DMHLookup(?type:Type, ?id:symbol, ?mt:Value, ?method:Method, ?retType:Type, ?paramTypes:ParamTypes)</li>
<li> .decl EquivalentWithPrependedReceiver(?mt:MethodType, ?mtConv:MethodType)</li>
<li> .decl FillConstructorsFromClass(?hctx:configuration.HContext, ?mockConstructors:Value, ?class:Type)</li>
<li> .decl FindConstructor(?invo:MethodInvocation, ?ret:Var)</li>
<li> .decl FindMethod(?invo:MethodInvocation, ?type:ReferenceType, ?id:symbol, ?mt:MethodType, ?hctx:configuration.HContext, ?ctx:configuration.Context)</li>
<li> .decl FindSpecial(?invo:MethodInvocation, ?ret:Var)</li>
<li> .decl FindStatic(?invo:MethodInvocation, ?ret:Var)</li>
<li> .decl FindVirtual(?invo:MethodInvocation, ?ret:Var)</li>
<li> .decl InvoReturnTypeMatch(?invo:MethodInvocation, ?hctx:configuration.HContext, ?ctx:configuration.Context, ?retType:Type)</li>
<li> .decl InvokedynamicBootCallGraphEdge(?callerCtx:configuration.Context, ?invokedynamic:DynamicMethodInvocation_Insn, ?calleeCtx:configuration.Context, ?bootMethod:Method)</li>
<li> .decl InvokedynamicCallSite(?callsite:CallSite, ?invokedynamic:DynamicMethodInvocation_Insn, ?dynName:symbol, ?K:number, ?ctx:configuration.Context)</li>
<li> .decl Invokedynamic_MethodType(?invokedynamic:DynamicMethodInvocation_Insn, ?mt:MethodType)</li>
<li> .decl LambdaArg(?calleeCtx:configuration.Context, ?formal:Var, ?formalType:Type, ?actual:Var, ?invokedynamic:DynamicMethodInvocation_Insn)</li>
<li> .decl LambdaCallGraphEdge(?callerCtx:configuration.Context, ?i:MethodInvocation, ?calleeCtx:configuration.Context, ?m:Method, ?lambda:Lambda)</li>
<li> .decl LambdaCaptured(?invokedynamic:DynamicMethodInvocation_Insn, ?val:Value, ?idx:number, ?hctx:configuration.HContext)</li>
<li> .decl LambdaMetafactoryInvoke(?invokedynamic:DynamicMethodInvocation_Insn)</li>
<li> .decl LambdaObject(?invokedynamic:DynamicMethodInvocation_Insn, ?lambda:Lambda, ?dynName:symbol, ?K:number, ?implMethod:Method, ?ctx:configuration.Context)</li>
<li> .decl MHLookup_Type(?value:Value, ?type:Type)</li>
<li> .decl MTCallMatch(?invo:MethodInvocation, ?hctx:configuration.HContext, ?ctx:configuration.Context, ?paramTypes:ParamTypes, ?retType:Type, ?arity:number)</li>
<li> .decl MT_ParamValue(?invo:MethodInvocation, ?index:number, ?classValue:Value)</li>
<li> .decl MT_ReturnType(?invo:MethodInvocation, ?hctx:configuration.HContext, ?ctx:configuration.Context, ?type:ReferenceType)</li>
<li> .decl MethodHandleCGE_Arg(?callerCtx:configuration.Context, ?calleeCtx:configuration.Context, ?actual:Var, ?formal:Var, ?actualType:Type, ?formalType:Type, ?name:symbol)</li>
<li> .decl MethodHandleCallGraphEdge(?callerCtx:configuration.Context, ?i:MethodInvocation, ?calleeCtx:configuration.Context, ?m:Method, ?mh:MethodHandle, ?name:symbol)</li>
<li> .decl MethodHandleCallGraphEdge_Candidate(?callerCtx:configuration.Context, ?i:MethodInvocation, ?m:Method, ?mh:MethodHandle, ?name:symbol)</li>
<li> .decl MethodHandle_Method(?methodHandle:MethodHandle, ?method:Method)</li>
<li> .decl MethodHandle_MethodType(?mh:MethodHandle, ?mt:MethodType)</li>
<li> .decl MethodType_Arity(?mt:MethodType, ?arity:number)</li>
<li> .decl MethodType_ParamType(?mt:MethodType, ?index:number, ?pType:Type)</li>
<li> .decl MethodType_ParamTypes(?mt:MethodType, ?paramTypes:ParamTypes)</li>
<li> .decl MethodType_ReturnType(?mt:MethodType, ?retType:Type)</li>
<li> .decl MethodVarArgs(?method:Method, ?idx:number, ?formal:Var, ?type:ArrayType)</li>
<li> .decl Method_MethodType(?method:Method, ?mt:MethodType)</li>
<li> .decl Params_ReceiverShiftRight(?lambda:Lambda, ?implMethod:Method, ?shiftK:number, ?shiftN:number)</li>
<li> .decl PopulateMTParamTypes(?mt:Value, ?invokedynamic:DynamicMethodInvocation_Insn)</li>
<li> .decl ReachableInvokedynamic(?invokedynamic:DynamicMethodInvocation_Insn, ?dynName:symbol, ?dynRetType:Type, ?ctx:configuration.Context)</li>
<li> .decl ReachableLambdaMetafactoryInvoke(?invokedynamic:DynamicMethodInvocation_Insn, ?dynName:symbol, ?dynRetType:Type, ?ctx:configuration.Context)</li>
<li> .decl ReachableMethodTypeN(?id:number, ?invo:MethodInvocation, ?ctx:configuration.Context)</li>
<li> .decl StaticMethodHandleCall(?callerCtx:configuration.Context, ?invo:MethodInvocation, ?method:Method, ?mh:MethodHandle)</li>
<li> .decl UnhandledInvokedynamic(?invokedynamic:DynamicMethodInvocation_Insn, ?bootMethodId:symbol)</li>
<li> .decl isBootstrapMethodContext(?ctx:configuration.Context)</li>
<li> .decl isInitialMethodType(?mt:MethodType)</li>
</ul>
<h2> main/native.dl </h2>
<ul>
<li> .decl AppCallGraphEdgeFromNativeMethod(?targetMethod:Method, ?nativeMethod:Method)</li>
<li> .decl CallGraphEdgeFromNativeMethod(?targetMethod:Method, ?nativeMethod:Method, ?function:symbol, ?file:symbol)</li>
<li> .decl HighlyPossibleNativeCodeTargetMethod(?method:Method, ?function:symbol, ?file:symbol)</li>
<li> .decl LoadFromReference(?ctx:configuration.Context, ?to:Var, ?basehctx:configuration.HContext, ?basevalue:Value)</li>
<li> .decl LoadFromReferenceArgs(?base:Var, ?to:Var)</li>
<li> .decl NativeAllocation(?constructor:Method, ?function:symbol, ?file:symbol, ?type:ReferenceType)</li>
<li> .decl NativeMethodReturningValue(?m:Method, ?t:Type, ?return:Var, ?v:Value)</li>
<li> .decl ReachableAppMethodFromNativeCode(?method:Method)</li>
<li> .decl ReachableContextFromNative(?ctx:configuration.Context, ?method:Method, ?function:symbol, ?file:symbol)</li>
<li> .decl ReachableMethodFromNativeCode(?method:Method)</li>
<li> .decl ReachableNativeMethodInvocation(?ctx:configuration.Context, ?invo:MethodInvocation, ?nativeMethod:Method)</li>
<li> .decl SimulateNativeAllocation(?strMethod: Method, ?strHeap: HeapAllocation, ?strConstructor: Method)</li>
<li> .decl SimulatedNativeAllocation(?heap:HeapAllocation, ?method:Method)</li>
<li> .decl StoreIntoWeakReference(?basehctx:configuration.HContext, ?basevalue:Value, ?ctx:configuration.Context, ?from:Var)</li>
<li> .decl StoreIntoWeakReferenceArgs(?from:Var, ?base:Var)</li>
<li> .decl _NativeMethodInvocation(?invo:MethodInvocation, ?nativeMethod:Method)</li>
<li> .decl isNativeContext(?ctx:configuration.Context)</li>
</ul>
<h2> main/package-heuristic.dl </h2>
<ul>
<li> .decl ClassNameIndexes(?pos:number, ?type:ClassType)</li>
<li> .decl Class_PackageHack(?type:ClassType, ?packageName:symbol)</li>
<li> .decl DotsInClassName(?type:ClassType, ?pos:number)</li>
<li> .decl LastDot(?type:ClassType, ?pos:number)</li>
<li> .decl NotLastDot(?pos:number, ?type:ClassType)</li>
<li> .decl NotSecondLastDot(?pos:number, ?type:ClassType)</li>
<li> .decl SecondLastDot(?type:ClassType, ?pos:number)</li>
</ul>
<h2> main/phantom-dead.dl </h2>
<ul>
<li> .decl DeadInstruction(?i:Instruction)</li>
<li> .decl DeadMethod(?m:Method)</li>
<li> .decl DeadType(?type:Type)</li>
<li> .decl PhantomInvoke(?instruction:Instruction)</li>
<li> .decl RemovedMethod(?method:Method)</li>
</ul>
<h2> main/prologue.dl </h2>
<ul>
<li> .decl PrimitiveType_Boxed(?type:Type, ?boxedType:Type)</li>
</ul>
<h2> main/reflection/classloading.dl </h2>
<ul>
<li> .decl DalvikMethodInvocation(?var:Var, ?m:Method, ?ctx:configuration.Context, ?hctx:configuration.HContext)</li>
</ul>
<h2> main/reflection/declarations.dl </h2>
<ul>
<li> .decl ReflectiveAllocation(?instruction:Instruction, ?type:ReferenceType, ?value:Value)</li>
<li> .decl ReflectiveValue(?value:Value)</li>
<li> .decl ReifiedClass(?type:ReferenceType, ?value:Value)</li>
<li> .decl ReifiedConstructor(?constructor:Method, ?value:Value)</li>
<li> .decl ReifiedField(?field:Field, ?value:Value)</li>
<li> .decl ReifiedMethod(?method:Method, ?value:Value)</li>
<li> .decl StringPrecisionThreshold(?t:number)</li>
<li> .decl java_lang_ClassLoader_getResource(?invocation:MethodInvocation, ?to:Var, ?from:Var)</li>
<li> .decl java_lang_Class_forName(?invocation:MethodInvocation, ?inmethod:Method)</li>
<li> .decl java_lang_Class_getAnnotations(?invocation:MethodInvocation, ?to:Var, ?from:Var)</li>
<li> .decl java_lang_Class_getCanonicalName(?to:Var, ?from:Var)</li>
<li> .decl java_lang_Class_getClassLoader(?invocation:MethodInvocation, ?to:Var, ?from:Var)</li>
<li> .decl java_lang_Class_getComponentType(?to:Var, ?from:Var)</li>
<li> .decl java_lang_Class_getConstructor(?to:Var, ?from:Var)</li>
<li> .decl java_lang_Class_getConstructors(?invocation:MethodInvocation, ?to:Var, ?from:Var)</li>
<li> .decl java_lang_Class_getDeclaredAnnotations(?invocation:MethodInvocation, ?to:Var, ?from:Var)</li>
<li> .decl java_lang_Class_getDeclaredConstructor(?to:Var, ?from:Var)</li>
<li> .decl java_lang_Class_getDeclaredConstructors(?invocation:MethodInvocation, ?to:Var, ?from:Var)</li>
<li> .decl java_lang_Class_getDeclaredField(?to:Var, ?param:Var, ?from:Var)</li>
<li> .decl java_lang_Class_getDeclaredFields(?invocation:MethodInvocation, ?to:Var, ?from:Var)</li>
<li> .decl java_lang_Class_getDeclaredMethod(?to:Var, ?param:Var, ?from:Var)</li>
<li> .decl java_lang_Class_getDeclaredMethods(?invocation:MethodInvocation, ?to:Var, ?from:Var)</li>
<li> .decl java_lang_Class_getField(?to:Var, ?param:Var, ?from:Var)</li>
<li> .decl java_lang_Class_getFields(?invocation:MethodInvocation, ?to:Var, ?from:Var)</li>
<li> .decl java_lang_Class_getInterfaces(?invocation:MethodInvocation, ?to:Var, ?from:Var)</li>
<li> .decl java_lang_Class_getMethod(?to:Var, ?param:Var, ?from:Var)</li>
<li> .decl java_lang_Class_getMethods(?invocation:MethodInvocation, ?to:Var, ?from:Var)</li>
<li> .decl java_lang_Class_getName(?to:Var, ?from:Var)</li>
<li> .decl java_lang_Class_getPrimitiveClass(?to:Var, ?name:Var)</li>
<li> .decl java_lang_Class_getSuperclass(?to:Var, ?from:Var)</li>
<li> .decl java_lang_Class_newInstance(?invocation:MethodInvocation, ?to:Var, ?from:Var)</li>
<li> .decl java_lang_Object_getClass(?to:Var, ?from:Var)</li>
<li> .decl java_lang_reflect_Array_newInstance(?invocation:MethodInvocation, ?to:Var, ?param:Var)</li>
<li> .decl java_lang_reflect_Constructor_newInstance(?invocation:MethodInvocation, ?to:Var, ?from:Var)</li>
<li> .decl java_lang_reflect_Field_get(?invocation:MethodInvocation, ?to:Var, ?field:Var)</li>
<li> .decl java_lang_reflect_Field_getDeclaredAnnotations(?invocation:MethodInvocation, ?to:Var, ?from:Var)</li>
<li> .decl java_lang_reflect_Field_get_base(?invocation:MethodInvocation, ?base:Var)</li>
<li> .decl java_lang_reflect_Field_set(?invocation:MethodInvocation, ?from:Var, ?field:Var)</li>
<li> .decl java_lang_reflect_Field_set_base(?invocation:MethodInvocation, ?base:Var)</li>
<li> .decl java_lang_reflect_Method_getDeclaredAnnotations(?invocation:MethodInvocation, ?to:Var, ?from:Var)</li>
<li> .decl java_lang_reflect_Method_getParameterAnnotations(?invocation:MethodInvocation, ?to:Var, ?from:Var)</li>
<li> .decl java_lang_reflect_Method_invoke(?invocation:MethodInvocation, ?method:Var)</li>
</ul>
<h2> main/reflection/dynamic-proxies.dl </h2>
<ul>
<li> .decl ArgArrayAndActualArg(?argsArrValue:Value, ?methSig:Method, ?actual:Var)</li>
<li> .decl ArgArrayOfProxyMethod(?meth:Method, ?invo:MethodInvocation, ?value:Value)</li>
<li> .decl ArrayContentsPointToInterface(?iface:InterfaceType, ?hctx:configuration.HContext, ?arrayValue:Value)</li>
<li> .decl BoxAllocationOfPrimitiveFormal(?formal:Var, ?value:Value)</li>
<li> .decl CallToMethodOfProxyObject(?hctx:configuration.HContext, ?value:Value, ?ctx:configuration.Context, ?invo:MethodInvocation)</li>
<li> .decl HandledProxy(?newProxyInstanceInvo:MethodInvocation, ?handlerType:ReferenceType)</li>
<li> .decl MethodOfInterface(?meth:Method, ?iface:InterfaceType)</li>
<li> .decl PrimitiveFormalOfInterface(?meth:Method, ?formal:Var, ?formalType:PrimitiveType)</li>
<li> .decl ProxyCallArgArray(?invo:MethodInvocation, ?methSig:Method, ?argsArrValue:Value)</li>
<li> .decl ProxyCallGraphEdge(?callerCtx:configuration.Context, ?invo:MethodInvocation, ?calleeCtx:configuration.Context, ?handlerInvokeMeth:Method)</li>
<li> .decl ProxyCallGraphEdgeCandidate(?callerCtx:configuration.Context, ?hctx:configuration.HContext, ?invo:MethodInvocation, ?handlerObj:Value, ?handlerInvokeMeth:Method, ?value:Value, ?handlerType:ReferenceType)</li>
<li> .decl ProxyClass(?class:ClassType)</li>
<li> .decl ProxyClassInstance(?iface:InterfaceType, ?invo:MethodInvocation, ?value:Value)</li>
<li> .decl ProxyClassOfInterface(?iface:InterfaceType, ?class:ClassType)</li>
<li> .decl ProxyInit(?callerCtx:configuration.Context, ?hctx:configuration.HContext, ?invo:MethodInvocation, ?proxy:Value, ?handlerObj:Value, ?init:Method)</li>
<li> .decl ProxyInvoke(?invokeMethName:symbol, ?invokeMethDescriptor:symbol)</li>
<li> .decl ProxyInvokeResult(?callerCtx:configuration.Context, ?invo:MethodInvocation, ?calleeCtx:configuration.Context, ?handlerReturnVar:Var)</li>
<li> .decl ProxyObject_Handler(?value:Value, ?handlerObj:Value)</li>
<li> .decl ProxyObject_HandlerCtx(?value:Value, ?handlerCtx:configuration.Context)</li>
<li> .decl ProxyObject_HandlerHctx(?value:Value, ?handlerHctx:configuration.HContext)</li>
<li> .decl ProxyObject_Interface(?value:Value, ?iface:InterfaceType)</li>
<li> .decl ProxyObject_Invocation(?value:Value, ?invo:MethodInvocation)</li>
<li> .decl SpecialMethodFromObject(?method:Method, ?objMethod:Method)</li>
<li> .decl isProxyObject(?value:Value)</li>
<li> .decl java_lang_reflect_Proxy_getProxyClass(?invo:MethodInvocation, ?ret:Var, ?interfaces:Var)</li>
<li> .decl java_lang_reflect_Proxy_newProxyInstance(?invo:MethodInvocation, ?ret:Var, ?handler:Var, ?interfaces:Var)</li>
</ul>
<h2> main/reflection/java.lang.Class.dl </h2>
<ul>
<li> .decl AssignReflectiveAllocation(?invocation:MethodInvocation, ?type:Type, ?ctx:configuration.Context, ?to:Var)</li>
<li> .decl Enums(?enumsArray:Value, ?enumType:Type, ?ctx:configuration.Context, ?return:Var)</li>
<li> .decl FillArray_Constructors(?hctx:configuration.HContext, ?arrayValue:Value, ?classValue:Value)</li>
<li> .decl FillArray_Fields(?hctx:configuration.HContext, ?arrayValue:Value, ?type:Type)</li>
<li> .decl FillArray_Interfaces(?hctx:configuration.HContext, ?arrayValue:Value, ?type:Type)</li>
<li> .decl FillArray_Methods(?hctx:configuration.HContext, ?arrayValue:Value, ?type:Type)</li>
<li> .decl FillArray_PublicConstructors(?hctx:configuration.HContext, ?arrayValue:Value, ?classValue:Value)</li>
<li> .decl FillArray_PublicFields(?hctx:configuration.HContext, ?arrayValue:Value, ?type:Type)</li>
<li> .decl FillArray_PublicMethods(?hctx:configuration.HContext, ?arrayValue:Value, ?type:Type)</li>
<li> .decl ForwardHighConfidenceReflectiveAssignClassConstant(?ctx:configuration.Context, ?invocation:MethodInvocation, ?type:Type)</li>
<li> .decl ForwardHighConfidenceReflectiveAssignFieldConstant(?ctx:configuration.Context, ?to:Var, ?signature:Field)</li>
<li> .decl ForwardHighConfidenceReflectiveAssignMethodConstant(?ctx:configuration.Context, ?to:Var, ?signature:Method)</li>
<li> .decl ForwardReflectiveAssignClassConstant(?ctx:configuration.Context, ?invocation:MethodInvocation, ?type:Type)</li>
<li> .decl ForwardReflectiveAssignClassConstantString(?ctx:configuration.Context, ?invocation:MethodInvocation, ?type:Type, ?constantHeap:Value)</li>
<li> .decl ForwardReflectiveAssignFieldConstant(?ctx:configuration.Context, ?to:Var, ?signature:Field)</li>
<li> .decl ForwardReflectiveAssignFieldConstantString(?ctx:configuration.Context, ?to:Var, ?signature:Field, ?constantHeap:Value)</li>
<li> .decl ForwardReflectiveAssignMethodConstant(?ctx:configuration.Context, ?to:Var, ?signature:Method)</li>
<li> .decl ForwardReflectiveAssignMethodConstantString(?ctx:configuration.Context, ?to:Var, ?signature:Method, ?constantHeap:Value)</li>
<li> .decl FromGetSuperClassType(?callerCtx:configuration.Context, ?hctx:configuration.HContext, ?type:Type, ?to:Var)</li>
<li> .decl HighConfidenceAssign(?value:Value, ?inmethod:Method)</li>
<li> .decl NumberOfClassesMatchingConstant(?constant:HeapAllocation, ?n:number)</li>
<li> .decl NumberOfFieldsMatchingConstant(?constant:HeapAllocation, ?n:number)</li>
<li> .decl NumberOfMethodsMatchingConstant(?constant:HeapAllocation, ?n:number)</li>
<li> .decl OptClassToConstructor(?constructor:Method, ?classValue:Value)</li>
<li> .decl OptGetFieldFromClass(?to:Var, ?ctx:configuration.Context, ?param:Var, ?type:Type)</li>
<li> .decl OptGetMethodFromClass(?to:Var, ?ctx:configuration.Context, ?param:Var, ?type:Type)</li>
<li> .decl OptTypeContainsPublicField(?type:Type, ?signature:Field)</li>
<li> .decl OptTypeContainsPublicMethod(?type:Type, ?signature:Method)</li>
<li> .decl PopulateAnnotationsForType(?annotationsArray:Value, ?type:Type, ?hctx:configuration.HContext)</li>
<li> .decl ReflectiveSpecialMethodInvocation(?invocation:MethodInvocation, ?constructor:Method, ?ctx:configuration.Context, ?to:Var)</li>
<li> .decl getMethodsPrecisionThreshold(?t:number)</li>
<li> .decl getMethodsResult(?type:ReferenceType, ?value:Value)</li>
<li> .decl getMethodsSupportedType(?type:ClassType)</li>
</ul>
<h2> main/reflection/java.lang.reflect.Field.dl </h2>
<ul>
<li> .decl PopulateAnnotationsForField(?annotationsArray:Value, ?field:Field, ?hctx:configuration.HContext)</li>
<li> .decl ReflectiveLoadField(?invocation:MethodInvocation, ?ctx:configuration.Context, ?to:Var, ?signature:Field)</li>
<li> .decl ReflectiveLoadInstanceField(?ctx1:configuration.Context, ?to:Var, ?signature:Field, ?ctx2:configuration.Context, ?base:Var)</li>
<li> .decl ReflectiveLoadStaticField(?ctx:configuration.Context, ?to:Var, ?signature:Field)</li>
<li> .decl ReflectiveStoreField(?invocation:MethodInvocation, ?signature:Field, ?ctx:configuration.Context, ?from:Var)</li>
<li> .decl ReflectiveStoreInstanceField(?ctx1:configuration.Context, ?from:Var, ?signature:Field, ?ctx2:configuration.Context, ?base:Var)</li>
<li> .decl ReflectiveStoreStaticField(?signature:Field, ?ctx:configuration.Context, ?from:Var)</li>
</ul>
<h2> main/reflection/java.lang.reflect.Method.dl </h2>
<ul>
<li> .decl PopulateAnnotationsForMethod(?annotationsArray:Value, ?method:Method, ?hctx:configuration.HContext)</li>
<li> .decl PopulateParameterAnnotationsForMethod(?annotationsArray:Value, ?method:Method, ?hctx:configuration.HContext, ?invocation:MethodInvocation)</li>
<li> .decl ReflectiveActualParams(?invocation:MethodInvocation, ?argsParam:Var)</li>
<li> .decl ReflectiveAssignReturnValue(?invocation:MethodInvocation, ?var:Var)</li>
<li> .decl ReflectiveBaseVar(?invocation:MethodInvocation, ?base:Var)</li>
<li> .decl ReflectiveMethodInvocation(?ctx:configuration.Context, ?invocation:MethodInvocation, ?signature:Method)</li>
</ul>
<h2> main/reflection/light-Class.dl </h2>
<ul>
<li> .decl Enums(?enumsArray:Value, ?enumType:Type, ?ctx:configuration.Context, ?return:Var)</li>
<li> .decl ReflectiveAssignClassConstant(?ctx:configuration.Context, ?invocation:MethodInvocation, ?type:ReferenceType)</li>
<li> .decl ReifiedClass(?type:ReferenceType, ?value:Value)</li>
<li> .decl java_lang_Class_forName(?invocation:MethodInvocation, ?inmethod:Method)</li>
</ul>
<h2> main/reflection/light-reflection-glue.dl </h2>
<ul>
<li> .decl ReflectiveMethodCall(?m:Method, ?callerCtx:configuration.Context, ?calleeCtx:configuration.Context, ?this:Var, ?args:Var, ?invocation:MethodInvocation)</li>
<li> .decl ReflectiveMethodCall_Candidate(?methodVar:Var, ?methName:symbol, ?callerCtx:configuration.Context, ?type:Type)</li>
<li> .decl java_lang_Class_getConstructor(?to:Var, ?from:Var)</li>
<li> .decl java_lang_Class_getMethod(?to:Var, ?param:Var, ?from:Var)</li>
<li> .decl java_lang_reflect_Constructor_newInstance(?invocation:MethodInvocation, ?to:Var, ?from:Var)</li>
<li> .decl java_lang_reflect_Method_invoke(?invocation:MethodInvocation, ?methodVar:Var)</li>
</ul>
<h2> main/reflection/rules.dl </h2>
<ul>
<li> .decl BackwardHighConfidenceReflectiveAssignClassConstant(?invocation:MethodInvocation, ?type:Type)</li>
<li> .decl BackwardHighConfidenceReflectiveAssignFieldConstant(?to:Var, ?signature:Field)</li>
<li> .decl BackwardHighConfidenceReflectiveAssignMethodConstant(?to:Var, ?signature:Method)</li>
<li> .decl BackwardReflectiveAssignClassConstant(?invocation:MethodInvocation, ?type:Type)</li>
<li> .decl BackwardReflectiveAssignFieldConstant(?to:Var, ?signature:Field)</li>
<li> .decl BackwardReflectiveAssignMethodConstant(?to:Var, ?signature:Method)</li>
<li> .decl ClassSubtype(?subType:ClassType, ?type:ClassType)</li>
<li> .decl FairlyInformativeFieldName(?constant:Value)</li>
<li> .decl FairlyInformativeMethodName(?constant:Value)</li>
<li> .decl InferredTypesPrecisionThreshold(?t:number)</li>
<li> .decl InvokeArgLoadArrayIndex(?calleeCtx:configuration.Context, ?to:Var, ?callerCtx:configuration.Context, ?base:Var)</li>
<li> .decl LoadReflectiveValueArrayIndex(?calleeCtx:configuration.Context, ?to:Var, ?basehctx:configuration.HContext, ?basevalue:Value)</li>
<li> .decl MarkerReflectiveObject(?invocation:MethodInvocation, ?value:Value)</li>
<li> .decl NumberOfClassSubtypes(?type:ClassType, ?count:number)</li>
<li> .decl NumberOfTypesMatchingFieldName(?constant:HeapAllocation, ?n:number)</li>
<li> .decl NumberOfTypesMatchingMethod(?constant:HeapAllocation, ?n:number)</li>
<li> .decl Opt2AssignCast(?inmethod:Method, ?supertype:Type, ?to:Var, ?from:Var)</li>
<li> .decl Opt2SpecialGetValueCast(?type:Type, ?getFieldInvocation:MethodInvocation)</li>
<li> .decl Opt2SpecialInvokeValueCast(?type:Type, ?getMethodInvocation:MethodInvocation)</li>
<li> .decl OptFieldObjectFromGet(?fieldValue:Value, ?return:Var)</li>
<li> .decl OptFieldType(?type:Type, ?signature:Field, ?declaringClassType:Type)</li>
<li> .decl OptForNameFromGetConstructors(?forNameInvocation:MethodInvocation, ?ctx:configuration.Context, ?to:Var)</li>
<li> .decl OptGetFieldsClass(?type:Type, ?getFieldsInvocation:MethodInvocation)</li>
<li> .decl OptGetMethodsClass(?type:Type, ?getMethodsInvocation:MethodInvocation)</li>
<li> .decl OptGetOnSpecialMissingGetFieldsValue(?getFieldsInvocation:MethodInvocation, ?ctx:configuration.Context, ?invocation:MethodInvocation)</li>
<li> .decl OptInvokeOnSpecialMissingGetMethodsValue(?getMethodsInvocation:MethodInvocation, ?ctx:configuration.Context, ?invocation:MethodInvocation)</li>
<li> .decl OptMarkerReflectiveObject(?invocation:MethodInvocation, ?value:Value)</li>
<li> .decl OptMethodObjectFromInvoke(?methodValue:Value, ?return:Var)</li>
<li> .decl OptSpecialGetValueCast(?type:Type, ?getFieldsInvocation:MethodInvocation)</li>
<li> .decl OptSpecialInvokeValueCast(?type:Type, ?getMethodsInvocation:MethodInvocation)</li>
<li> .decl ReflectiveAssignClassConstant(?ctx:configuration.Context, ?invocation:MethodInvocation, ?type:Type)</li>
<li> .decl ReflectiveAssignFieldConstant(?ctx:configuration.Context, ?to:Var, ?signature:Field)</li>
<li> .decl ReflectiveAssignMethodConstant(?ctx:configuration.Context, ?to:Var, ?signature:Method)</li>
<li> .decl ReflectiveCallGraphEdge(?callerCtx:configuration.Context, ?invocation:MethodInvocation, ?calleeCtx:configuration.Context, ?callee:Method)</li>
<li> .decl ReflectiveHeapInterproceduralAssign(?sig:Field, ?toCtx:configuration.Context, ?to:Var, ?fromCtx:configuration.Context, ?from:Var)</li>
<li> .decl ReflectiveLoadHeapInstanceField(?toCtx:configuration.Context, ?to:Var, ?signature:Field, ?basehctx:configuration.HContext, ?base:Value)</li>
<li> .decl ReflectiveReachable(?m:Method)</li>
<li> .decl ReflectiveStaticMethodInvocation(?ctx:configuration.Context, ?invocation:MethodInvocation, ?signature:Method)</li>
<li> .decl ReflectiveStoreHeapInstanceField(?signature:Field, ?basehctx:configuration.HContext, ?basevalue:Value, ?fromCtx:configuration.Context, ?from:Var)</li>
<li> .decl ReflectiveVirtualMethodInvocation(?signature:Method, ?invocation:MethodInvocation, ?ctx:configuration.Context, ?base:Var)</li>
<li> .decl SpecialMissingForNameValue(?invocation:MethodInvocation, ?value:Value)</li>
<li> .decl SpecialMissingForNameValueFlowsToGetField(?forNameInvocation:MethodInvocation, ?type:Type, ?constant:Value, ?inMethod:Method)</li>
<li> .decl SpecialMissingForNameValueFlowsToGetMethod(?forNameInvocation:MethodInvocation, ?type:Type, ?constant:Value, ?inMethod:Method)</li>
<li> .decl SpecialMissingGetConstructorValue(?invocation:MethodInvocation, ?value:Value)</li>
<li> .decl SpecialMissingGetFieldValue(?invocation:MethodInvocation, ?value:Value)</li>
<li> .decl SpecialMissingGetFieldsValue(?invocation:MethodInvocation, ?value:Value)</li>
<li> .decl SpecialMissingGetMethodValue(?invocation:MethodInvocation, ?value:Value)</li>
<li> .decl SpecialMissingGetMethodsValue(?invocation:MethodInvocation, ?value:Value)</li>
<li> .decl SpecialMissingGetValueFromGetField(?invocation:MethodInvocation, ?value:Value)</li>
<li> .decl SpecialMissingGetValueFromGetFields(?invocation:MethodInvocation, ?value:Value)</li>
<li> .decl SpecialMissingInvokeValueFromGetMethod(?invocation:MethodInvocation, ?value:Value)</li>
<li> .decl SpecialMissingInvokeValueFromGetMethods(?invocation:MethodInvocation, ?value:Value)</li>
<li> .decl SpecialMissingNewInstanceValue(?invocation:MethodInvocation, ?value:Value)</li>
<li> .decl SpecialMissingNewInstanceValueFlowsToCast(?forNameInvocation:MethodInvocation, ?type:Type, ?inMethod:Method)</li>
<li> .decl TypeHasHeap(?type:Type)</li>
<li> .decl TypeMatchingFieldName(?type:Type, ?constant:HeapAllocation)</li>
<li> .decl TypeMatchingMethod(?type:Type, ?constant:HeapAllocation)</li>
<li> .decl UnknownReflectiveObject(?type:Type, ?invocation:MethodInvocation, ?value:Value)</li>
<li> .decl _OptMethodWithVarCast(?subtype:Type, ?inMethod:Method, ?from:Var)</li>
</ul>
<h2> main/scaler-pre-analysis.dl </h2>
<ul>
<li> .decl ActualParam_Method(?var:Var, ?method:Method)</li>
<li> .decl AllCallGraphEdge(?from:MethodInvocation, ?to:Method)</li>
<li> .decl CallSiteIn(?invo:MethodInvocation, ?method:Method)</li>
<li> .decl DataStructureClass(?class:Type)</li>
<li> .decl DataStructureMethod(?method:Method)</li>
<li> .decl DoubleDispatchInvocation(?invo:MethodInvocation)</li>
<li> .decl EntryContextMethod(?method:Method)</li>
<li> .decl EntryDataStructureMethod(?method:Method)</li>
<li> .decl EntryNonDataStructureMethod(?method:Method)</li>
<li> .decl ExteriorFVar_Method(?var:Var, ?method: Method)</li>
<li> .decl Instance_Method(?method:Method)</li>
<li> .decl InteriorVar_Method(?var:Var, ?method:Method)</li>
<li> .decl InvocationActualParam(?invo:MethodInvocation, ?var:Var)</li>
<li> .decl InvocationHasMethodArgumentAsReceiver(?invo:MethodInvocation)</li>
<li> .decl InvocationHasMethodReceiverAsArgument(?invo:MethodInvocation)</li>
<li> .decl InvocationHasMethodReceiverasArgument(?invo:MethodInvocation)</li>
<li> .decl InvocationReceiver(?invo:MethodInvocation, ?method:Method, ?var:Var)</li>
<li> .decl InvokedMethod(method:Method)</li>
<li> .decl MethodCallsOthers(?method:Method)</li>
<li> .decl MethodCanBenefitFromCS(?method:Method)</li>
<li> .decl MethodCannotBenefitFromCS(?method:Method)</li>
<li> .decl MethodCantBenefitFromCS(?method:Method)</li>
<li> .decl MethodDoesStores(?method:Method)</li>
<li> .decl MethodDoesntCallOthers(?method:Method)</li>
<li> .decl MethodDoesntDoStores(?method:Method)</li>
<li> .decl MethodDoesntPassReferences(?method:Method)</li>
<li> .decl MethodDoesntReturnReference(?method:Method)</li>
<li> .decl MethodDoesntThrowException(?method:Method)</li>
<li> .decl MethodFormalParam(?method:Method, ?var:Var)</li>
<li> .decl MethodPassesReferences(?method:Method)</li>
<li> .decl MethodReturnsReference(?method:Method)</li>
<li> .decl MethodThrowsException(?method:Method)</li>
<li> .decl Method_AllPossibleOneTypeContexts(?method:Method, ?receiverType:Type)</li>
<li> .decl Method_AllPossibleOneTypeContexts(?method:Method, ?receiverType:Type)</li>
<li> .decl Method_AllPossibleTwoObjContexts(?method:Method, ?receiverOfAllocator:Value, ?receiver:Value)</li>
<li> .decl Method_AllPossibleTwoObjContexts(?method:Method, ?receiverOfAllocator:Value, ?receiver:Value)</li>
<li> .decl Method_AllPossibleTwoTypeContexts(?method:Method, ?receiverOfAllocatorType:Type, ?receiverType:Type)</li>
<li> .decl Method_AllPossibleTwoTypeContexts(?method:Method, ?receiverOfAllocatorType:Type, ?receiverType:Type)</li>
<li> .decl Method_Neighbor(?method:Method, ?neighbor:Method)</li>
<li> .decl Method_NumberOfContexts(?method:Method, ?n:number)</li>
<li> .decl Method_NumberOfNeighbors(?method:Method, ?n:number)</li>
<li> .decl Method_TotalVPT(?method:Method, Y:number)</li>
<li> .decl MonomorphicallyInvokedMethod(?method:Method)</li>
<li> .decl Object_In(?object:Value, ?method:Method)</li>
<li> .decl PolymorphicallyInvokedMethod(?method:Method)</li>
<li> .decl Prephase_ReceiverOfAllocatingMethod_Object(?receiver:Value, ?allocatedObject:Value)</li>
<li> .decl ReceiverOfAllocatingMethod_Object(?receiver:Value, ?allocatedObject:Value)</li>
<li> .decl ReceiverOfAllocatingMethod_Object(?receiver:Value, ?allocatedObject:Value)</li>
<li> .decl ReceiverOfMethod(?method:Method, ?value:Value)</li>
<li> .decl ReceiverOfMethod(?method:Method, ?value:Value)</li>
<li> .decl Stats_Simple_InsensStaticFieldPointsToCount(?field:Field, ?n:number)</li>
<li> .decl Stats_Simple_SensStaticFieldPointsToCount(?field:Field, ?n:number)</li>
<li> .decl StickyContextMethod(?method:Method)</li>
<li> .decl This_Var(?method:Method, ?var:Var)</li>
<li> .decl VPTCountPerMethodVariable(?method:Method, ?var:Var, ?n:number)</li>
<li> .decl VarTransitivelyPointsTo(?heap:Value, ?var:Var)</li>
<li> .decl Var_In(?var:Var, ?method:Method)</li>
<li> .decl VariableCantBenefitFromCS(?var:Var)</li>
<li> .decl VariableValueEscapesMethod(?var:Var)</li>
<li> .decl VarsInSameMethodHaveSamePointsToSet(?var1:Var, ?var2:Var)</li>
<li> .decl VarsInSameMethodPointToDifferentObjects(?var1:Var, ?var2:Var)</li>
</ul>
<h2> main/special-library.dl </h2>
<ul>
<li> .decl CollectionClass(?class:Type)</li>
<li> .decl CollectionInnerClass(?class:ClassType)</li>
<li> .decl CollectionInnerClassPrefix(?innerClassPrefix:symbol)</li>
<li> .decl SpecialLibraryClass(?class:Type)</li>
<li> .decl SpecialLibraryMethod(?method:Method)</li>
<li> .decl SpecialLibraryObject(?heap:HeapAllocation)</li>
</ul>
<h2> main/string-concat.dl </h2>
<ul>
<li> .decl ReflectionStringConstantFlowsIntoStringFactory(?hctx:configuration.HContext, ?value:Value, ?factoryHctx:configuration.HContext, ?factoryValue:Value)</li>
<li> .decl ReflectionStringConstantVarPointsTo(?hctx:configuration.HContext, ?value:Value, ?ctx:configuration.Context, ?var:Var)</li>
<li> .decl StringFactoryVar(?var:Var)</li>
<li> .decl StringFactoryVarPointsTo(?factoryHctx:configuration.HContext, ?factoryValue:Value, ?ctx:configuration.Context, ?var:Var)</li>
<li> .decl VarAssignedFromStringFactoryVar(?ret:Var, ?base:Var)</li>
<li> .decl VarAssignedToStringFactoryVar(?param:Var, ?base:Var)</li>
<li> .decl VarFlowsFromStringFactory(?ctx:configuration.Context, ?var:Var, ?factoryHctx:configuration.HContext, ?factoryValue:Value)</li>
<li> .decl VarFlowsIntoStringFactory(?factoryHctx:configuration.HContext, ?factoryValue:Value, ?ctx:configuration.Context, ?var:Var)</li>
<li> .decl VarOfReflectionInterest(?ctx:configuration.Context, ?var:Var)</li>
</ul>
<h2> main/string-constants.dl </h2>
<ul>
<li> .decl AllocationShouldBeMergedGlobally(?heaptype:Type)</li>
<li> .decl AllocationShouldBeMergedPerClass(?heaptype:Type, ?class:Type)</li>
<li> .decl AllocationShouldBeMergedPerMethod(?heaptype:Type, ?meth:Method)</li>
<li> .decl AllocationShouldBeMergedPerPackage(?heaptype:Type, ?packageName:symbol)</li>
<li> .decl AllocationsPerClassAndType(?type:Type, ?class:ReferenceType, ?n:number)</li>
<li> .decl AllocationsPerMethodAndType(?type:Type, ?meth:Method, ?n:number)</li>
<li> .decl AllocationsPerPackageAndType(?type:Type, ?packageName:symbol, ?n:number)</li>
<li> .decl AllocationsPerType(?type:Type, ?n:number)</li>
<li> .decl AssignContextInsensitiveHeapAllocation(?heap:HeapAllocation, ?var:Var, ?inmethod:Method)</li>
<li> .decl AssignNormalHeapAllocation(?heap:HeapAllocation, ?var:Var, ?inmethod:Method)</li>
<li> .decl ClassAndTypeToHeap(?heap:HeapAllocation, ?heaptype:Type, ?class:ReferenceType)</li>
<li> .decl ClassAndTypeToMergedHeap(?heap:HeapAllocation, ?heaptype:Type, ?class:Type)</li>
<li> .decl ClassAndTypeToRepresentative(?type:Type, ?class:Type, ?reprHeap:HeapAllocation)</li>
<li> .decl ClassIterationTrick(?length:number)</li>
<li> .decl ClassNameMatchingStringConstant_Type(?type:Type, ?heap:HeapAllocation)</li>
<li> .decl ClassNameSuffix(?suffix:symbol, ?classname:ReferenceType)</li>
<li> .decl ExceptionHeapTypeRepresentativeOrdinal(?type:Type, ?reprHeapOrd:number)</li>
<li> .decl ExceptionType(?type:Type)</li>
<li> .decl ExceptionTypeToHeap(?heap:HeapAllocation, ?type:Type)</li>
<li> .decl FieldNameMatchingStringConstant_Signature(?sig:Field, ?heap:HeapAllocation)</li>
<li> .decl FieldNamePrefix(?prefix:symbol, ?sig:Field)</li>
<li> .decl FieldNameSuffix(?suffix:symbol, ?sig:Field)</li>
<li> .decl FieldOfClassMatchesString(?heap:HeapAllocation, ?type:Type)</li>
<li> .decl HeapAllocation_ContextInsensitive(?heap:HeapAllocation)</li>
<li> .decl HeapAllocation_Keep(?heap:HeapAllocation)</li>
<li> .decl HeapAllocation_Merge(?heap:HeapAllocation, ?mergeHeap:HeapAllocation)</li>
<li> .decl HeapIsMergedString(?heap:HeapAllocation)</li>
<li> .decl HeapIsMergedStringFactory(?heap:HeapAllocation)</li>
<li> .decl HeapRepresentative(?heap:HeapAllocation, ?heapRepr:symbol)</li>
<li> .decl MemberPrefixIterationTrick(?length:number)</li>
<li> .decl MemberSuffixIterationTrick(?length:number)</li>
<li> .decl MethodAllocationMergeThreshold(?t:number)</li>
<li> .decl MethodAndTypeToHeap(?heap:HeapAllocation, ?heapType:Type, ?method:Method)</li>
<li> .decl MethodAndTypeToMergedHeap(?heap:HeapAllocation, ?heaptype:Type, ?meth:Method)</li>
<li> .decl MethodAndTypeToRepresentative(?type:Type, ?meth:Method, ?reprHeap:HeapAllocation)</li>
<li> .decl MethodNameMatchingStringConstant_Signature(?sig:Method, ?heap:HeapAllocation)</li>
<li> .decl MethodNamePrefix(?prefix:symbol, ?sig:Method)</li>
<li> .decl MethodNameSuffix(?suffix:symbol, ?sig:Method)</li>
<li> .decl MethodOfClassMatchesString(?heap:HeapAllocation, ?type:Type)</li>
<li> .decl MinHeapOrdinalPerClassAndType(?minHeapOrd:number, ?type:Type, ?class:Type)</li>
<li> .decl MinHeapOrdinalPerMethodAndType(?ord:number, ?type:Type, ?meth:Method)</li>
<li> .decl MinHeapOrdinalPerPackageAndType(?minHeapOrd:number, ?type:Type, ?packageName:symbol)</li>
<li> .decl MinHeapOrdinalPerType(?minHeapOrd:number, ?type:Type)</li>
<li> .decl MinRepresentativeHeapToPickFromOrdinal(?minHeapReprOrd:number, ?heap:HeapAllocation)</li>
<li> .decl MinStringFactoryHeapOrdinalPerPackageAndType(?minHeapOrd:number, ?type:Type, packageName:symbol)</li>
<li> .decl MinStringOrdinalForColor(?color:number, ?minHeapOrd:number)</li>
<li> .decl MinStringOrdinalGreaterThanOtherInSameClass(?heap:HeapAllocation, ?heapGreaterOrd:number, ?type:Type)</li>
<li> .decl MinimalSuffix(?type:Type, ?suffix:symbol)</li>
<li> .decl MinimalSuffixLen(?type:Type, ?suffixLen:number)</li>
<li> .decl NonTrivialStringConstant(?heap:StringConstant)</li>
<li> .decl ObjectMultipleAllocated(?heap:HeapAllocation)</li>
<li> .decl OptAssignHeapAllocation(?inmethod:Method, ?heap:HeapAllocation)</li>
<li> .decl PackageAndTypeToHeap(?heap:HeapAllocation, ?heaptype:Type, ?packageName:symbol)</li>
<li> .decl PackageAndTypeToMergedHeap(?heap:HeapAllocation, ?heaptype:Type, ?packageName:symbol)</li>
<li> .decl PackageAndTypeToRepresentative(?type:Type, ?packageName:symbol, ?representativeHeap:HeapAllocation)</li>
<li> .decl PackageAndTypeToStringFactoryHeap(?heap:HeapAllocation, ?type:Type, ?packageName:symbol)</li>
<li> .decl PackageAndTypeToStringFactoryRepresentative(?type:Type, ?packageName:symbol, ?representativeHeap:HeapAllocation)</li>
<li> .decl PreClassNameMatchingStringConstant(?heap:HeapAllocation)</li>
<li> .decl PreClassNameMatchingStringConstantExact_Type(?type:Type, ?heap:HeapAllocation)</li>
<li> .decl PreClassNameMatchingStringConstantInexact_Type(?type:Type, ?heap:HeapAllocation)</li>
<li> .decl PreClassNameMatchingStringConstant_Type(?type:Type, ?heap:HeapAllocation)</li>
<li> .decl PreFieldNameMatchingStringConstant(?heap:HeapAllocation)</li>
<li> .decl PreFieldNameMatchingStringConstantExact_Signature(?sig:Field, ?heap:HeapAllocation)</li>
<li> .decl PreFieldNameMatchingStringConstantInexact_Signature(?sig:Field, ?heap:HeapAllocation)</li>
<li> .decl PreFieldNameMatchingStringConstant_Signature(?sig:Field, ?heap:HeapAllocation)</li>
<li> .decl PreMethodNameMatchingStringConstant(?heap:HeapAllocation)</li>
<li> .decl PreMethodNameMatchingStringConstantExact_Signature(?sig:Method, ?heap:HeapAllocation)</li>
<li> .decl PreMethodNameMatchingStringConstantInexact_Signature(?sig:Method, ?heap:HeapAllocation)</li>
<li> .decl PreMethodNameMatchingStringConstant_Signature(?sig:Method, ?heap:HeapAllocation)</li>
<li> .decl ReflectionStringConstant(?heap:HeapAllocation)</li>
<li> .decl ReflectionSubstringObject(?heap:HeapAllocation)</li>
<li> .decl RelevantSuffixPosition(?typeName: Type, ?pos:number)</li>
<li> .decl RepresentativesToPickFrom(?heapRepr:HeapAllocation, ?heap:HeapAllocation)</li>
<li> .decl SpringBeanId(?id:symbol)</li>
<li> .decl StringColorForHeap(?heap:HeapAllocation, ?color:number)</li>
<li> .decl StringColorGreaterThan(?num:number, ?heap:HeapAllocation)</li>
<li> .decl StringFactoryHeap(?heap:HeapAllocation)</li>
<li> .decl StringFactoryType(?type:Type)</li>
<li> .decl StringGreaterThanOtherInSameClass(?heap1:HeapAllocation, ?heap2:HeapAllocation, ?type:Type)</li>
<li> .decl StringImmediatelyGreaterThanOtherInSomeClass(?heapGreater:HeapAllocation, ?heap:HeapAllocation)</li>
<li> .decl StringImmediatelyLessThanOtherInClass(?heap:HeapAllocation, ?type:Type, ?heapGreater:HeapAllocation)</li>
<li> .decl StringRepresentativeForColor(?color:number, ?heap:HeapAllocation)</li>
<li> .decl Suffix(?type:Type, ?suffix:symbol, ?suffixLen:number)</li>
<li> .decl TypeToHeap(?heap:HeapAllocation, ?heaptype:Type)</li>
<li> .decl TypeToMergedHeap(?heap:HeapAllocation, ?heaptype:Type)</li>
<li> .decl TypeToRepresentative(?type:Type, ?representativeHeap:HeapAllocation)</li>
<li> .decl Type_DeclaresReferenceField(?type:Type)</li>
<li> .decl Type_HasNoReferenceField(?type:Type)</li>
<li> .decl ValidPrefixForField(?field:Field, ?fieldName:symbol, ?length:number)</li>
<li> .decl ValidPrefixForMethod(?method:Method, ?methodName:symbol, ?length:number)</li>
<li> .decl ValidSuffixForField(?field:Field, ?fieldName:symbol, ?index:number, ?length:number)</li>
<li> .decl ValidSuffixForMethod(?method:Method, ?methodName:symbol, ?index:number, ?length:number)</li>
<li> .decl ValidSuffixForType(?className:symbol, ?index:number, ?length:number)</li>
<li> .decl _StringFactoryType(?type:Type)</li>
<li> .decl _StringIterationTrick(?pos:number)</li>
<li> .decl string_upper(s1:symbol, s2:symbol)</li>
</ul>
<h2> main/threads-declarations.dl </h2>
<ul>
<li> .decl FakeInvocation_MainThreadInit(?invo: MethodInvocation)</li>
<li> .decl FakeInvocation_SystemThreadGroupInit(?invo: MethodInvocation)</li>
<li> .decl FakeInvocation_ThreadGroupInit(?invo: MethodInvocation)</li>
<li> .decl ReachableCurrentThreadInvocation(?callerCtx:configuration.Context, ?local:Var)</li>
<li> .decl RunningThread(?hctx:configuration.HContext, ?value:Value)</li>
</ul>
<h2> main/threads.dl </h2>
<ul>
<li> .decl _ReachableValuesWithRunMethod(?hctx:configuration.HContext, ?value:Value, ?run:Method)</li>
</ul>
<h2> main/zipper-pre-analysis.dl </h2>
<ul>
<li> .decl AllCallGraphEdge(?from:MethodInvocation, ?to:Method)</li>
<li> .decl ArrayLoad(?to:Var, ?array:Value)</li>
<li> .decl ArrayStore(?array:Value, ?from:Var)</li>
<li> .decl CallReturnTo(?recv:Var, ?to:Var)</li>
<li> .decl CallSiteIn(?invo:MethodInvocation, ?method:Method)</li>
<li> .decl Formal_Param(?method:Method, ?param:Var)</li>
<li> .decl InstanceInvocationReceiver(?invo:MethodInvocation, ?recv:Var)</li>
<li> .decl InstanceLoad(?to:Var, ?baseObj:Value, ?field:Field)</li>
<li> .decl InstanceStore(?baseObj:Value, ?field:Field, ?from:Var)</li>
<li> .decl Instance_Method(?method:Method)</li>
<li> .decl InterproceduralAssign(?to:Var, ?from:Var)</li>
<li> .decl LocalAssign(?to:Var, ?from:Var)</li>
<li> .decl ObjType(?obj:Value, ?type:Type)</li>
<li> .decl ObjectAssign(?obj:Value, ?var:Var)</li>
<li> .decl ObjectIn(?object:Value, ?inmethod:Method)</li>
<li> .decl RetVar(?method:Method, ?ret:Var)</li>
<li> .decl This_Var(?method:Method, ?var:Var)</li>
<li> .decl VarIn(?var:Var, ?method:Method)</li>
</ul>
<h2> python/addons/statistics/statistics-simple-declarations.dl </h2>
<ul>
<li> .decl ImpreciseTensorShapeList_Insens(?shape:Value)</li>
<li> .decl Stats_Simple_AssignedVariable(?var:Var)</li>
<li> .decl Stats_Simple_InsensCallGraphEdge(?from:FunctionInvocation_Insn, ?to:Function)</li>
<li> .decl Stats_Simple_InsensReachableVar(?var:Var)</li>
<li> .decl Stats_Simple_InsensVarPointsTo(?value:Value, ?var:Var)</li>
<li> .decl Stats_Simple_ReachableVar(?ctx:mainAnalysis.configuration.Context, ?var:Var)</li>
<li> .decl Stats_Simple_VirtualCallGraphEdge(?from:FunctionInvocation_Insn, ?to:Function)</li>
<li> .decl TensorHasMoreThanOneShape_Insens(?tensor:Value)</li>
<li> .decl TensorOpHasImpreciseArg_Insens(?insn:FunctionInvocation_Insn, ?operationVal:Value)</li>
<li> .decl TensorOperationError_Insens(?insn:FunctionInvocation_Insn, ?tensor:Value, ?msg:symbol)</li>
<li> .decl TensorOperationProducesOutput_Insens(?insn:FunctionInvocation_Insn)</li>
<li> .decl TensorOperationProducesOutput_ValueIns(?ctx:mainAnalysis.configuration.Context, ?insn:FunctionInvocation_Insn)</li>
<li> .decl TensorOperationWarning_Insens(?insn:FunctionInvocation_Insn, ?tensor:Value, ?msg:symbol)</li>
</ul>
<h2> python/facts/import-entities.dl </h2>
<ul>
<li> .decl _ActualKeywordParam(?index:number, ?invocation:symbol, ?keyword:symbol, ?var:symbol)</li>
<li> .decl _ActualPositionalParam(?index:number, ?invocation:symbol, ?var:symbol)</li>
<li> .decl _ApplicationClass(?type:symbol)</li>
<li> .decl _AssignReturnValue(?invocation:symbol, ?to:symbol)</li>
<li> .decl _ClassType(?class:symbol)</li>
<li> .decl _DirectSuperclass(?class:symbol, ?superclass:symbol)</li>
<li> .decl _ExceptionHandler_Previous(?handler:symbol, ?previous:symbol)</li>
<li> .decl _FormalParam(?index:number, ?paramName:symbol, ?function:symbol, ?var:symbol)</li>
<li> .decl _FormalParam_DefaultValueVar(?function:symbol, ?index:number, ?var:symbol)</li>
<li> .decl _NativeReturnVar(?var:symbol, ?function:symbol)</li>
<li> .decl _ThisVar(?function:symbol, ?var:symbol)</li>
<li> .decl _Var_DeclaringFunction(?var:symbol, ?method:symbol)</li>
</ul>
<h2> python/facts/import-facts.dl </h2>
<ul>
<li> .decl String_toRaw(?id:symbol, ?rawId:symbol)</li>
<li> .decl _AssignBinop(?instruction:symbol, ?index:number, ?to:symbol, ?oper:symbol, ?inFunction:symbol)</li>
<li> .decl _AssignBoolConstant(?instruction:symbol, ?index:number, ?const:symbol, ?to:symbol, ?inFunction:symbol)</li>
<li> .decl _AssignFloatConstant(?instruction:symbol, ?index:number, ?const:symbol, ?to:symbol, ?inFunction:symbol)</li>
<li> .decl _AssignHeapAllocation(?instruction:symbol, ?index:number, ?heap:symbol, ?to:symbol, ?inFunction:symbol)</li>
<li> .decl _AssignIntConstant(?instruction:symbol, ?index:number, ?const:symbol, ?to:symbol, ?inFunction:symbol)</li>
<li> .decl _AssignLocal(?instruction:symbol, ?index:number, ?from:symbol, ?to:symbol, ?inFunction:symbol)</li>
<li> .decl _AssignNone(?instruction:symbol, ?index:number, ?to:symbol, ?inFunction:symbol)</li>
<li> .decl _AssignOperFrom(?instruction:symbol, ?operNum:number, ?from:symbol)</li>
<li> .decl _AssignUnop(?instruction:symbol, ?index:number, ?to:symbol, ?oper:symbol, ?inFunction:symbol)</li>
<li> .decl _CollectionRead(?insn:symbol, ?index:number, ?to:symbol, ?collection:symbol, ?indexOrKey:symbol, ?function:symbol)</li>
<li> .decl _CollectionWrite(?insn:symbol, ?index:number, ?collection:symbol, ?indexOrKey:symbol, ?from:symbol, ?function:symbol)</li>
<li> .decl _ComprehensionFunction(?function:symbol)</li>
<li> .decl _ExceptionHandler(?handler:symbol, ?function:symbol, ?index:number, ?type:symbol, ?var:symbol, ?begin:number, ?end:number)</li>
<li> .decl _Field(?signature:symbol, ?declaringClass:symbol, ?simplename:symbol)</li>
<li> .decl _File_DeclaringPackage(?file:symbol, ?name:symbol, ?declPackage:symbol)</li>
<li> .decl _Function(?function:symbol, ?simplename:symbol, ?declaringType:symbol, ?arity:number, ?declaredInFile: File)</li>
<li> .decl _FunctionInvocation(?instruction:symbol, ?index:number, ?to:symbol, ?base:symbol, ?function:symbol)</li>
<li> .decl _FunctionInvocation_NumberOfActualParams(?invocation:symbol, ?total:number)</li>
<li> .decl _Function_SourcePosition(?fun:symbol, ?startLine:number, ?endLine:number, ?startColumn:number, ?endColumn:number)</li>
<li> .decl _GlobalRead(?instruction:symbol, ?index: number, ?to:symbol, ?name:symbol, ?inFunct:symbol)</li>
<li> .decl _GlobalWrite(?instruction:symbol, ?index: number, ?name:symbol, ?from:symbol, ?inFunct:symbol)</li>
<li> .decl _Goto(?instruction:symbol, ?index:number, ?to:number, ?function:symbol)</li>
<li> .decl _If(?instruction:symbol, ?index:number, ?to:number, ?function:symbol)</li>
<li> .decl _IfVar(?instruction:symbol, ?var:symbol)</li>
<li> .decl _Import(?instruction:symbol, ?index: number, ?name:symbol, ?to:symbol, ?inFunct:symbol)</li>
<li> .decl _Instruction_SourcePosition(?insn:symbol, ?startLine:number, ?endLine:number, ?startColumn:number, ?endColumn:number)</li>
<li> .decl _LexicalRead(?instruction:symbol, ?index: number, ?to:symbol, ?name:symbol, ?scope:symbol, ?inFunct:symbol)</li>
<li> .decl _LexicalWrite(?instruction:symbol, ?index: number, ?name:symbol, ?scope:symbol, ?from:symbol, ?inFunct:symbol)</li>
<li> .decl _LoadInstanceField(?instruction:symbol, ?index:number, ?to:symbol, ?base:symbol, ?fieldName:symbol, ?function:symbol)</li>
<li> .decl _NormalHeap(?id:symbol, ?type:symbol)</li>
<li> .decl _OriginalIntConstant(?intConst:symbol)</li>
<li> .decl _Package_DeclaringPackage(?file:symbol, ?name:symbol, ?declPackage:symbol)</li>
<li> .decl _Return(?instruction:symbol, ?index:number, ?var:symbol, ?function:symbol)</li>
<li> .decl _ReturnNone(?instruction:symbol, ?index:number, ?function:symbol)</li>
<li> .decl _StoreInstanceField(?instruction:symbol, ?index:number, ?from:symbol, ?base:symbol, ?fieldName:symbol, ?function:symbol)</li>
<li> .decl _StringConstant(?id:symbol)</li>
<li> .decl _StringRaw(?id:symbol, ?rawId:symbol)</li>
<li> .decl _Throw(?instruction:symbol, ?index:number, ?var:symbol, ?function:symbol)</li>
<li> .decl _UnsupportedInstruction(?instruction:symbol, ?index:number, ?function:symbol)</li>
<li> .decl _Var_SourceName(?var:symbol, ?name:symbol)</li>
</ul>
<h2> python/facts/post-process.dl </h2>
<ul>
<li> .decl AssignBinOper_Info(?instr:Instruction, ?op:symbol, ?var1:Var, ?var2:Var)</li>
</ul>
<h2> python/facts/schema.dl </h2>
<ul>
<li> .decl ActualKeywordParam(?index:number, ?invocation:FunctionInvocation_Insn, ?keyword:symbol, ?var:Var)</li>
<li> .decl ActualPositionalParam(?index:number, ?invocation:FunctionInvocation_Insn, ?var:Var)</li>
<li> .decl ApplicationClass(?ref:ClassType)</li>
<li> .decl ApplicationFunction(?function:Function)</li>
<li> .decl ApplicationVar(?var:Var)</li>
<li> .decl AssignBoolConstant_Id(?insn:AssignBoolConstant_Insn, ?const:BoolConstant)</li>
<li> .decl AssignCast(?type:Type, ?from:Var, ?to:Var, ?inFunction:Function)</li>
<li> .decl AssignFloatConstant_Id(?insn:AssignFloatConstant_Insn, ?const:FloatConstant)</li>
<li> .decl AssignHeapAllocation(?heap:HeapAllocation, ?to:Var, ?inFunction:Function)</li>
<li> .decl AssignHeapAllocation_Heap(?insn:AssignHeapAllocation_Insn, ?heap:HeapAllocation)</li>
<li> .decl AssignInstruction_To(?insn:AssignInstruction, ?to:Var)</li>
<li> .decl AssignIntConstant_Id(?insn:AssignIntConstant_Insn, ?const:IntConstant)</li>
<li> .decl AssignLocal(?from:Var, ?to:Var, ?inFunction:Function)</li>
<li> .decl AssignLocal_From(?insn:AssignLocal_Insn, ?from:Var)</li>
<li> .decl AssignNull(?to:Var, ?inFunction:Function)</li>
<li> .decl AssignOper_From(?insn:AssignOper_Insn, ?operNum:number, ?from:Var)</li>
<li> .decl AssignReturnValue(?invocation:FunctionInvocation_Insn, ?to:Var)</li>
<li> .decl Assign_Operation(?insn:AssignOper_Insn, ?oper:symbol)</li>
<li> .decl CollectionAccessInsn_Base(?insn:CollectionAccess_Insn, ?base:Var)</li>
<li> .decl CollectionAccessInsn_IndexOrKey(?insn:CollectionAccess_Insn, ?indexOrKey:Var)</li>
<li> .decl DirectSuperclass(?class:ClassType, ?superclass:ClassType)</li>
<li> .decl ExceptionHandler_Begin(?handler:ExceptionHandler, ?index:number)</li>
<li> .decl ExceptionHandler_End(?handler:ExceptionHandler, ?index:number)</li>
<li> .decl ExceptionHandler_FormalParam(?handler:ExceptionHandler, ?var:Var)</li>
<li> .decl ExceptionHandler_Function(?handler:ExceptionHandler, ?inFunction:Function)</li>
<li> .decl ExceptionHandler_Index(?handler:ExceptionHandler, ?index:number)</li>
<li> .decl ExceptionHandler_Previous(?handler:ExceptionHandler, ?previous:ExceptionHandler)</li>
<li> .decl ExceptionHandler_Type(?handler:ExceptionHandler, ?type:Type)</li>
<li> .decl FieldInstruction_Signature(?insn:FieldInstruction, ?fieldName:symbol)</li>
<li> .decl Field_DeclaringType(?field:Field, ?declaringClass:ClassType)</li>
<li> .decl Field_SimpleName(?field:Field, ?simpleName:symbol)</li>
<li> .decl FormalParam(?index:number, ?paramName:symbol, ?function:Function, ?var:Var)</li>
<li> .decl FormalParam_DefaultValForIndex(?function:Function,?paramIndex:number, ?from:Var)</li>
<li> .decl FormalParam_DefaultValForName(?function:Function,?paramName:symbol, ?from:Var)</li>
<li> .decl FunctionInvocation(?invocation:FunctionInvocation_Insn, ?inFunction:Function)</li>
<li> .decl FunctionInvocation_Base(?invocation:FunctionInvocation_Insn, ?base:Var)</li>
<li> .decl FunctionInvocation_NumberOfActualParams(?invocation:FunctionInvocation_Insn, ?total:number)</li>
<li> .decl Function_Arity(?function:Function, ?arity:number)</li>
<li> .decl Function_DeclaredInFile(?function:Function, ?file:File)</li>
<li> .decl Function_Module(?function:Function, ?module: Module)</li>
<li> .decl Function_NumOfRequiredParams(?function:Function, ?numOfParams:number)</li>
<li> .decl Function_SimpleName(?function:Function, ?simpleName:symbol)</li>
<li> .decl Function_SourcePosition(?function:Function, ?startLine:number, ?endLine:number, ?startColumn:number, ?endColumn:number)</li>
<li> .decl GlobalAccessInsn_Name(?insn: GlobalAccess_Insn, ?name:symbol)</li>
<li> .decl GlobalAccessInsn_Scope(?insn: GlobalAccess_Insn, ?scope:Scope)</li>
<li> .decl GlobalWriteInsn_From(?insn: GlobalAccess_Insn, ?from:Var)</li>
<li> .decl Goto_Target(?insn:Goto_Insn, ?index:number)</li>
<li> .decl HeapAllocation_Type(?heap:HeapAllocation, ?type:Type)</li>
<li> .decl If_Target(?insn:If_Insn, ?index:number)</li>
<li> .decl If_Var(?insn:If_Insn, ?var:Var)</li>
<li> .decl ImportInsn_ModuleName(?insn: ImportInstruction, ?name:symbol)</li>
<li> .decl Instruction_Function(?insn:Instruction, ?inFunction:Function)</li>
<li> .decl Instruction_Index(?insn:Instruction, ?index:number)</li>
<li> .decl Instruction_SourcePosition(?insn:Instruction, ?startLine:number, ?endLine:number, ?startColumn:number, ?endColumn:number)</li>
<li> .decl LexicalAccessInsn_Name(?insn: LexicalAccess_Insn, ?name:symbol)</li>
<li> .decl LexicalAccessInsn_VarScope(?insn: LexicalAccess_Insn, ?scope:Function)</li>
<li> .decl LexicalWriteInsn_From(?insn: LexicalAccess_Insn, ?from:Var)</li>
<li> .decl LoadInstanceField(?base:Var, ?sig:Field, ?to:Var, ?inFunction:Function)</li>
<li> .decl LoadInstanceField_Base(?insn:LoadInstanceField_Insn, ?var:Var)</li>
<li> .decl LoadInstanceField_To(?insn:LoadInstanceField_Insn, ?var:Var)</li>
<li> .decl Module_DeclaringPackage(?module: Module, ?moduleName:symbol, ?declPackage: Package)</li>
<li> .decl NativeReturnVar(?var:Var, ?function:Function)</li>
<li> .decl OriginalHeapAllocation_Type(?heap:HeapAllocation, ?type:Type)</li>
<li> .decl Package_DeclaringPackage(?pack: Package, ?packageName:symbol, ?declPackage: Package)</li>
<li> .decl ReadFromCollectionInsn_To(?insn:ReadFromCollection_Insn, ?to:Var)</li>
<li> .decl ReturnNonNone_Var(?return:ReturnNonNone_Insn, ?var:Var)</li>
<li> .decl ReturnVar(?var:Var, ?function:Function)</li>
<li> .decl Stats_Metrics(order:symbol, msg:symbol, c:number)</li>
<li> .decl StoreInstanceField(?from:Var, ?base:Var, ?signature:Field, ?inFunction:Function)</li>
<li> .decl StoreInstanceField_Base(?insn:StoreInstanceField_Insn, ?var:Var)</li>
<li> .decl StoreInstanceField_From(?insn:StoreInstanceField_Insn, ?var:Var)</li>
<li> .decl ThisVar(?function:Function, ?var:Var)</li>
<li> .decl Throw(?insn:Throw_Insn, ?var:Var)</li>
<li> .decl Throw_Var(?insn:Throw_Insn, ?var:Var)</li>
<li> .decl Type_boolean(?t:PrimitiveType)</li>
<li> .decl Type_complex(?t:PrimitiveType)</li>
<li> .decl Type_float(?t:PrimitiveType)</li>
<li> .decl Type_int(?t:PrimitiveType)</li>
<li> .decl Type_long(?t:PrimitiveType)</li>
<li> .decl Type_none(?t:PrimitiveType)</li>
<li> .decl Type_string(?t:PrimitiveType)</li>
<li> .decl Var_DeclaringFunction(?var:Var, ?function:Function)</li>
<li> .decl Var_SourceName(?var:Var, ?name:symbol)</li>
<li> .decl WriteToCollectionInsn_From(?insn:WriteToCollection_Insn, ?from:Var)</li>
<li> .decl isAssignBinop_Insn(?insn:AssignBinop_Insn)</li>
<li> .decl isAssignBoolConstant_Insn(?insn:AssignBoolConstant_Insn)</li>
<li> .decl isAssignFloatConstant_Insn(?insn:AssignFloatConstant_Insn)</li>
<li> .decl isAssignHeapAllocation_Insn(?insn:AssignHeapAllocation_Insn)</li>
<li> .decl isAssignInstruction(?insn:AssignInstruction)</li>
<li> .decl isAssignIntConstant_Insn(?insn:AssignIntConstant_Insn)</li>
<li> .decl isAssignLocal_Insn(?insn:AssignLocal_Insn)</li>
<li> .decl isAssignNone_Insn(?insn:AssignNone_Insn)</li>
<li> .decl isAssignOper_Insn(?insn:AssignOper_Insn)</li>
<li> .decl isAssignUnop_Insn(?insn:AssignUnop_Insn)</li>
<li> .decl isBoolConstant(?n:BoolConstant)</li>
<li> .decl isClassType(?t:ClassType)</li>
<li> .decl isCollectionAccess_Insn(?insn:CollectionAccess_Insn)</li>
<li> .decl isComprehensionFunction(?m:Function)</li>
<li> .decl isConstructorMethod(?m:Function)</li>
<li> .decl isExceptionHandler(?handler:ExceptionHandler)</li>
<li> .decl isField(?field:Field)</li>
<li> .decl isFieldInstruction(?insn:FieldInstruction)</li>
<li> .decl isFile(file:File)</li>
<li> .decl isFloatConstant(?n:FloatConstant)</li>
<li> .decl isFunction(?m:Function)</li>
<li> .decl isFunctionInvocation(?insn:FunctionInvocation_Insn)</li>
<li> .decl isGenericField(?field:Field)</li>
<li> .decl isGlobalAccess_Insn(?insn: GlobalAccess_Insn)</li>
<li> .decl isGlobalRead_Insn(?insn: GlobalRead_Insn)</li>
<li> .decl isGlobalWrite_Insn(?insn: GlobalWrite_Insn)</li>
<li> .decl isGoto_Insn(?insn:Goto_Insn)</li>
<li> .decl isHeapAllocation(?h:HeapAllocation)</li>
<li> .decl isIf_Insn(?insn:If_Insn)</li>
<li> .decl isImportInstruction(?insn: ImportInstruction)</li>
<li> .decl isInstruction(?insn:Instruction)</li>
<li> .decl isIntConstant(?n:IntConstant)</li>
<li> .decl isLexicalAccess_Insn(?insn: LexicalAccess_Insn)</li>
<li> .decl isLexicalRead_Insn(?insn: LexicalRead_Insn)</li>
<li> .decl isLexicalWrite_Insn(?insn: LexicalWrite_Insn)</li>
<li> .decl isLoadInstanceField_Insn(?insn:LoadInstanceField_Insn)</li>
<li> .decl isMethod(?m:Function)</li>
<li> .decl isModeledFunction(?m:Function)</li>
<li> .decl isModeledModule(?module:Module)</li>
<li> .decl isModule(?module:Module)</li>
<li> .decl isNormalHeap(?h:NormalHeap)</li>
<li> .decl isNumConstant(?n:NumConstant)</li>
<li> .decl isOriginalIntConstant(?n:IntConstant)</li>
<li> .decl isPackage(package:Package)</li>
<li> .decl isPrimitiveType(?t:PrimitiveType)</li>
<li> .decl isReadFromCollection_Insn(?insn: ReadFromCollection_Insn)</li>
<li> .decl isReturnInstruction(?insn:ReturnInstruction)</li>
<li> .decl isReturnNonNone_Insn(?insn:ReturnNonNone_Insn)</li>
<li> .decl isReturnNone_Insn(?insn:ReturnNone_Insn)</li>
<li> .decl isStoreInstanceField_Insn(?insn:StoreInstanceField_Insn)</li>
<li> .decl isStringConstant(?h:StringConstant)</li>
<li> .decl isStringRaw(?id:symbol)</li>
<li> .decl isThrow_Insn(?insn:Throw_Insn)</li>
<li> .decl isType(?t:Type)</li>
<li> .decl isUnsupportedInstruction(?insn:UnsupportedInstruction)</li>
<li> .decl isVar(v:Var)</li>
<li> .decl isWriteToCollection_Insn(?insn: WriteToCollection_Insn)</li>
</ul>
<h2> python/lib-specific/default-python-lib.dl </h2>
<ul>
<li> .decl ArgParseValueDefaultNamespace(?argVal:Value, ?argHctx:configuration.HContext, ?nameSpaceVal:Value)</li>
<li> .decl BuiltInOpProducesOutput(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?operationVal:Value)</li>
<li> .decl BuiltInOp_NameToVal(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?operationVal:Value, ?name:symbol, ?namedValHctx:configuration.HContext, ?namedVal:Value)</li>
<li> .decl LenOp(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?lenOp:Value, ?inValHctx:configuration.HContext, ?inVal:Value)</li>
<li> .decl RangeOp(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?rangeOp:Value)</li>
<li> .decl RangeOpOneArg(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?rangeOp:Value)</li>
<li> .decl RawString_RemoveDashes(?before:StringConstant, ?after:symbol)</li>
</ul>
<h2> python/lib-specific/modeled.dl </h2>
<ul>
<li> .decl ModeledClass(?class:ClassType, ?name:symbol, ?declaringModule: Module)</li>
<li> .decl ModeledFunction(?function:Function, ?name:symbol, ?declaringModule: Module)</li>
<li> .decl ModeledMethod(?method:Function, ?name:symbol, ?declaringClass: ClassType, ?inModule: Module)</li>
<li> .decl ModeledModule(?module:Module, ?name:symbol, ?declaringModule: Module)</li>
</ul>
<h2> python/lib-specific/numpy.dl </h2>
<ul>
<li> .decl NumPyOperationOutputHCtx(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?operationVal:Value, ?hctx:configuration.HContext)</li>
<li> .decl NumPyOperationOutputShape(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?operationVal:Value, ?shapeHctx:configuration.HContext, ?shape:Value)</li>
<li> .decl NumPyOperationProducesOutput(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?operationVal:Value)</li>
<li> .decl NumPyOperation_NameToVal(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?operationVal:Value, ?name:symbol, ?namedValHctx:configuration.HContext, ?namedVal:Value)</li>
<li> .decl NumpyArrayOp(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?npArrayOp:Value)</li>
<li> .decl NumpyArrayShape(?arrayHctx:configuration.HContext, ?array:Value, ?shapeHctx:configuration.HContext, ?shapeList:Value)</li>
<li> .decl NumpyArrayShapeListContent(?hctx:configuration.HContext, ?val:Value, ?index:number, ?indexValue:Value)</li>
<li> .decl NumpyArrayShapeListLength(?hctx:configuration.HContext, ?val:Value, ?size:number)</li>
<li> .decl NumpyGetSubArrayOp(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?npSubArrayOp:Value)</li>
<li> .decl NumpyGetSubArrayOpInArray(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?npSubArrayOp:Value, ?inArrayHctx:configuration.HContext, ?inArray:Value)</li>
<li> .decl NumpyGetSubArrayOpIndex(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?npSubArrayOp:Value, ?index:number)</li>
<li> .decl NumpyRandNArrayOp(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?npRandArrayOp:Value, ?outLen:number)</li>
<li> .decl NumpyRandNArrayOpDimensionResult(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?npRandArrayOp:Value, ?dim:number, ?dimRes:Value)</li>
<li> .decl NumpyRandNArrayOpHaveResUpToX(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?npRandArrayOp:Value, ?upTo:number)</li>
<li> .decl NumpyRandomArrayOp(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?npRandArrayOp:Value)</li>
<li> .decl NumpyRandomArrayOpFunction(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?npRandArrayOp:Value, ?fun:Function)</li>
<li> .decl NumpyRandomFunction_Info(?function:Function, ?type:symbol, ?defVal:Value)</li>
</ul>
<h2> python/lib-specific/tensorflow/arithmetic-ops.dl </h2>
<ul>
<li> .decl BroadcastingFunctionInfo(?function:Function, ?funName:symbol)</li>
<li> .decl TfBroadcastingOp(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?broadcastingOp:Value, ?offset:number)</li>
<li> .decl TfBroadcastingOpAllDimsHaveRes(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?broadcastingOp:Value)</li>
<li> .decl TfBroadcastingOpAllDimsUpToXHaveRes(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?broadcastingOp:Value, ?index:number)</li>
<li> .decl TfBroadcastingOpBroadcastWarning(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?broadcastingOp:Value)</li>
<li> .decl TfBroadcastingOpCannotBroadcast(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?broadcastingOp:Value)</li>
<li> .decl TfBroadcastingOpResultShapeListContent(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?broadcastingOp:Value, ?index:number, ?indexVal:Value)</li>
<li> .decl TfBroadcastingOpResultShapeListLength(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?broadcastingOp:Value, ?len:number)</li>
<li> .decl TfMatMulOp(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?matMulOp:Value)</li>
<li> .decl TfMatMulOpAllDimsHaveRes(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?matMulOp:Value)</li>
<li> .decl TfMatMulOpAllDimsUpToXHaveRes(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?matMulOp:Value, ?index:number)</li>
<li> .decl TfMatMulOpCorrectTypeArgs(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?matMulOp:Value)</li>
<li> .decl TfMatMulOpDifferentNumOfDims(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?matMulOp:Value)</li>
<li> .decl TfMatMulOpDimIsCompatible(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?matMulOp:Value, ?dim:number, ?dimVal:Value)</li>
<li> .decl TfMatMulOpFull(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?matMulOp:Value, ?tensor1Hctx:configuration.HContext, ?tensor1:Value, ?tensor2Hctx:configuration.HContext, ?tensor2:Value)</li>
<li> .decl TfMatMulOpInTensorsSameNumOfDim(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?matMulOp:Value, ?ndims:number)</li>
<li> .decl TfMatMulOpIncompatible(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?matMulOp:Value)</li>
<li> .decl TfMatMulOpRowsNColsCompatible(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?matMulOp:Value)</li>
</ul>
<h2> python/lib-specific/tensorflow/general-tensor-modeling.dl </h2>
<ul>
<li> .decl ImpreciseTensorShapeList(?shapeValHctx:configuration.HContext, ?shapeVal:Value)</li>
<li> .decl PossibleDimValue_Representation(?val:Value, ?repr:symbol)</li>
<li> .decl TensorDType(?tensorHctx:configuration.HContext, ?tensor:Value, ?dtypeHctx:configuration.HContext, ?dtype:Value)</li>
<li> .decl TensorFlowsToSelf(?ctx:configuration.Context, ?tensor:Value)</li>
<li> .decl TensorFlowsToSelf_Insens(?tensor:Value)</li>
<li> .decl TensorFlowsToTensorOp(?fromHctx:configuration.HContext, ?from:Value, ?toCtx:configuration.Context, ?to:Value)</li>
<li> .decl TensorFlowsToTensor_Insens(?from:Value, ?to:Value)</li>
<li> .decl TensorHasMoreThanOneShape(?tensorHctx:configuration.HContext, ?tensor:Value)</li>
<li> .decl TensorLikeObjectShapeConcatUpToDim(?hctx:configuration.HContext, ?val:Value, ?concatdims:symbol, ?upToDim:number)</li>
<li> .decl TensorLikeObjectShapeInfo(?hctx:configuration.HContext, ?val:Value, ?shapeStr:symbol)</li>
<li> .decl TensorLikeObjectShapeListContent(?hctx:configuration.HContext, ?val:Value, ?index:number, ?indexValue:Value)</li>
<li> .decl TensorLikeObjectShapeListLength(?hctx:configuration.HContext, ?val:Value, ?size:number)</li>
<li> .decl TensorLikeObjectToTensorDtype(?hctx:configuration.HContext, ?val:Value, ?dtypeHctx:configuration.HContext, ?dtypeVal:Value)</li>
<li> .decl TensorOpHasImpreciseArg(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?operationVal:Value)</li>
<li> .decl TensorOpImpreciseNameToVal(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?operationVal:Value, ?name:symbol)</li>
<li> .decl TensorOpOutputShape(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?operationVal:Value, ?shapeHctx:configuration.HContext, ?shapeVal:Value)</li>
<li> .decl TensorOpOutputWithHctx(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?opValHctx:configuration.HContext, ?operationVal:Value)</li>
<li> .decl TensorOperationError(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?operationVal:Value, ?errorMSG:symbol)</li>
<li> .decl TensorOperationProducesOutput(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?operationVal:Value)</li>
<li> .decl TensorOperationTensorArg(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?operationVal:Value, ?tensorArgHctx:configuration.HContext, ?tensorArg:Value)</li>
<li> .decl TensorOperationWarning(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?operationVal:Value, ?warningMSG:symbol)</li>
<li> .decl TensorOperation_GetDTypeFromName(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?operationVal:Value, ?name:symbol)</li>
<li> .decl TensorOperation_NameToVal(?ctx:configuration.Context, ?operationVal:Value, ?name:symbol, ?namedValHctx:configuration.HContext, ?namedVal:Value)</li>
<li> .decl TensorShape(?tensorHctx:configuration.HContext, ?tensor:Value, ?shapeHctx:configuration.HContext, ?shapeList:Value)</li>
<li> .decl TensorShapeListAtIndexHasMoreThanOneVal(?shapeValHctx:configuration.HContext, ?shapeVal:Value, ?index:number)</li>
<li> .decl TensorShapeListContent(?hctx:configuration.HContext, ?val:Value, ?index:number, ?indexValue:Value)</li>
<li> .decl TensorShapeListLength(?hctx:configuration.HContext, ?val:Value, ?size:number)</li>
<li> .decl isTensorLikeObject(?val:Value)</li>
<li> .decl isTensorVal(?val:Value)</li>
</ul>
<h2> python/lib-specific/tensorflow/keras.dl </h2>
<ul>
<li> .decl KerasImageToArrayOp(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?imgToArrOp:Value, ?imageHctx:configuration.HContext, ?image:Value)</li>
<li> .decl KerasLoadImageOp(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?loadImgVal:Value, ?shapeListHctx:configuration.HContext, ?shapeList:Value)</li>
<li> .decl PILImageShapeListContent(?hctx:configuration.HContext, ?val:Value, ?index:number, ?indexValue:Value)</li>
<li> .decl PILImageShapeListLength(?hctx:configuration.HContext, ?val:Value, ?size:number)</li>
</ul>
<h2> python/lib-specific/tensorflow/pooling-conv-ops.dl </h2>
<ul>
<li> .decl ConvOperation(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?newVal:Value)</li>
<li> .decl ConvOperationFunctionInfo(?function:Function, ?funName:symbol, ?nDims:number)</li>
<li> .decl ConvOperation_DillationRateForDim(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?newVal:Value, ?dim:number, ?dillationRateValForDim:Value)</li>
<li> .decl ConvOperation_DimResBeforeStrides(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?newVal:Value, ?dim:number, ?resBeforeStrides:number)</li>
<li> .decl ConvOrPoolOperation(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?newVal:Value)</li>
<li> .decl ConvOrPoolOperation_AllDimsCanBeComputed(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?newVal:Value)</li>
<li> .decl ConvOrPoolOperation_ChannelsFirst(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?newVal:Value)</li>
<li> .decl ConvOrPoolOperation_ChannelsLast(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?newVal:Value)</li>
<li> .decl ConvOrPoolOperation_ChannelsPosInTensor(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?newVal:Value, ?channelsPosInTensor:number)</li>
<li> .decl ConvOrPoolOperation_DimPosInTensor(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?newVal:Value, ?dim:number, ?dimPosInTensor:number)</li>
<li> .decl ConvOrPoolOperation_DimResult(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?newVal:Value, ?dim:number, ?dimRes:Value)</li>
<li> .decl ConvOrPoolOperation_GetNumbersForDim(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?newVal:Value, ?dim:number, ?tensorValForDimNum:number, ?kernelSizeValForDimNum:number, ?strideValForDimNum:number)</li>
<li> .decl ConvOrPoolOperation_KernelSizeForDim(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?newVal:Value, ?dim:number, ?kernelSizeValForDim:Value)</li>
<li> .decl ConvOrPoolOperation_NumOfDims(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?newVal:Value, ?ndims:number)</li>
<li> .decl ConvOrPoolOperation_NumOfOutputChannels(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?newVal:Value, ?outputChannelsVal:Value)</li>
<li> .decl ConvOrPoolOperation_PaddingSame(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?newVal:Value)</li>
<li> .decl ConvOrPoolOperation_PaddingValid(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?newVal:Value)</li>
<li> .decl ConvOrPoolOperation_StridesForDim(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?newVal:Value, ?dim:number, ?strideValForDim:Value)</li>
<li> .decl ConvOrPoolOperation_ValidDimension(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?newVal:Value, ?dim:number)</li>
<li> .decl LayersLibOperation(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?newVal:Value)</li>
<li> .decl NNLibOperation(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?newVal:Value)</li>
<li> .decl PoolOperation(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?newVal:Value)</li>
<li> .decl PoolOperationFunctionInfo(?function:Function, ?funName:symbol, ?nDims:number)</li>
<li> .decl PoolOperation_DimResBeforeStrides(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?newVal:Value, ?dim:number, ?resBeforeStrides:number)</li>
<li> .decl PossibleDimNumber(?dim: number)</li>
</ul>
<h2> python/lib-specific/tensorflow/shape-mod-ops.dl </h2>
<ul>
<li> .decl ExpandDimsInvalidAxisNum(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?expDimsVal:Value)</li>
<li> .decl ExpandDimsOp(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?expDimsVal:Value)</li>
<li> .decl ExpandDimsOpAxisNum(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?expDimsVal:Value, ?axis:number)</li>
<li> .decl ExpandDimsOpDim(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?expDimsVal:Value, ?dim:number)</li>
<li> .decl ExpandDimsOpInTensorShapeLength(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?expDimsVal:Value, ?length:number)</li>
<li> .decl ExpandDimsValidAxisNum(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?expDimsVal:Value)</li>
<li> .decl ReshapeOperation(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?reshapeOpVal:Value)</li>
<li> .decl ReshapeOperationBatchContamination(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?reshapeOpVal:Value)</li>
<li> .decl ReshapeOperationConcreteToConcrete(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?reshapeOpVal:Value)</li>
<li> .decl ReshapeOperationConcreteToMinus1(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?reshapeOpVal:Value)</li>
<li> .decl ReshapeOperationCorrectTypeArgs(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?reshapeOpVal:Value)</li>
<li> .decl ReshapeOperationDimListHasMinus1(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?reshapeOpVal:Value)</li>
<li> .decl ReshapeOperationDimListPosIntList(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?reshapeOpVal:Value)</li>
<li> .decl ReshapeOperationInTensorConcrete(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?reshapeOpVal:Value)</li>
<li> .decl ReshapeOperationInTensorHasNoneDim(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?reshapeOpVal:Value)</li>
<li> .decl ReshapeOperationInvalid(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?reshapeOpVal:Value)</li>
<li> .decl ReshapeOperationNoneToConcrete(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?reshapeOpVal:Value)</li>
<li> .decl ReshapeOperationNoneToMinus1(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?reshapeOpVal:Value)</li>
<li> .decl ReshapeOperationProductsOfShapes(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?reshapeOpVal:Value, ?tensorProd:number, ?dimListProd:number)</li>
<li> .decl ReshapeOperationReplaceMinus1WithVal(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?reshapeOpVal:Value, ?newVal:Value)</li>
<li> .decl SetShapeOp(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?setShapeOpVal:Value)</li>
<li> .decl SetShapeOpInvalidForDim(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?setShapeOpVal:Value, ?dim:number, ?setShapeValForDim:Value, ?tensorShapeValForDim:Value)</li>
<li> .decl SetShapeOpInvalidShapeLengths(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?setShapeOpVal:Value)</li>
<li> .decl SetShapeOpSameListLen(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?setShapeOpVal:Value)</li>
<li> .decl SetShapeOpShapeListLengths(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?setShapeOpVal:Value, ?tensorShapeListLength:number, ?inShapeListLength:number)</li>
<li> .decl SetShapeOpValidCorrectTypeArgs(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?setShapeOpVal:Value)</li>
<li> .decl SetShapeOpValidForDim(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?setShapeOpVal:Value, ?dim:number, ?valForDim:Value)</li>
<li> .decl SetShapeOpValidUpToDim(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?setShapeOpVal:Value, ?dim:number)</li>
<li> .decl TransposeOp(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?transposeOpVal:Value)</li>
<li> .decl TransposeOpOutputShapeListContent(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?transposeOpVal:Value, ?index:number, ?indexVal:Value)</li>
<li> .decl TransposeOpShapeListLengths(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?transposeOpVal:Value, ?tensorShapeListLength:number, ?permutationListLen:number)</li>
<li> .decl ValidTransposeOp(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?transposeOpVal:Value, ?len:number)</li>
</ul>
<h2> python/lib-specific/tensorflow/shape-pass-through-ops.dl </h2>
<ul>
<li> .decl ShapePassThroughFunction(?function:Function, ?name:symbol, ?declModule:Module, ?argName:symbol)</li>
<li> .decl ShapePassThroughOp(?ctx:configuration.Context, ?insn:Instruction, ?shapePassThroughOp:Value)</li>
</ul>
<h2> python/lib-specific/tensorflow/tensor-creation-ops.dl </h2>
<ul>
<li> .decl FeedDictArg(?hctx:configuration.HContext, ?val:Value)</li>
<li> .decl PlaceholderEvaluationOp(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?placeHolderEvalOp:Value)</li>
<li> .decl PlaceholderEvaluationOpEvalArg(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?placeHolderEvalOp:Value, ?argHctx:configuration.HContext, ?argVal:Value)</li>
<li> .decl PlaceholderEvaluationOpInPlaceholderOp(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?placeHolderEvalOp:Value, ?placeHolderHCtx:configuration.HContext, ?placeHolderOp:Value)</li>
<li> .decl PlaceholderEvaluationOpKnownPlaceholderShape(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?placeHolderEvalOp:Value)</li>
<li> .decl PlaceholderEvaluationOpKnownPlaceholderShapeDimForDim(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?placeHolderEvalOp:Value, ?dim:number, ?inTensorDimVal:Value, ?shapeListDimVal:Value)</li>
<li> .decl PlaceholderEvaluationOpKnownPlaceholderShapeInvalid(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?placeHolderEvalOp:Value)</li>
<li> .decl PlaceholderEvaluationOpKnownPlaceholderShapeInvalidForDim(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?placeHolderEvalOp:Value, ?dim:number)</li>
<li> .decl PlaceholderEvaluationOpKnownPlaceholderShapeLenForLen(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?placeHolderEvalOp:Value, ?len1:number, ?len2:number)</li>
<li> .decl PlaceholderEvaluationOpKnownPlaceholderShapeValid(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?placeHolderEvalOp:Value)</li>
<li> .decl PlaceholderEvaluationOpKnownPlaceholderShapeValidForDim(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?placeHolderEvalOp:Value, ?dim:number, ?dimVal:Value)</li>
<li> .decl PlaceholderEvaluationOpKnownPlaceholderShapeValidUpToDim(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?placeHolderEvalOp:Value, ?dim:number)</li>
<li> .decl PlaceholderEvaluationOpUnknownPlaceholderShape(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?placeHolderEvalOp:Value)</li>
<li> .decl PlaceholderOperation(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?placeHolderOp:Value)</li>
<li> .decl PlaceholderOperationKnownShape(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?placeHolderOp:Value)</li>
<li> .decl PlaceholderOperationOutDtype(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?placeHolderOp:Value, ?dtypeHctx: configuration.HContext, ?dtype:Value)</li>
<li> .decl PlaceholderOperationUnknownShape(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?placeHolderOp:Value)</li>
<li> .decl RandDistrCreationFunctionInfo(?function:Function, ?funName:symbol)</li>
<li> .decl SessRunFeedDictArg(?hctx:configuration.HContext, ?val:Value)</li>
<li> .decl StringToDtype(?string:Value, ?dtypeHctx:configuration.HContext, ?dtype:Value)</li>
<li> .decl TensorEvalFeedDictArg(?hctx:configuration.HContext, ?val:Value)</li>
<li> .decl TfConstantOp(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?constOp:Value)</li>
<li> .decl TfConstantOpOutDtype(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?constOp:Value, ?dtypeHctx:configuration.HContext, ?dtypeVal:Value)</li>
<li> .decl TfConstantOpOutShapeContent(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?constOp:Value, ?dimNum:number, ?dimVal:Value)</li>
<li> .decl TfConstantOpOutShapeLength(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?constOp:Value, ?len:number)</li>
<li> .decl TfConstantOpUnknownInDtype(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?constOp:Value)</li>
<li> .decl TfConstantOpUnknownInShape(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?constOp:Value)</li>
<li> .decl TfRandTensorOp(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?randOp:Value)</li>
<li> .decl TfVariableOp(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?constOp:Value)</li>
<li> .decl TfVariableOpOutDtype(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?constOp:Value, ?dtypeHctx:configuration.HContext, ?dtypeVal:Value)</li>
<li> .decl ZerosOrOnesLikeOp(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?zerosOrOnes:Value)</li>
<li> .decl ZerosOrOnesOp(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?zerosOrOnes:Value)</li>
</ul>
<h2> python/lib-specific/tensorflow/tensorflow-library.dl </h2>
<ul>
<li> .decl TensorObjectHasConcreteDimensions(?tensorHctx:configuration.HContext, ?tensorVal:Value)</li>
<li> .decl isTensorDataType(?type: TensorDataType)</li>
</ul>
<h2> python/lib-specific/tensorflow/uncategorized-ops.dl </h2>
<ul>
<li> .decl ArgMaxMinOp(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?argMaxMinOp:Value)</li>
<li> .decl ArgMaxMinOpAxisDimIsOneWarning(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?argMaxMinOp:Value)</li>
<li> .decl ArgMaxMinOpAxisNum(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?argMaxMinOp:Value, ?axisNum:number)</li>
<li> .decl EmbdedingLookupOp(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?embLookOp:Value)</li>
<li> .decl EmbdedingLookupOpTensorLengths(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?embLookOp:Value, ?len1:number, ?len2:number)</li>
<li> .decl ReduceOp(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?redOp:Value)</li>
<li> .decl SoftmaxCrEntrWLogitsOp(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?scewlOp:Value)</li>
<li> .decl SoftmaxCrEntrWLogitsOpAxisNums(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?scewlOp:Value, ?value1:Value, ?value2:Value)</li>
<li> .decl SoftmaxCrEntrWLogitsOpInvalidAxes(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?scewlOp:Value)</li>
<li> .decl SoftmaxCrEntrWLogitsOpLabelsMultRes(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?scewlOp:Value, ?res: number)</li>
<li> .decl SoftmaxCrEntrWLogitsOpLogitsMultRes(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?scewlOp:Value, ?res: number)</li>
<li> .decl SoftmaxCrEntrWLogitsOpSameRes(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?scewlOp:Value, ?res:number)</li>
<li> .decl SoftmaxCrEntrWLogitsOpValidAxes(?ctx:configuration.Context, ?insn:FunctionInvocation_Insn, ?scewlOp:Value)</li>
</ul>
<h2> python/main/comprehension.dl </h2>
<ul>
<li> .decl IterableObjectLength(?hctx:configuration.HContext, ?val:Value, ?lenVal:Value)</li>
<li> .decl ListCompCall(?callerCtx:configuration.Context, ?invo:FunctionInvocation_Insn, ?fun:Function)</li>
<li> .decl ListCompCallIterArg(?callerCtx:configuration.Context, ?invo:FunctionInvocation_Insn, ?fun:Function, ?hctx:configuration.HContext, ?val:Value)</li>
<li> .decl ListCompCallReturnVal(?callerCtx:configuration.Context, ?invo:FunctionInvocation_Insn, ?fun:Function, ?hctx:configuration.HContext, ?val:Value)</li>
<li> .decl ListCompProducesOutput(?callerCtx:configuration.Context, ?invo:FunctionInvocation_Insn, ?fun:Function, ?outVal:Value)</li>
<li> .decl ListCompProducesOutputWithHctx(?callerCtx:configuration.Context, ?invo:FunctionInvocation_Insn, ?fun:Function, ?hctx:configuration.HContext, ?outVal:Value)</li>
</ul>
<h2> python/main/configuration.dl </h2>
<ul>
<li> .decl ContextRequest(?ctx:configuration.Context, ?hctx:configuration.HContext, ?invo:FunctionInvocation_Insn,?value:Value, ?function:Function)</li>
<li> .decl ContextResponse(?callerCtx:configuration.Context, ?hctx:configuration.HContext, ?invo:FunctionInvocation_Insn,?value:Value, ?calleeCtx:Context)</li>
<li> .decl InitContextRequest(?symbol:symbol)</li>
<li> .decl InitContextResponse(?symbol:symbol, ?context:Context)</li>
<li> .decl InitHContextRequest(?symbol:symbol)</li>
<li> .decl InitHContextResponse(?symbol:symbol, ?hcontext:HContext)</li>
<li> .decl RecordContextRequest(?callerCtx:configuration.Context, ?value:Value, ?var:Var)</li>
<li> .decl RecordContextResponse(?callerCtx:configuration.Context, ?value:Value, ?var:Var, ?hctx:configuration.HContext)</li>
</ul>
<h2> python/main/const-int.dl </h2>
<ul>
<li> .decl BinaryIntOp(?ctx: configuration.Context, ?instr:Instruction, ?constVal1:Value, ?constVal2:Value, ?res:number)</li>
<li> .decl BinaryIntOpOperandDists(?ctx: configuration.Context, ?instr:Instruction, ?constVal1:Value, ?constVal2:Value, ?dist1:number, ?dist2:number)</li>
<li> .decl IntConstant_Distance(?const:IntConstant, ?distance:number)</li>
<li> .decl ValidBinaryIntOp(?ctx: configuration.Context, ?instr:Instruction, ?res:number, ?newDist:number)</li>
<li> .decl VarHasConstFloatValue(?value:Value, ?var:Var)</li>
<li> .decl VarHasConstIntValue(?value:Value, ?var:Var)</li>
<li> .decl VarHasConstNoneValue(?value:Value, ?var:Var)</li>
<li> .decl VarHasConstValue(?value:Value, ?var:Var)</li>
<li> .decl VarPointsToConstFloatValue(?hctx:configuration.HContext, ?value:Value, ?ctx:configuration.Context, ?var:Var)</li>
<li> .decl VarPointsToConstIntValue(?hctx:configuration.HContext, ?value:Value, ?ctx:configuration.Context, ?var:Var)</li>
<li> .decl VarPointsToConstNoneValue(?hctx:configuration.HContext, ?value:Value, ?ctx:configuration.Context, ?var:Var)</li>
<li> .decl VarPointsToConstValue(?hctx:configuration.HContext, ?value:Value, ?ctx:configuration.Context, ?var:Var)</li>
</ul>
<h2> python/main/dictionaries.dl </h2>
<ul>
<li> .decl DictKeyForVal(?dictHctx:configuration.HContext, ?dict:Value, ?key:Value, ?valHctx:configuration.HContext, ?val:Value)</li>
</ul>
<h2> python/main/function-resolution-declarations.dl </h2>
<ul>
<li> .decl FunctionInvResolvesTo(?ctx: configuration.Context, ?insn:FunctionInvocation_Insn, ?val:Value, ?hctx:configuration.HContext, ?fun:Function)</li>
<li> .decl FunctionInvResolvesToNonSpecialFunction(?ctx: configuration.Context, ?insn:FunctionInvocation_Insn, ?val:Value, ?hctx:configuration.HContext, ?fun:Function)</li>
<li> .decl FunctionInvResolvesToSpecialFunction(?ctx: configuration.Context, ?insn:FunctionInvocation_Insn, ?val:Value, ?hctx:configuration.HContext, ?fun:Function)</li>
<li> .decl ResolvedActualParamValue(?callerCtx: configuration.Context, ?invo:Instruction, ?resolvedFunction:Function, ?paramName:symbol, ?hctx:configuration.HContext, ?paramValue:Value)</li>
<li> .decl ResolvedFunctionActualParam(?ctx: configuration.Context, ?insn:FunctionInvocation_Insn, ?tofunction:Function, ?formalParamVar:Var, ?actualParamVar:Var)</li>
<li> .decl ResolvedFunctionHasActualKeywordParamForIndex(?ctx: configuration.Context, ?insn:FunctionInvocation_Insn, ?tofunction:Function, ?formalParamIndex:number, ?actualParamVar:Var)</li>
<li> .decl ResolvedFunctionHasActualParamForIndex(?ctx: configuration.Context, ?insn:FunctionInvocation_Insn, ?tofunction:Function, ?formalParamIndex:number)</li>
<li> .decl ResolvedFunctionHasActualParamUptoIndex(?ctx: configuration.Context, ?insn:FunctionInvocation_Insn, ?tofunction:Function, ?formalParamIndex:number)</li>
<li> .decl ResolvedFunctionHasActualPositionalParamForIndex(?ctx: configuration.Context, ?insn:FunctionInvocation_Insn, ?tofunction:Function, ?formalParamIndex:number, ?actualParamVar:Var)</li>
<li> .decl ResolvedFunctionHasAllRequiredParams(?ctx: configuration.Context, ?insn:FunctionInvocation_Insn, ?tofunction:Function)</li>
<li> .decl ResolvedFunctionHasInvalidNumberOfActualParams(?ctx: configuration.Context, ?insn:FunctionInvocation_Insn, ?tofunction:Function)</li>
<li> .decl ResolvedFunctionHasKeywordAndPositionalActualParamForIndex(?ctx: configuration.Context, ?insn:FunctionInvocation_Insn, ?tofunction:Function, ?formalParamIndex:number)</li>
<li> .decl ResolvedFunctionHasValidNumberOfActualParams(?ctx: configuration.Context, ?insn:FunctionInvocation_Insn, ?tofunction:Function)</li>
<li> .decl ResolvedFunctionMissingActualOrDefaultParamForIndex(?ctx: configuration.Context, ?insn:FunctionInvocation_Insn, ?tofunction:Function, ?formalParamIndex:number)</li>
<li> .decl ResolvedFunctionMissingActualParamForIndex(?ctx: configuration.Context, ?insn:FunctionInvocation_Insn, ?tofunction:Function, ?formalParamIndex:number)</li>
<li> .decl ResolvedFunctionNoActualKeywordParamForIndex(?ctx: configuration.Context, ?insn:FunctionInvocation_Insn, ?tofunction:Function, ?formalParamIndex:number)</li>
<li> .decl ResolvedFunctionNoActualPositionalParamForIndex(?ctx: configuration.Context, ?insn:FunctionInvocation_Insn, ?tofunction:Function, ?formalParamIndex:number)</li>
</ul>
<h2> python/main/imports.dl </h2>
<ul>
<li> .decl ClassType_Module(?class:ClassType, ?module: Module)</li>
<li> .decl ModuleCanImportModule(?importingModule:Module, ?importName:symbol, ?importedModule:Module)</li>
<li> .decl PackageCanImportPackage(?package:Package, ?importName:symbol, ?importedPackage:Package)</li>
<li> .decl VarPointsToFunction(?hctx:configuration.HContext, ?val: Value, ?ctx:configuration.Context, ?var:Var)</li>
<li> .decl VarPointsToModule(?hctx:configuration.HContext, ?val: Value, ?ctx:configuration.Context, ?var:Var)</li>
</ul>
<h2> python/main/lists.dl </h2>
<ul>
<li> .decl ConstListMultAll(?hctx:configuration.HContext, ?heap:HeapAllocation, ?res:number)</li>
<li> .decl ConstListMultAllInner(?hctx:configuration.HContext, ?heap:HeapAllocation, ?index:number, ?res:number)</li>
<li> .decl ListAtIndexPointsTo(?listHctx:configuration.HContext, ?listHeap:HeapAllocation, ?index:number, ?valHctx:configuration.HContext, ?value:Value)</li>
<li> .decl ListInitialLength(?listHeap:HeapAllocation, ?length:number)</li>
<li> .decl ListOfConsts(?listHctx:configuration.HContext, ?heapList:HeapAllocation)</li>
<li> .decl ListOfConstsAtIndexPointsTo(?listHctx:configuration.HContext, ?listHeap:HeapAllocation, ?index:number, ?value:Value)</li>
<li> .decl ListOfConstsInner(?listHctx:configuration.HContext, ?heapList:HeapAllocation, ?index:number)</li>
<li> .decl ListOfConstsLength(?hctx:configuration.HContext, ?heap:HeapAllocation, ?len:number)</li>
<li> .decl ListOfIntConsts(?listHctx:configuration.HContext, ?heapList:HeapAllocation)</li>
<li> .decl ListOfIntConstsAtIndexPointsTo(?listHctx:configuration.HContext, ?listHeap:HeapAllocation, ?index:number, ?value:Value)</li>
<li> .decl ListOfIntConstsInner(?listHctx:configuration.HContext ,?heapList:HeapAllocation, ?index:number)</li>
<li> .decl ListOfPosIntConsts(?listHctx:configuration.HContext, ?heapList:HeapAllocation)</li>
<li> .decl ListOfPosIntConstsAtIndexPointsTo(?listHctx:configuration.HContext, ?listHeap:HeapAllocation, ?index:number, ?value:Value)</li>
<li> .decl ListOfPosIntConstsInner(?listHctx:configuration.HContext ,?heapList:HeapAllocation, ?index:number)</li>
<li> .decl PyListDeducedDtype(?listHctx:configuration.HContext, ?listHeap:HeapAllocation, ?dtype:symbol)</li>
<li> .decl PyListDeducedShapeContents(?listHctx:configuration.HContext, ?listHeap:HeapAllocation, ?index:number, ?indexVal:Value)</li>
<li> .decl PyListDeducedShapeLength(?listHctx:configuration.HContext, ?listHeap:HeapAllocation, ?size:number)</li>
<li> .decl PyListOfNumConstsGetFirst(?listHctx:configuration.HContext, ?listHeap:HeapAllocation, ?numConst:symbol)</li>
<li> .decl VarPointsToList(?hctx:configuration.HContext, ?listHeap:HeapAllocation, ?ctx:configuration.Context, ?var:Var)</li>
</ul>
<h2> python/main/main-declarations.dl </h2>
<ul>
<li> .decl ArrayIndexPointsTo(?hctx:configuration.HContext, ?value:Value, ?basehctx:configuration.HContext, ?basevalue:Value)</li>
<li> .decl BinopNewIntConstantValue(?value:Value, ?numStr:IntConstant, ?dist:number)</li>
<li> .decl BoundMethodAllocationSelfArgument(?boundMethHctx:configuration.HContext, ?boundMethodVal:Value, ?selfHctx:configuration.HContext, ?selfVal:Value)</li>
<li> .decl CallGraphEdge(?callerCtx:configuration.Context, ?invocation:FunctionInvocation_Insn, ?calleeCtx:configuration.Context, ?function:Function)</li>
<li> .decl ClassInstanceAllocationInitializingClassObject(?instanceHctx:configuration.HContext, ?classInstance:HeapAllocation, ?classObjectHctx:configuration.HContext, ?classObject:HeapAllocation)</li>
<li> .decl DiagnosticForLSP(?file:File, ?severity:symbol, ?startLine:number, ?startCol:number, ?endLine:number, ?endCol:number, ?message:symbol)</li>
<li> .decl DictInitialAssignVar(?heap:HeapAllocation, ?var:Var, ?ctx:configuration.Context)</li>
<li> .decl GlobalNamePointsTo(?hctx:configuration.HContext, ?value:Value, ?scope:Scope, ?name:symbol)</li>
<li> .decl HoverInfoForLSP(?file:File, ?ctx:configuration.Context, ?index:number, ?startLine:number, ?startCol:number, ?endLine:number, ?endCol:number, ?messagePart:symbol, ?valuePart:symbol)</li>
<li> .decl InstanceFieldPointsTo(?hctx:configuration.HContext, ?value:Value, ?sig:Field, ?basehctx:configuration.HContext, ?basevalue:Value)</li>
<li> .decl IntConstantValue_ActualNum(?value:Value, ?num:number)</li>
<li> .decl IsPyListOrTuple(?heap:HeapAllocation)</li>
<li> .decl ListInitialAssignVar(?heap:HeapAllocation, ?var:Var, ?ctx:configuration.Context)</li>
<li> .decl NonBinopNewIntConstantValue(?value:Value, ?numStr:IntConstant)</li>
<li> .decl Reachable(?function:Function)</li>
<li> .decl ReachableContext(?ctx:configuration.Context, ?function:Function)</li>
<li> .decl Value_Num(?value:Value, ?const:symbol)</li>
<li> .decl Value_String(?value:Value, ?str:StringConstant)</li>
<li> .decl Value_Type(?value:Value, ?type:Type)</li>
<li> .decl VarPointsTo(?hctx:configuration.HContext, ?value:Value, ?ctx:configuration.Context, ?var:Var)</li>
<li> .decl isBoundMethodObjectAllocation(?h: FunctionObjectAllocation)</li>
<li> .decl isClassInstanceAllocation(?h: ClassInstanceAllocation)</li>
<li> .decl isClassObjectAllocation(?h: ClassObjectAllocation)</li>
<li> .decl isConstantValue(?value:Value)</li>
<li> .decl isContext(?ctx:configuration.Context)</li>
<li> .decl isFloatConstantValue(?value:Value)</li>
<li> .decl isFunctionObjectAllocation(?h: FunctionObjectAllocation)</li>
<li> .decl isHContext(?hctx:configuration.HContext)</li>
<li> .decl isHeapValue(?value:Value)</li>
<li> .decl isImmutableContext(?ctx:configuration.Context)</li>
<li> .decl isImmutableHContext(?ctx:configuration.HContext)</li>
<li> .decl isInitialContext(?ctx:configuration.Context)</li>
<li> .decl isIntConstantValue(?value:Value)</li>
<li> .decl isModeledHeapValue(?value:Value)</li>
<li> .decl isNonFunctionObjectValue(?val:Value)</li>
<li> .decl isNonHeapValue(?value:Value)</li>
<li> .decl isNoneValue(?none:Value)</li>
<li> .decl isPyDict(?heap:HeapAllocation)</li>
<li> .decl isUnboundMethodObjectAllocation(?h: FunctionObjectAllocation)</li>
<li> .decl isUnboundMethodOrFunctionObjectAllocation(?h: FunctionObjectAllocation)</li>
<li> .decl isValue(?value:Value)</li>
</ul>
<p>Timestamp: 2021-06-11 15:17:12.708975</p></body></html>