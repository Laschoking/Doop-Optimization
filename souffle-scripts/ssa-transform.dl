#import "../souffle-logic/facts/import-facts.dl"
#import "../souffle-logic/facts/flow-sensitive-schema.dl"
#import "../souffle-logic/facts/flow-insensitive-schema.dl"
#import "../souffle-logic/addons/cfg-analysis/declarations.dl"
#import "../souffle-logic/addons/cfg-analysis/analysis.dl"

// If instr is an assignment found at instruction i in method meth
// then create a new assignment fact with same RHS and LHS v_i,
// where v is the name of the original variable.

.decl SSA_Alias(?ssa_name:symbol, ?original:symbol)
.output SSA_Alias

// Helper relation to factor out some code.
.decl SSA_AssignDetails(?instr:symbol, ?to:symbol, ?index:number, ?ssa_name:symbol, ?method:symbol)

.decl SSA_AssignToOriginal(?instr:symbol, ?original:symbol)

SSA_AssignToOriginal(?instr, ?to),
SSA_Alias(cat(?to, cat("_", to_string(?index))), ?to),
SSA_AssignDetails(?instr, ?to, ?index, cat(?to, cat("_", to_string(?index))), ?method) :-
    Instruction_Index(?instr, ?index),
    AssignInstruction_To(?instr, ?to),
    Instruction_Method(?instr, ?method).

.decl SSA_AssignHeapAllocation(?instr:symbol, ?index:number, ?ssa_name:symbol, ?method:symbol)
.output SSA_AssignHeapAllocation

SSA_AssignHeapAllocation(?instr, ?index, ?ssa_name, ?method) :-
    isAssignHeapAllocation_Insn(?instr),
    SSA_AssignDetails(?instr, ?to, ?index, ?ssa_name, ?method).

.decl SSA_AssignLocal(?instr:symbol, ?index:number, ?ssa_name:symbol, ?method:symbol)
.output SSA_AssignLocal

SSA_AssignLocal(?instr, ?index, ?ssa_name, ?method) :-
    isAssignLocal_Insn(?instr),
    SSA_AssignDetails(?instr, ?to, ?index, ?ssa_name, ?method).

.decl SSA_AssignBinop(?instr:symbol, ?index:number, ?ssa_name:symbol, ?method:symbol)
.output SSA_AssignBinop

SSA_AssignBinop(?instr, ?index, ?ssa_name, ?method) :-
    isAssignBinop_Insn(?instr),
    SSA_AssignDetails(?instr, ?to, ?index, ?ssa_name, ?method).

.decl SSA_AssignUnop(?instr:symbol, ?index:number, ?ssa_name:symbol, ?method:symbol)
.output SSA_AssignUnop

SSA_AssignUnop(?instr, ?index, ?ssa_name, ?method) :-
    isAssignUnop_Insn(?instr),
    SSA_AssignDetails(?instr, ?to, ?index, ?ssa_name, ?method).

// TODO: Is this needed?
//.decl SSA_AssignOperFrom(?instr:symbol, ?index:number, ?ssa_name:symbol, ?method:symbol)
//.output SSA_AssignOperFrom
//
//SSA_Alias(?method, ?to, ?ssa_name),
//SSA_AssignOperFrom(?instr, ?index, ?ssa_name, ?method) :-
//    isAssignOperFrom_Insn(?instr),
//    Instruction_Index(?instr, ?index),
//    AssignInstruction_To(?instr, ?to),
//    Instruction_Method(?instr, ?method),
//    ?ssa_name = cat(?to, cat("_", to_string(?index))).

.decl SSA_AssignCast(?instr:symbol, ?index:number, ?ssa_name:symbol, ?method:symbol)
.output SSA_AssignCast

SSA_AssignCast(?instr, ?index, ?ssa_name, ?method) :-
    isAssignCast_Insn(?instr),
    SSA_AssignDetails(?instr, ?to, ?index, ?ssa_name, ?method).

.decl SSA_AssignCastNumConstant(?instr:symbol, ?index:number, ?ssa_name:symbol, ?method:symbol)
.output SSA_AssignCastNumConstant

SSA_AssignCastNumConstant(?instr, ?index, ?ssa_name, ?method) :-
    isAssignCastNumConstant_Insn(?instr),
    SSA_AssignDetails(?instr, ?to, ?index, ?ssa_name, ?method).

.decl SSA_AssignCastNull(?instr:symbol, ?index:number, ?ssa_name:symbol, ?method:symbol)
.output SSA_AssignCastNull

SSA_AssignCastNull(?instr, ?index, ?ssa_name, ?method) :-
    isAssignCastNull_Insn(?instr),
    SSA_AssignDetails(?instr, ?to, ?index, ?ssa_name, ?method).

.decl SSA_AssignNumConstant(?instr:symbol, ?index:number, ?ssa_name:symbol, ?method:symbol)
.output SSA_AssignNumConstant

SSA_AssignNumConstant(?instr, ?index, ?ssa_name, ?method) :-
    isAssignNumConstant_Insn(?instr),
    SSA_AssignDetails(?instr, ?to, ?index, ?ssa_name, ?method).

.decl SSA_AssignInstanceOf(?instr:symbol, ?index:number, ?ssa_name:symbol, ?method:symbol)
.output SSA_AssignInstanceOf

SSA_AssignInstanceOf(?instr, ?index, ?ssa_name, ?method) :-
    isAssignInstanceOf_Insn(?instr),
    SSA_AssignDetails(?instr, ?to, ?index, ?ssa_name, ?method).

// TODO: Is this needed?
//.decl SSA_AssignPhantomInvoke(?instr:symbol, ?index:number, ?ssa_name:symbol, ?method:symbol)
//.output SSA_AssignPhantomInvoke
//
//SSA_Alias(?method, ?to, ?ssa_name),
//SSA_AssignPhantomInvoke(?instr, ?index, ?ssa_name, ?method) :-
//    isAssignPhantomInvoke(?instr),
//    Instruction_Index(?instr, ?index),
//    AssignInstruction_To(?instr, ?to),
//    Instruction_Method(?instr, ?method),
//    ?ssa_name = cat(?to, cat("_", to_string(?index))).

.decl StrictlyDominates(?dominator:symbol, ?block:symbol)
.output StrictlyDominates

StrictlyDominates(?dominator, ?block) :-
    Dominates(?dominator, ?block),
    !?dominator = ?block.

.decl DominanceFrontier(?dBlock:symbol, ?block:symbol)
.output DominanceFrontier

DominanceFrontier(?dBlock, ?block) :-
    MayPredecessorBBModuloThrow(?pred, ?block),
    Dominates(?dBlock, ?pred),
    !StrictlyDominates(?dBlock, ?block).

.decl DFPlus(?dBlock:symbol, ?block:symbol, ?var:symbol)
.output DFPlus

DFPlus(?dBlock, ?block, ?var) :-
    ContainsAssignment(?dBlock, ?var),
    DominanceFrontier(?dBlock, ?block).

DFPlus(?dBlock, ?block, ?var) :-
    ContainsAssignment(?dBlock, ?var),
    DFPlus(?dBlock, ?block, ?var).

.decl ContainsAssignment(?dBlock:symbol, ?var:symbol)

ContainsAssignment(?dBlock, ?var) :-
    BasicBlockHead(?insn, ?dBlock),
    SSA_AssignDetails(?insn, ?var, _, _, _).

.decl DebugBB(?bb:symbol)
.output BasicBlockBegin

DebugBB(?bb) :- BasicBlockBegin(?bb).

// Phi Instrutions inserted at basic blocks.
// ?phi_var is the new phi variable name that will be generated,
// ?block is the basic block (represented by it's first instr) where
// the Phi Instruction will be inserted.
.decl PhiAssign(?phi_var:symbol, ?arity:number, ?block:symbol)
.output PhiAssign

SSA_Alias(?phi_var, ?var),
PhiAssign(?phi_var, ?arity, ?block) :-
    DFPlus(_, ?block, ?var),
    Instruction_Index(?block, ?index),
    ?arity = count : MayPredecessorBBModuloThrow(_, ?block),
    ?phi_var = cat(cat(?var, "_phi_"), to_string(?index)).
    
.decl BBFollowsSimilarDef(?block:symbol, ?instr:symbol, ?def:symbol)
.output BBFollowsSimilarDef

BBFollowsSimilarDef(?block, ?instr, ?original) :-
    BasicBlockHead(?instr, ?block),
    BasicBlockHead(?follow, ?block),
    PhiAssign(?phi_var, _, ?instr),
    SSA_Alias(?phi_var, ?original),
    SSA_AssignToOriginal(?follow, ?original),
    Instruction_Index(?instr, ?i),
    Instruction_Index(?follow, ?j),
    ?i < ?j.

BBFollowsSimilarDef(?block, ?instr, ?original) :-
    BasicBlockHead(?instr, ?block),
    BasicBlockHead(?follow, ?block),
    SSA_AssignToOriginal(?instr, ?original),
    SSA_AssignToOriginal(?follow, ?original),
    Instruction_Index(?instr, ?i),
    Instruction_Index(?follow, ?j),
    ?i < ?j.

.decl BBLocalOutDefs(?block:symbol, ?def:symbol)
.output BBLocalOutDefs

BBLocalOutDefs(?block, ?def) :-
    BasicBlockBegin(?block),
    PhiAssign(?def, _, ?block),
    SSA_Alias(?def, ?original),
    !SSA_AssignToOriginal(?block, ?original),
    !BBFollowsSimilarDef(?block, ?block, ?original).

BBLocalOutDefs(?block, ?def) :-
    BasicBlockBegin(?block),
    BasicBlockHead(?assgn, ?block),
    SSA_AssignToOriginal(?assgn, ?original),
    SSA_AssignDetails(?assgn, ?original, _, ?def, _),
    !BBFollowsSimilarDef(?block, ?assgn, ?original).

.decl ExistsLocalDef(?block:symbol, ?def:symbol)
ExistsLocalDef(?block, ?original) :-
    BBLocalOutDefs(?block, ?def),
    SSA_Alias(?def, ?original).

.decl BBOutDefs(?block:symbol, ?def:symbol)
.output BBOutDefs

BBOutDefs(?block, ?def) :-
    BBLocalOutDefs(?block, ?def).

BBOutDefs(?block, ?prev_def) :-
    MayPredecessorBBModuloThrow(?pred, ?block),
    BBOutDefs(?pred, ?prev_def),
    SSA_Alias(?prev_def, ?original),
    !ExistsLocalDef(?block, ?original).

// Two defs are similar, if they are both renames of the same
// variable in the original program.
.decl SimilarDefs(?def_1:symbol, ?def_2:symbol)

SimilarDefs(?def_1, ?def_2) :-
    SSA_Alias(?def_1, ?original),
    SSA_Alias(?def_2, ?original).

// A phi assignment is non trivial, if there exist two different predecessors
// basic blocks that have different defs for var in their out-def sets.
.decl isNonTrivialPhi(?block:symbol, ?var:symbol)

isNonTrivialPhi(?block, ?var) :-
    PhiAssign(?var, _, ?block),
    ExistTwoDifferentPredDefs(?block, ?var).

// Helper predicate that achieves the core logic for the non trivial phi predicate.
.decl ExistTwoDifferentPredDefs(?block:symbol, ?phi_name:symbol)

ExistTwoDifferentPredDefs(?block, ?phi_name) :-
    MayPredecessorBBModuloThrow(?pred1, ?block),
    MayPredecessorBBModuloThrow(?pred2, ?block),
    ?pred1 != ?pred2,
    SSA_Alias(?phi_name, ?original),
    BBOutDefs(?pred_1, ?def_1),
    BBOutDefs(?pred_2, ?def_2),
    SimilarDefs(?def_1, ?def_2),
    SimilarDefs(?phi_name, ?def_1),
    ?def_1 != ?def_2.

.decl SimilarOutDefs(?block:symbol, ?def:symbol, ?out_def:symbol)

SimilarOutDefs(?block, ?def, ?out_def) :-
    BBOutDefs(?block, ?out_def),
    SimilarDefs(?def, ?out_def).

// These instructions create chains of assignments, at the head of each block.
// This is a helper relation to assist the final assignment operation, which 
// will require linking the assignments with the rest of the code.
.decl PhiPseudoAssign(?phi_var:symbol, ?def:symbol, ?src_block:symbol, ?dst_block:symbol, ?pseudoname:symbol)
.output PhiPseudoAssign

// Many assigns on the same phi var, consist of a PhiChunk. These are unique, since 
// phi_var is unique (SSA naming).
.decl PhiChunk(?phi_var:symbol)
.output PhiChunk

PhiChunk(?phi_var),
PhiPseudoAssign(?phi_var, ?phi_arg, ?src_block, ?dst_block, ?pseudoname) :-
    PhiAssign(?phi_var, _, ?dst_block),
    isNonTrivialPhi(?dst_block, ?phi_var),
    MayPredecessorBBModuloThrow(?src_block, ?dst_block),
    SimilarOutDefs(?src_block, ?phi_var, ?phi_arg),
    Instruction_Index(?src_block, ?src_idx),
    Instruction_Index(?dst_block, ?dst_idx),
    ?pseudoname = cat(?phi_var, cat("_", to_string(?src_idx))).

// TODO: Are the initial checks needed?
.decl ExistsPseudoAssignBetween(?prev:symbol, ?next:symbol)
ExistsPseudoAssignBetween(?prev, ?next) :-
    PhiPseudoAssign(?phi, _, _, ?block, ?prev),
    PhiPseudoAssign(?phi, _, _, ?block, ?next),
    PhiPseudoAssign(?phi, _, _, ?block, ?mid),
    ord(?prev) < ord(?next),
    ord(?prev) < ord(?mid),
    ord(?mid)  < ord(?next).

.decl SSANext(?prev:symbol, ?next:symbol)
.output SSANext

.decl PhiChunkNext(?prev:symbol, ?next:symbol)
.output PhiChunkNext

// Link PhiChunk assignments
SSANext(?prev, ?next),
PhiChunkNext(?prev, ?next) :-
    PhiPseudoAssign(?phi, _, _, ?block, ?prev),
    PhiPseudoAssign(?phi, _, _, ?block, ?next),
    ord(?prev) < ord(?next),
    !ExistsPseudoAssignBetween(?prev, ?next).

.decl PhiChunkStart(?phi_chunk:symbol, ?start:symbol)
.output PhiChunkStart

PhiChunkStart(?phi_chunk, ?start) :-
    PhiPseudoAssign(?phi_chunk, _, _, _, ?start),
    !PhiChunkNext(_, ?start).

.decl PhiChunkEnd(?phi_chunk:symbol, ?end:symbol)
.output PhiChunkEnd

PhiChunkEnd(?phi_chunk, ?end) :-
    PhiPseudoAssign(?phi_chunk, _, _, _, ?end),
    !PhiChunkNext(?end, _).
    
//PhiAssignInstruction(?phi_var, ?block, $) :-
//    PhiAssign(?phi_var, _, ?block),
//    ExistTwoDifferentPredDefs(?block, ?phi_var).

//.decl InstrReachingDef(?instr:symbol, ?original:symbol, ?def:symbol)
//
//InstrReachingDef(?instr, ?def, ?original) :-
//    MayPredecessorModuloThrow(?prev, ?instr),
//    !SSA_AssignDetails(?prev, _, _, _, _),
//    InstrReachingDef(?prev, ?def, ?original).
//
//InstrReachingDef(?instr, ?def, ?original) :-
//    MayPredecessorModuloThrow(?prev, ?instr),
//    !SSA_AssignDetails(?prev, _, _, _, _),
//    InstrReachingDef(?prev, ?def, ?original).
