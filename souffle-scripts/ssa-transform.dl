#define ANDROID

#import "../souffle-logic/facts/import-facts.dl"
#import "../souffle-logic/facts/import-entities.dl"
#import "../souffle-logic/facts/flow-sensitive-schema.dl"
#import "../souffle-logic/facts/flow-insensitive-schema.dl"
#import "../souffle-logic/addons/cfg-analysis/declarations.dl"
#import "../souffle-logic/addons/cfg-analysis/analysis.dl"

// If instr is an assignment found at instruction i in method meth
// then create a new assignment fact with same RHS and LHS v_i,
// where v is the name of the original variable.

// Holds all ssa renames in the program for a given origin variable.
// e.g. (v0_0, v0), (v0_1, v0) ... 
.decl SSA_Alias(?ssa_name:symbol, ?original:symbol)
.output SSA_Alias

// Helper relation to factor out some code.
.decl SSA_AssignDetails(?instr:symbol, ?to:symbol, ?index:number, ?ssa_name:symbol, ?method:symbol)

// Aux relations
.decl SSA_AssignToOriginal(?instr:symbol, ?original:symbol)

.decl SSA_FormalParam(?index:number, ?method:symbol, ?ssa_name:symbol)
.decl SSA_ThisVar(?method:symbol, ?ssa_name:symbol)

SSA_AssignToOriginal(?instr, ?to),
SSA_Alias(cat(?to, cat("_", to_string(?index))), ?to),
SSA_AssignDetails(?instr, ?to, ?index, cat(?to, cat("_", to_string(?index))), ?method) :-
    Instruction_Index(?instr, ?index),
    AssignInstruction_To(?instr, ?to),
    Instruction_Method(?instr, ?method).

SSA_Alias(cat(?original, cat("_", "0")), ?original),
SSA_FormalParam(?index, ?method, cat(?original, cat("_", "0"))) :-
    FormalParam(?index, ?method, ?original).

SSA_Alias(cat(?original, cat("_", "0")), ?original),
SSA_ThisVar(?method, cat(?original, cat("_", "0"))) :-
    ThisVar(?method, ?original).
    
.decl SSA_AssignHeapAllocation(?instr:symbol, ?index:number, ?ssa_name:symbol, ?method:symbol)
.output SSA_AssignHeapAllocation

SSA_AssignHeapAllocation(?instr, ?index, ?ssa_name, ?method) :-
    isAssignHeapAllocation_Insn(?instr),
    SSA_AssignDetails(?instr, ?to, ?index, ?ssa_name, ?method).

.decl SSA_AssignLocal(?instr:symbol, ?index:number, ?ssa_name:symbol, ?method:symbol)
.output SSA_AssignLocal

SSA_AssignLocal(?instr, ?index, ?ssa_name, ?method) :-
    isAssignLocal_Insn(?instr),
    SSA_AssignDetails(?instr, ?to, ?index, ?ssa_name, ?method).

.decl SSA_AssignBinop(?instr:symbol, ?index:number, ?ssa_name:symbol, ?method:symbol)
.output SSA_AssignBinop

SSA_AssignBinop(?instr, ?index, ?ssa_name, ?method) :-
    isAssignBinop_Insn(?instr),
    SSA_AssignDetails(?instr, ?to, ?index, ?ssa_name, ?method).

.decl SSA_AssignUnop(?instr:symbol, ?index:number, ?ssa_name:symbol, ?method:symbol)
.output SSA_AssignUnop

SSA_AssignUnop(?instr, ?index, ?ssa_name, ?method) :-
    isAssignUnop_Insn(?instr),
    SSA_AssignDetails(?instr, ?to, ?index, ?ssa_name, ?method).

// TODO: Is this needed?
//.decl SSA_AssignOperFrom(?instr:symbol, ?index:number, ?ssa_name:symbol, ?method:symbol)
//.output SSA_AssignOperFrom
//
//SSA_Alias(?method, ?to, ?ssa_name),
//SSA_AssignOperFrom(?instr, ?index, ?ssa_name, ?method) :-
//    isAssignOperFrom_Insn(?instr),
//    Instruction_Index(?instr, ?index),
//    AssignInstruction_To(?instr, ?to),
//    Instruction_Method(?instr, ?method),
//    ?ssa_name = cat(?to, cat("_", to_string(?index))).

.decl SSA_AssignCast(?instr:symbol, ?index:number, ?ssa_name:symbol, ?method:symbol)
.output SSA_AssignCast

SSA_AssignCast(?instr, ?index, ?ssa_name, ?method) :-
    isAssignCast_Insn(?instr),
    SSA_AssignDetails(?instr, ?to, ?index, ?ssa_name, ?method).

.decl SSA_AssignCastNumConstant(?instr:symbol, ?index:number, ?ssa_name:symbol, ?method:symbol)
.output SSA_AssignCastNumConstant

SSA_AssignCastNumConstant(?instr, ?index, ?ssa_name, ?method) :-
    isAssignCastNumConstant_Insn(?instr),
    SSA_AssignDetails(?instr, ?to, ?index, ?ssa_name, ?method).

.decl SSA_AssignCastNull(?instr:symbol, ?index:number, ?ssa_name:symbol, ?method:symbol)
.output SSA_AssignCastNull

SSA_AssignCastNull(?instr, ?index, ?ssa_name, ?method) :-
    isAssignCastNull_Insn(?instr),
    SSA_AssignDetails(?instr, ?to, ?index, ?ssa_name, ?method).

.decl SSA_AssignNumConstant(?instr:symbol, ?index:number, ?ssa_name:symbol, ?method:symbol)
.output SSA_AssignNumConstant

SSA_AssignNumConstant(?instr, ?index, ?ssa_name, ?method) :-
    isAssignNumConstant_Insn(?instr),
    SSA_AssignDetails(?instr, ?to, ?index, ?ssa_name, ?method).

.decl SSA_AssignInstanceOf(?instr:symbol, ?index:number, ?ssa_name:symbol, ?method:symbol)
.output SSA_AssignInstanceOf

SSA_AssignInstanceOf(?instr, ?index, ?ssa_name, ?method) :-
    isAssignInstanceOf_Insn(?instr),
    SSA_AssignDetails(?instr, ?to, ?index, ?ssa_name, ?method).

// TODO: Is this needed?
//.decl SSA_AssignPhantomInvoke(?instr:symbol, ?index:number, ?ssa_name:symbol, ?method:symbol)
//.output SSA_AssignPhantomInvoke
//
//SSA_Alias(?method, ?to, ?ssa_name),
//SSA_AssignPhantomInvoke(?instr, ?index, ?ssa_name, ?method) :-
//    isAssignPhantomInvoke(?instr),
//    Instruction_Index(?instr, ?index),
//    AssignInstruction_To(?instr, ?to),
//    Instruction_Method(?instr, ?method),
//    ?ssa_name = cat(?to, cat("_", to_string(?index))).

// Simple implementation of the mathematical definition of strict
// domination.
.decl StrictlyDominates(?dominator:symbol, ?block:symbol)
.output StrictlyDominates

StrictlyDominates(?dominator, ?block) :-
    Dominates(?dominator, ?block),
    !?dominator = ?block.

.decl DominanceFrontier(?dBlock:symbol, ?block:symbol)
.output DominanceFrontier

DominanceFrontier(?dBlock, ?block) :-
    MayPredecessorBBModuloThrow(?pred, ?block),
    Dominates(?dBlock, ?pred),
    !StrictlyDominates(?dBlock, ?block).

.decl DFPlus(?dBlock:symbol, ?block:symbol, ?var:symbol)
.output DFPlus

DFPlus(?dBlock, ?block, ?var) :-
    ContainsAssignment(?dBlock, ?var),
    DominanceFrontier(?dBlock, ?block).

DFPlus(?dBlock, ?block, ?var) :-
    ContainsAssignment(?dBlock, ?var),
    DFPlus(?dBlock, ?block, ?var).

.decl ContainsAssignment(?dBlock:symbol, ?var:symbol)

ContainsAssignment(?dBlock, ?var) :-
    BasicBlockHead(?insn, ?dBlock),
    SSA_AssignDetails(?insn, ?var, _, _, _).

.decl DebugBB(?bb:symbol)
.output BasicBlockBegin

DebugBB(?bb) :- BasicBlockBegin(?bb).

// Phi Instrutions inserted at basic blocks.
// ?phi_var is the new phi variable name that will be generated,
// ?block is the basic block (represented by it's first instr) where
// the Phi Instruction will be inserted.
.decl PhiAssign(?phi_var:symbol, ?arity:number, ?block:symbol)
.output PhiAssign

SSA_Alias(?phi_var, ?var),
PhiAssign(?phi_var, ?arity, ?block) :-
    DFPlus(_, ?block, ?var),
    Instruction_Index(?block, ?index),
    ?arity = count : MayPredecessorBBModuloThrow(_, ?block),
    ?phi_var = cat(cat(?var, "_phi_"), to_string(?index)).
    
.decl BBFollowsSimilarDef(?block:symbol, ?instr:symbol, ?def:symbol)
.output BBFollowsSimilarDef

BBFollowsSimilarDef(?block, ?instr, ?original) :-
    BasicBlockHead(?instr, ?block),
    BasicBlockHead(?follow, ?block),
    PhiAssign(?phi_var, _, ?instr),
    SSA_Alias(?phi_var, ?original),
    SSA_AssignToOriginal(?follow, ?original),
    Instruction_Index(?instr, ?i),
    Instruction_Index(?follow, ?j),
    ?i < ?j.

BBFollowsSimilarDef(?block, ?instr, ?original) :-
    BasicBlockHead(?instr, ?block),
    BasicBlockHead(?follow, ?block),
    SSA_AssignToOriginal(?instr, ?original),
    SSA_AssignToOriginal(?follow, ?original),
    Instruction_Index(?instr, ?i),
    Instruction_Index(?follow, ?j),
    ?i < ?j.

.decl BBLocalOutDefs(?block:symbol, ?def:symbol)
.output BBLocalOutDefs

BBLocalOutDefs(?block, ?def) :-
    BasicBlockBegin(?block),
    PhiAssign(?def, _, ?block),
    SSA_Alias(?def, ?original),
    !SSA_AssignToOriginal(?block, ?original),
    !BBFollowsSimilarDef(?block, ?block, ?original).

BBLocalOutDefs(?block, ?def) :-
    BasicBlockBegin(?block),
    BasicBlockHead(?assgn, ?block),
    SSA_AssignToOriginal(?assgn, ?original),
    SSA_AssignDetails(?assgn, ?original, _, ?def, _),
    !BBFollowsSimilarDef(?block, ?assgn, ?original).

BBLocalOutDefs(?block, ?def) :-
    BasicBlockBegin(?block),
    Instruction_Index(?block, 1),
    Instruction_Method(?block, ?method),
    (SSA_FormalParam(_, ?method, ?def);
    SSA_ThisVar(?method, ?def)),
    SSA_Alias(?def, ?origin),
    !ContainsAssignment(?block, ?origin).

.decl ExistsLocalDef(?block:symbol, ?def:symbol)
ExistsLocalDef(?block, ?original) :-
    BBLocalOutDefs(?block, ?def),
    SSA_Alias(?def, ?original).

.decl BBOutDefs(?block:symbol, ?def:symbol)
.output BBOutDefs

.decl BasicBlockOutDefs(?block:symbol, ?ssa_var:symbol, ?origin:symbol)
.output BasicBlockOutDefs

BasicBlockOutDefs(?block, ?ssa_var, ?origin) :-
    BasicBlockTail(?block, ?end),
    !SSA_AssignToOriginal(?end, ?origin),
    ReachingDef(?end, ?ssa_var, ?origin).

BasicBlockOutDefs(?block, ?ssa_var, ?origin) :-
    BasicBlockTail(?block, ?end),
    SSA_Alias(?ssa_var, ?origin),
    SSA_AssignDetails(?end, _, _, ?ssa_var, _).

BBOutDefs(?block, ?def) :-
    BBLocalOutDefs(?block, ?def).

BBOutDefs(?block, ?prev_def) :-
    MayPredecessorBBModuloThrow(?pred, ?block),
    BBOutDefs(?pred, ?prev_def),
    SSA_Alias(?prev_def, ?original),
    !ExistsLocalDef(?block, ?original).

// Two defs are similar, if they are both renames of the same
// variable in the original program.
.decl SimilarDefs(?def_1:symbol, ?def_2:symbol)

SimilarDefs(?def_1, ?def_2) :-
    SSA_Alias(?def_1, ?original),
    SSA_Alias(?def_2, ?original).

// A phi assignment is non trivial, if there exist two different predecessors
// basic blocks that have different defs for var in their out-def sets.
.decl isNonTrivialPhi(?block:symbol, ?var:symbol)

isNonTrivialPhi(?block, ?var) :-
    PhiAssign(?var, _, ?block),
    ExistTwoDifferentPredDefs(?block, ?var).

// Helper predicate that achieves the core logic for the non trivial phi predicate.
.decl ExistTwoDifferentPredDefs(?block:symbol, ?phi_name:symbol)

// Refactored, doesnt compile
ExistTwoDifferentPredDefs(?block, ?phi_name) :-
    MayPredecessorBBModuloThrow(?pred1, ?block),
    MayPredecessorBBModuloThrow(?pred2, ?block),
    ?pred1 != ?pred2,
    SSA_Alias(?phi_name, ?origin),
    BasicBlockOutDefs(?pred1, ?def_1, ?origin),
    BasicBlockOutDefs(?pred2, ?def_2, ?origin),
    ?def_1 != ?def_2.

// Old
//ExistTwoDifferentPredDefs(?block, ?phi_name) :-
//    MayPredecessorBBModuloThrow(?pred1, ?block),
//    MayPredecessorBBModuloThrow(?pred2, ?block),
//    ?pred1 != ?pred2,
//    SSA_Alias(?phi_name, ?origin),
//    BBOutDefs(?pred_1, ?def_1),
//    BBOutDefs(?pred_2, ?def_2),
//    SimilarDefs(?def_1, ?def_2),
//    SimilarDefs(?phi_name, ?def_1),
//    ?def_1 != ?def_2.

.decl SimilarOutDefs(?block:symbol, ?def:symbol, ?out_def:symbol)

SimilarOutDefs(?block, ?def, ?out_def) :-
    BBOutDefs(?block, ?out_def),
    SimilarDefs(?def, ?out_def).

// These instructions create chains of assignments, at the head of each block.
// This is a helper relation to assist the final assignment operation, which 
// will require linking the assignments with the rest of the code.
.decl PhiPseudoAssign(?phi_var:symbol, ?def:symbol, ?src_block:symbol, ?dst_block:symbol, ?pseudoname:symbol)
.output PhiPseudoAssign

// Many assigns on the same phi var, consist of a PhiChunk. These are unique, since 
// phi_var is unique (SSA naming).
.decl PhiChunk(?phi_var:symbol)
.output PhiChunk

// Many PhiChunks in the same basic block, consist of a PhiHeader.
.decl PhiHeader(?block:symbol)
.output PhiHeader

// TODO: Check validity/necessity of isNonTrivialPhi relation

PhiChunk(?phi_var),
PhiHeader(?dst_block),
PhiPseudoAssign(?phi_var, ?phi_arg, ?src_block, ?dst_block, ?pseudoname) :-
    PhiAssign(?phi_var, _, ?dst_block),
    //isNonTrivialPhi(?dst_block, ?phi_var),
    MayPredecessorBBModuloThrow(?src_block, ?dst_block),
    SimilarOutDefs(?src_block, ?phi_var, ?phi_arg),
    Instruction_Index(?src_block, ?src_idx),
    Instruction_Index(?dst_block, ?dst_idx),
    ?pseudoname = cat(?phi_var, cat("_", to_string(?src_idx))).

// TODO: Are the initial checks needed?
.decl ExistsPseudoAssignBetween(?prev:symbol, ?next:symbol)
ExistsPseudoAssignBetween(?prev, ?next) :-
    PhiPseudoAssign(?phi, _, _, ?block, ?prev),
    PhiPseudoAssign(?phi, _, _, ?block, ?next),
    PhiPseudoAssign(?phi, _, _, ?block, ?mid),
    ord(?prev) < ord(?next),
    ord(?prev) < ord(?mid),
    ord(?mid)  < ord(?next).

.decl ExistsPhiChunkBetween(?prev:symbol, ?next:symbol)

ExistsPhiChunkBetween(?prev, ?next) :-
    PhiPseudoAssign(?prev, _, _, ?block, _),
    PhiPseudoAssign(?next, _, _, ?block, _),
    PhiPseudoAssign(?mid, _, _, ?block, _),
    ord(?prev) < ord(?next),
    ord(?prev) < ord(?mid),
    ord(?mid)  < ord(?next).

// New next relation, since we need to include the new assignments that
// are generated by the phi placement.
.decl SSANext(?prev:symbol, ?next:symbol)
.output SSANext

.decl PhiChunkNext(?prev:symbol, ?next:symbol)
.output PhiChunkNext

// Link PhiChunk assignments
SSANext(?prev, ?next),
PhiChunkNext(?prev, ?next) :-
    PhiPseudoAssign(?chunk, _, _, ?block, ?prev),
    PhiPseudoAssign(?chunk, _, _, ?block, ?next),
    ord(?prev) < ord(?next),
    !ExistsPseudoAssignBetween(?prev, ?next).

.decl PhiChunkStart(?phi_chunk:symbol, ?start:symbol)
.output PhiChunkStart

PhiChunkStart(?phi_chunk, ?start) :-
    PhiPseudoAssign(?phi_chunk, _, _, _, ?start),
    !PhiChunkNext(_, ?start).

.decl PhiChunkEnd(?phi_chunk:symbol, ?end:symbol)
.output PhiChunkEnd

PhiChunkEnd(?phi_chunk, ?end) :-
    PhiPseudoAssign(?phi_chunk, _, _, _, ?end),
    !PhiChunkNext(?end, _).

.decl PhiHeaderNext(?prev:symbol, ?next:symbol)

SSANext(?prev_end, ?next_start),
PhiHeaderNext(?prev, ?next) :-
    PhiPseudoAssign(?prev, _, _, ?phi_header, _),
    PhiPseudoAssign(?next, _, _, ?phi_header, _),
    PhiChunkEnd(?prev, ?prev_end),
    PhiChunkStart(?next, ?next_start),
    ord(?prev) < ord(?next),
    !ExistsPhiChunkBetween(?prev, ?next).
    
.decl PhiHeaderStart(?phi_chunk:symbol, ?start:symbol)
.output PhiHeaderStart

PhiHeaderStart(?phi_header, ?start) :-
    PhiPseudoAssign(?start_chunk, _, _, ?phi_header, _),
    PhiChunkStart(?start_chunk, ?start),
    !PhiHeaderNext(_, ?start_chunk).

.decl PhiHeaderEnd(?phi_chunk:symbol, ?end:symbol)
.output PhiHeaderEnd

SSANext(?end, ?phi_header),
PhiHeaderEnd(?phi_header, ?end) :-
    PhiPseudoAssign(?end_chunk, _, _, ?phi_header, _),
    PhiChunkEnd(?end_chunk, ?end),
    !PhiHeaderNext(?end_chunk, _).

SSANext(?prev, ?next) :-
    Instruction_Next(?prev, ?old_next),
    PhiHeaderStart(?old_next, ?next).

SSANext(?prev, ?next) :-
    Instruction_Next(?prev, ?next),
    !PhiHeaderStart(?next, _).

.decl isInstr(?insn:symbol)

// TODO: Add Instruction_Method
isInstruction(?insn),
Instruction_Index(?insn, ?index) :- 
    ArrayInitialValueFromConst(?insn, ?index, _, _, _, _).

isInstruction(?insn) :-
    Instruction_Method(?insn, _).

isInstruction(?insn) :-
    PhiPseudoAssign(_, _, _, _, ?insn).

// Simple index calculation, based on the SSANext relation.
.decl SSA_InstructionIndex(?insn:symbol, ?index:number)
.output SSA_InstructionIndex

// Base case; If the insn has no previous instruction, then its index
// is one.
SSA_InstructionIndex(?insn, 1) :-
    isInstruction(?insn),
    !SSANext(_, ?insn).

// If the insn has a prev instruction and prev has index "index", then
// insn has index "index  + 1".
SSA_InstructionIndex(?insn, ?index + 1) :-
    SSANext(?prev, ?insn),
    SSA_InstructionIndex(?prev, ?index).

// If the phi header for the basic block where insn is in, contains an phi
// pseudo assignment on ssa_var, which is an ssa rename for origin.
.decl ExistsDefInPhiHeader(?insn:symbol, ?ssa_var:symbol, ?origin:symbol)
.output ExistsDefInPhiHeader

ExistsDefInPhiHeader(?insn, ?ssa_var, ?origin) :-
    BasicBlockHead(?insn, ?head),
    PhiPseudoAssign(?ssa_var, _, _, ?head, _),
    SSA_Alias(?ssa_var, ?origin).

// This is a simple calculation of the reaching SSA definitions (ssa_var),
// at a given instruction (insn), for a given origin variable (not ssa-renamed,
// as seen in the original program).
.decl ReachingDef(?insn:symbol, ?ssa_var:symbol, ?origin:symbol)
.output ReachingDef

// If an instruction is the first instruction in a basic block, and a ssa defintion
// for origin exists in the Phi Header, then that def is the reaching def.
ReachingDef(?insn, ?ssa_var, ?origin) :-
    BasicBlockBegin(?insn),
    ExistsDefInPhiHeader(?insn, ?ssa_var, ?origin).

// If an instruction is the first instrution in a basic block, and there is no ssa
// definition for origin in the Phi Header, then the reaching definition is in the
// outwards defs of any of the predecessor basic blocks (the defs will all be the same,
// otherwise there would be a Phi Assignment in the Phi header).

// Old
//ReachingDef(?insn, ?ssa_var, ?origin) :-
//    BasicBlockBegin(?insn),
//    !ExistsDefInPhiHeader(?insn, _, ?origin),
//    SSA_Alias(?saa_var, ?origin),
//    MayPredecessorBBModuloThrow(?pred, ?insn),
//    SimilarOutDefs(?pred, _, ?ssa_var).

// Based on new
ReachingDef(?insn, ?ssa_var, ?origin) :-
    BasicBlockBegin(?insn),
    !ExistsDefInPhiHeader(?insn, _, ?origin),
    MayPredecessorBBModuloThrow(?pred, ?insn),
    BasicBlockOutDefs(?pred, ?ssa_var, ?origin).

// If an instruction is not the first instruction in a basic block, and the previous
// instuction is not an assignment with LHS an ssa rename of origin, then the reaching
// ssa definition for origin at insn is the same as the reaching ssa definition for origin
// at prev (recursive definition).
ReachingDef(?insn, ?ssa_var, ?origin) :-
    PrevInSameBasicBlock(?insn, ?prev),
    SSA_Alias(?ssa_var, ?origin),
    !SSA_AssignToOriginal(?prev, ?origin),
    ReachingDef(?prev, ?ssa_var, ?origin).

// If an instruction is not the first instruction in a basic block, and the previous
// instuction is an assignment with LHS an ssa rename of origin, the the reaching ssa defition
// for origin at insn is exactly that LHS ssa rename of origin.
ReachingDef(?insn, ?ssa_var, ?origin) :-
    PrevInSameBasicBlock(?insn, ?prev),
    SSA_Alias(?ssa_var, ?origin),
    SSA_AssignDetails(?prev, _, _, ?ssa_var, _).

// If an instruction is the first instruction in a method, then all formal paramters and
// the "this" register are reaching defs to that instruction.
ReachingDef(?insn, ?ssa_var, ?origin) :-
    SSA_InstructionIndex(?insn, 1),
    Instruction_Method(?insn, ?method),
    (SSA_FormalParam(_, ?method, ?ssa_var);
    SSA_ThisVar(?method, ?ssa_var)),
    SSA_Alias(?ssa_var, ?origin).

// Rule rewriting
.decl RewriteArrayInitialValueFromConst(?insn:symbol, ?index:number, ?to:symbol, ?arrayIndex:number, ?const:symbol, ?baseHeap:symbol)
.output RewriteArrayInitialValueFromConst(filename="ArrayInitialValueFromConst.facts")

RewriteArrayInitialValueFromConst(?insn, ?index, ?to, ?arrayIndex, ?const, ?baseHeap) :-
    ArrayInitialValueFromConst(?insn, ?index, ?var_origin, ?arrayIndex, ?const, ?baseHeap),
    ReachingDef(?insn, ?to, ?var_origin).

.decl RewriteActualParam(?index:number, ?invocation:symbol, ?var:symbol)
.output RewriteActualParam(filename="ActualParam.facts")

RewriteActualParam(?index, ?invocation, ?var) :-
    ActualParam(?index, ?invocation, ?var_origin),
    ReachingDef(?invocation, ?var, ?var_origin).

.decl RewriteAssignBinop(?insn:symbol, ?index:number, ?to:symbol, ?inmethod:symbol)
.output RewriteAssignBinop(filename="AssignBinop.facts")

RewriteAssignBinop(?insn, ?index, ?to, ?inmethod) :-
    SSA_AssignBinop(?insn, _, ?to, ?inmethod),
    SSA_InstructionIndex(?insn, ?index).

.decl RewriteAssignCast(?insn:symbol, ?index:number, ?from:symbol, ?to:symbol, ?type:symbol, ?inmethod:symbol)
.output RewriteAssignCast(filename="AssignCast.facts")

RewriteAssignCast(?insn, ?index, ?from, ?to, ?type, ?inmethod) :-
    SSA_AssignCast(?insn, _, ?to, ?inmethod),
    AssignCast_Type(?insn, ?type),
    AssignCast_From(?insn, ?from_origin),
    SSA_InstructionIndex(?insn, ?index),
    ReachingDef(?insn, ?from, ?from_origin).

.decl RewriteAssignCastNull(?insn:symbol, ?index:number, ?to:symbol, ?type:symbol, ?inmethod:symbol)
.output RewriteAssignCastNull(filename="AssignCastNull.facts")

RewriteAssignCastNull(?insn, ?index, ?to, ?type, ?inmethod) :-
    SSA_AssignCastNull(?insn, _, ?to, ?inmethod),
    AssignCast_Type(?insn, ?type),
    SSA_InstructionIndex(?insn, ?index).

.decl RewriteAssignCastNumConstant(?insn:symbol, ?index:number, ?const:symbol, ?to:symbol, ?type:symbol, ?inmethod:symbol)
.output RewriteAssignCastNumConstant(filename="AssignCastNumConstant.facts")

RewriteAssignCastNumConstant(?insn, ?index, ?const, ?to, ?type, ?inmethod) :-
    SSA_AssignCastNull(?insn, _, ?to, ?inmethod),
    AssignCast_Type(?insn, ?type),
    AssignCastNumConstant_Id(?insn, ?const),
    SSA_InstructionIndex(?insn, ?index).

.decl RewriteAssignOperFrom(?insn:symbol, ?pos:number, ?from:symbol)
.output RewriteAssignOperFrom(filename="AssignOperFrom.facts")

RewriteAssignOperFrom(?insn, ?pos, ?from) :-
    AssignOper_From(?insn, ?pos, ?from_origin),
    ReachingDef(?insn, ?from, ?from_origin).

.decl RewriteAssignLocal(?insn:symbol, ?index:number, ?to:symbol, ?from:symbol, ?inmethod:symbol)
.output RewriteAssignLocal(filename="AssignLocal.facts")

RewriteAssignLocal(?insn, ?index, ?to, ?from, ?inmethod) :-
    SSA_InstructionIndex(?insn, ?index),
    SSA_AssignLocal(?insn, _, ?to, ?inmethod),
    AssignLocal_From(?insn, ?from_origin),
    ReachingDef(?insn, ?from, ?from_origin).

