#define ANDROID

#import "../souffle-logic/facts/import-facts.dl"
#import "../souffle-logic/facts/import-entities.dl"
#import "../souffle-logic/facts/flow-sensitive-schema.dl"
#import "../souffle-logic/facts/flow-insensitive-schema.dl"
#import "../souffle-logic/addons/cfg-analysis/declarations.dl"
#import "../souffle-logic/addons/cfg-analysis/analysis.dl"

// If instr is an assignment found at instruction i in method meth
// then create a new assignment fact with same RHS and LHS v_i,
// where v is the name of the original variable.

// Holds all ssa renames in the program for a given origin variable.
// e.g. (v0_0, v0), (v0_1, v0) ... 
.decl SSA_Alias(?ssa_name:symbol, ?original:symbol)

// Helper relation to factor out some code.
.decl SSA_AssignDetails(?instr:symbol, ?to:symbol, ?index:number, ?ssa_name:symbol, ?method:symbol)

// Aux relations
.decl SSA_AssignToOriginal(?instr:symbol, ?original:symbol)

.decl SSA_FormalParam(?index:number, ?method:symbol, ?ssa_name:symbol)
.decl SSA_ThisVar(?method:symbol, ?ssa_name:symbol)

SSA_AssignToOriginal(?instr, ?to),
SSA_Alias(cat(?to, cat("_", to_string(?index))), ?to),
SSA_AssignDetails(?instr, ?to, ?index, cat(?to, cat("_", to_string(?index))), ?method) :-
    Instruction_Index(?instr, ?index),
    AssignInstruction_To(?instr, ?to),
    Instruction_Method(?instr, ?method).

SSA_AssignToOriginal(?instr, ?to),
SSA_Alias(cat(?to, cat("_", to_string(?index))), ?to),
SSA_AssignDetails(?instr, ?to, ?index, cat(?to, cat("_", to_string(?index))), ?method) :-
    _ExceptionHandler(?instr, ?method, ?index, _, ?to, _, _).

SSA_AssignToOriginal(?invocation, ?to),
SSA_Alias(cat(?to, cat("_", to_string(?index))), ?to),
SSA_AssignDetails(?invocation, ?to, ?index, cat(?to, cat("_", to_string(?index))), ?method) :-
    Instruction_Index(?invocation, ?index),
    AssignReturnValue(?invocation, ?to),
    Instruction_Method(?invocation, ?method).

SSA_AssignToOriginal(?instr, ?to),
SSA_Alias(cat(?to, cat("_", to_string(?index))), ?to),
SSA_AssignDetails(?instr, ?to, ?index, cat(?to, cat("_", to_string(?index))), ?method) :-
    _LoadArrayIndex(?instr, ?index, ?to, _, ?method).

SSA_AssignToOriginal(?instr, ?to),
SSA_Alias(cat(?to, cat("_", to_string(?index))), ?to),
SSA_AssignDetails(?instr, ?to, ?index, cat(?to, cat("_", to_string(?index))), ?method) :-
    _LoadInstanceField(?instr, ?index, ?to, _, _, ?method).

SSA_AssignToOriginal(?instr, ?to),
SSA_Alias(cat(?to, cat("_", to_string(?index))), ?to),
SSA_AssignDetails(?instr, ?to, ?index, cat(?to, cat("_", to_string(?index))), ?method) :-
    _LoadStaticField(?instr, ?index, ?to, _, ?method).

SSA_Alias(cat(?original, cat("_", "0")), ?original),
SSA_FormalParam(?index, ?method, cat(?original, cat("_", "0"))) :-
    FormalParam(?index, ?method, ?original).

SSA_Alias(cat(?original, cat("_", "0")), ?original),
SSA_ThisVar(?method, cat(?original, cat("_", "0"))) :-
    ThisVar(?method, ?original).

.decl SSA_AssignHeapAllocation(?instr:symbol, ?index:number, ?ssa_name:symbol, ?method:symbol)

SSA_AssignHeapAllocation(?instr, ?index, ?ssa_name, ?method) :-
    isAssignHeapAllocation_Insn(?instr),
    SSA_AssignDetails(?instr, _, ?index, ?ssa_name, ?method).

.decl SSA_AssignLocal(?instr:symbol, ?index:number, ?ssa_name:symbol, ?method:symbol)

SSA_AssignLocal(?instr, ?index, ?ssa_name, ?method) :-
    isAssignLocal_Insn(?instr),
    SSA_AssignDetails(?instr, _, ?index, ?ssa_name, ?method).

.decl SSA_AssignBinop(?instr:symbol, ?index:number, ?ssa_name:symbol, ?method:symbol)

SSA_AssignBinop(?instr, ?index, ?ssa_name, ?method) :-
    isAssignBinop_Insn(?instr),
    SSA_AssignDetails(?instr, _, ?index, ?ssa_name, ?method).

.decl SSA_AssignUnop(?instr:symbol, ?index:number, ?ssa_name:symbol, ?method:symbol)

SSA_AssignUnop(?instr, ?index, ?ssa_name, ?method) :-
    isAssignUnop_Insn(?instr),
    SSA_AssignDetails(?instr, _, ?index, ?ssa_name, ?method).

.decl SSA_AssignCast(?instr:symbol, ?index:number, ?ssa_name:symbol, ?method:symbol)

SSA_AssignCast(?instr, ?index, ?ssa_name, ?method) :-
    isAssignCast_Insn(?instr),
    SSA_AssignDetails(?instr, _, ?index, ?ssa_name, ?method).

.decl SSA_AssignCastNumConstant(?instr:symbol, ?index:number, ?ssa_name:symbol, ?method:symbol)

SSA_AssignCastNumConstant(?instr, ?index, ?ssa_name, ?method) :-
    isAssignCastNumConstant_Insn(?instr),
    SSA_AssignDetails(?instr, _, ?index, ?ssa_name, ?method).

.decl SSA_AssignCastNull(?instr:symbol, ?index:number, ?ssa_name:symbol, ?method:symbol)

SSA_AssignCastNull(?instr, ?index, ?ssa_name, ?method) :-
    isAssignCastNull_Insn(?instr),
    SSA_AssignDetails(?instr, _, ?index, ?ssa_name, ?method).

.decl SSA_AssignNull(?instr:symbol, ?index:number, ?ssa_name:symbol, ?method:symbol)

SSA_AssignNull(?instr, ?index, ?ssa_name, ?method) :-
    isAssignNull_Insn(?instr),
    SSA_AssignDetails(?instr, _, ?index, ?ssa_name, ?method).

.decl SSA_AssignNumConstant(?instr:symbol, ?index:number, ?ssa_name:symbol, ?method:symbol)

SSA_AssignNumConstant(?instr, ?index, ?ssa_name, ?method) :-
    isAssignNumConstant_Insn(?instr),
    SSA_AssignDetails(?instr, _, ?index, ?ssa_name, ?method).

.decl SSA_AssignInstanceOf(?instr:symbol, ?index:number, ?ssa_name:symbol, ?method:symbol)

SSA_AssignInstanceOf(?instr, ?index, ?ssa_name, ?method) :-
    isAssignInstanceOf_Insn(?instr),
    SSA_AssignDetails(?instr, _, ?index, ?ssa_name, ?method).

.decl SSA_LoadArrayIndex(?insn:symbol, ?index:number, ?to:symbol, ?method:symbol)
    
SSA_LoadArrayIndex(?insn, ?index, ?ssa_name, ?method) :-
    isLoadArrayIndex_Insn(?insn),
    SSA_AssignDetails(?insn, _, ?index, ?ssa_name, ?method).
    
.decl SSA_LoadInstanceField(?insn:symbol, ?index:number, ?to:symbol, ?method:symbol)
    
SSA_LoadInstanceField(?insn, ?index, ?ssa_name, ?method) :-
    isLoadInstanceField_Insn(?insn),
    SSA_AssignDetails(?insn, _, ?index, ?ssa_name, ?method).

.decl SSA_LoadStaticField(?insn:symbol, ?index:number, ?to:symbol, ?method:symbol)

SSA_LoadStaticField(?insn, ?index, ?ssa_name, ?method) :-
    isLoadStaticField_Insn(?insn),
    SSA_AssignDetails(?insn, _, ?index, ?ssa_name, ?method).
    
// TODO: Is this needed?
//.decl SSA_AssignPhantomInvoke(?instr:symbol, ?index:number, ?ssa_name:symbol, ?method:symbol)
//.output SSA_AssignPhantomInvoke
//
//SSA_Alias(?method, ?to, ?ssa_name),
//SSA_AssignPhantomInvoke(?instr, ?index, ?ssa_name, ?method) :-
//    isAssignPhantomInvoke(?instr),
//    Instruction_Index(?instr, ?index),
//    AssignInstruction_To(?instr, ?to),
//    Instruction_Method(?instr, ?method),
//    ?ssa_name = cat(?to, cat("_", to_string(?index))).

// Simple implementation of the mathematical definition of strict
// domination.
.decl StrictlyDominates(?dominator:symbol, ?block:symbol)

StrictlyDominates(?dominator, ?block) :-
    Dominates(?dominator, ?block),
    !?dominator = ?block.

.decl DominanceFrontier(?dBlock:symbol, ?block:symbol)

DominanceFrontier(?dBlock, ?block) :-
    MayPredecessorBBModuloThrow(?pred, ?block),
    Dominates(?dBlock, ?pred),
    !StrictlyDominates(?dBlock, ?block).

.decl DFPlus(?dBlock:symbol, ?block:symbol, ?var:symbol)

DFPlus(?dBlock, ?block, ?var) :-
    ContainsAssignment(?dBlock, ?var),
    DominanceFrontier(?dBlock, ?block).

DFPlus(?dBlock, ?block, ?var) :-
    ContainsAssignment(?dBlock, ?var),
    DFPlus(?dBlock, ?block, ?var).

.decl ContainsAssignment(?dBlock:symbol, ?var:symbol)

ContainsAssignment(?dBlock, ?var) :-
    BasicBlockHead(?insn, ?dBlock),
    SSA_AssignDetails(?insn, ?var, _, _, _).

.decl DebugBB(?bb:symbol)

DebugBB(?bb) :- BasicBlockBegin(?bb).

// Phi Instrutions inserted at basic blocks.
// ?phi_var is the new phi variable name that will be generated,
// ?block is the basic block (represented by it's first instr) where
// the Phi Instruction will be inserted.
.decl PhiAssign(?phi_var:symbol, ?arity:number, ?block:symbol)

SSA_Alias(?phi_var, ?var),
PhiAssign(?phi_var, ?arity, ?block) :-
    DFPlus(_, ?block, ?var),
    Instruction_Index(?block, ?index),
    ?arity = count : MayPredecessorBBModuloThrow(_, ?block),
    ?phi_var = cat(cat(?var, "_phi_"), to_string(?index)).
    
.decl BBFollowsSimilarDef(?block:symbol, ?instr:symbol, ?def:symbol)

BBFollowsSimilarDef(?block, ?instr, ?original) :-
    BasicBlockHead(?instr, ?block),
    BasicBlockHead(?follow, ?block),
    PhiAssign(?phi_var, _, ?instr),
    SSA_Alias(?phi_var, ?original),
    SSA_AssignToOriginal(?follow, ?original),
    Instruction_Index(?instr, ?i),
    Instruction_Index(?follow, ?j),
    ?i < ?j.

BBFollowsSimilarDef(?block, ?instr, ?original) :-
    BasicBlockHead(?instr, ?block),
    BasicBlockHead(?follow, ?block),
    SSA_AssignToOriginal(?instr, ?original),
    SSA_AssignToOriginal(?follow, ?original),
    Instruction_Index(?instr, ?i),
    Instruction_Index(?follow, ?j),
    ?i < ?j.

.decl BBLocalOutDefs(?block:symbol, ?def:symbol)

BBLocalOutDefs(?block, ?def) :-
    BasicBlockBegin(?block),
    PhiAssign(?def, _, ?block),
    SSA_Alias(?def, ?original),
    !SSA_AssignToOriginal(?block, ?original),
    !BBFollowsSimilarDef(?block, ?block, ?original).

BBLocalOutDefs(?block, ?def) :-
    BasicBlockBegin(?block),
    BasicBlockHead(?assgn, ?block),
    SSA_AssignToOriginal(?assgn, ?original),
    SSA_AssignDetails(?assgn, ?original, _, ?def, _),
    !BBFollowsSimilarDef(?block, ?assgn, ?original).

BBLocalOutDefs(?block, ?def) :-
    BasicBlockBegin(?block),
    Instruction_Index(?block, 1),
    Instruction_Method(?block, ?method),
    (SSA_FormalParam(_, ?method, ?def);
    SSA_ThisVar(?method, ?def)),
    SSA_Alias(?def, ?origin),
    !ContainsAssignment(?block, ?origin).

.decl ExistsLocalDef(?block:symbol, ?def:symbol)
ExistsLocalDef(?block, ?original) :-
    BBLocalOutDefs(?block, ?def),
    SSA_Alias(?def, ?original).

.decl BBOutDefs(?block:symbol, ?def:symbol)

.decl BasicBlockOutDefs(?block:symbol, ?ssa_var:symbol, ?origin:symbol)

BasicBlockOutDefs(?block, ?ssa_var, ?origin) :-
    BasicBlockTail(?block, ?end),
    !SSA_AssignToOriginal(?end, ?origin),
    ReachingDef(?end, ?ssa_var, ?origin).

BasicBlockOutDefs(?block, ?ssa_var, ?origin) :-
    BasicBlockTail(?block, ?end),
    SSA_Alias(?ssa_var, ?origin),
    SSA_AssignDetails(?end, _, _, ?ssa_var, _).

BBOutDefs(?block, ?def) :-
    BBLocalOutDefs(?block, ?def).

BBOutDefs(?block, ?prev_def) :-
    MayPredecessorBBModuloThrow(?pred, ?block),
    BBOutDefs(?pred, ?prev_def),
    SSA_Alias(?prev_def, ?original),
    !ExistsLocalDef(?block, ?original).

// Two defs are similar, if they are both renames of the same
// variable in the original program.
.decl SimilarDefs(?def_1:symbol, ?def_2:symbol)

SimilarDefs(?def_1, ?def_2) :-
    SSA_Alias(?def_1, ?original),
    SSA_Alias(?def_2, ?original).

// A phi assignment is non trivial, if there exist two different predecessors
// basic blocks that have different defs for var in their out-def sets.
.decl isNonTrivialPhi(?block:symbol, ?var:symbol)

isNonTrivialPhi(?block, ?var) :-
    PhiAssign(?var, _, ?block),
    ExistTwoDifferentPredDefs(?block, ?var).

// Helper predicate that achieves the core logic for the non trivial phi predicate.
.decl ExistTwoDifferentPredDefs(?block:symbol, ?phi_name:symbol)

// Refactored, doesnt compile
ExistTwoDifferentPredDefs(?block, ?phi_name) :-
    MayPredecessorBBModuloThrow(?pred1, ?block),
    MayPredecessorBBModuloThrow(?pred2, ?block),
    ?pred1 != ?pred2,
    SSA_Alias(?phi_name, ?origin),
    BasicBlockOutDefs(?pred1, ?def_1, ?origin),
    BasicBlockOutDefs(?pred2, ?def_2, ?origin),
    ?def_1 != ?def_2.

// Old
//ExistTwoDifferentPredDefs(?block, ?phi_name) :-
//    MayPredecessorBBModuloThrow(?pred1, ?block),
//    MayPredecessorBBModuloThrow(?pred2, ?block),
//    ?pred1 != ?pred2,
//    SSA_Alias(?phi_name, ?origin),
//    BBOutDefs(?pred_1, ?def_1),
//    BBOutDefs(?pred_2, ?def_2),
//    SimilarDefs(?def_1, ?def_2),
//    SimilarDefs(?phi_name, ?def_1),
//    ?def_1 != ?def_2.

.decl SimilarOutDefs(?block:symbol, ?def:symbol, ?out_def:symbol)

SimilarOutDefs(?block, ?def, ?out_def) :-
    BBOutDefs(?block, ?out_def),
    SimilarDefs(?def, ?out_def).

// These instructions create chains of assignments, at the head of each block.
// This is a helper relation to assist the final assignment operation, which 
// will require linking the assignments with the rest of the code.
.decl PhiPseudoAssign(?phi_var:symbol, ?def:symbol, ?src_block:symbol, ?dst_block:symbol, ?pseudoname:symbol)

// Many assigns on the same phi var, consist of a PhiChunk. These are unique, since 
// phi_var is unique (SSA naming).
.decl PhiChunk(?phi_var:symbol)

// Many PhiChunks in the same basic block, consist of a PhiHeader.
.decl PhiHeader(?block:symbol)

// TODO: Check validity/necessity of isNonTrivialPhi relation

PhiChunk(?phi_var),
PhiHeader(?dst_block),
PhiPseudoAssign(?phi_var, ?phi_arg, ?src_block, ?dst_block, ?pseudoname) :-
    PhiAssign(?phi_var, _, ?dst_block),
    //isNonTrivialPhi(?dst_block, ?phi_var),
    MayPredecessorBBModuloThrow(?src_block, ?dst_block),
    SimilarOutDefs(?src_block, ?phi_var, ?phi_arg),
    Instruction_Index(?src_block, ?src_idx),
    Instruction_Index(?dst_block, ?dst_idx),
    ?pseudoname = cat(?phi_var, cat("_", to_string(?src_idx))).

// TODO: Are the initial checks needed?
.decl ExistsPseudoAssignBetween(?prev:symbol, ?next:symbol)
ExistsPseudoAssignBetween(?prev, ?next) :-
    PhiPseudoAssign(?phi, _, _, ?block, ?prev),
    PhiPseudoAssign(?phi, _, _, ?block, ?next),
    PhiPseudoAssign(?phi, _, _, ?block, ?mid),
    ord(?prev) < ord(?next),
    ord(?prev) < ord(?mid),
    ord(?mid)  < ord(?next).

.decl ExistsPhiChunkBetween(?prev:symbol, ?next:symbol)

ExistsPhiChunkBetween(?prev, ?next) :-
    PhiPseudoAssign(?prev, _, _, ?block, _),
    PhiPseudoAssign(?next, _, _, ?block, _),
    PhiPseudoAssign(?mid, _, _, ?block, _),
    ord(?prev) < ord(?next),
    ord(?prev) < ord(?mid),
    ord(?mid)  < ord(?next).

// New next relation, since we need to include the new assignments that
// are generated by the phi placement.
.decl SSANext(?prev:symbol, ?next:symbol)

.decl PhiChunkNext(?prev:symbol, ?next:symbol)

// Link PhiChunk assignments
SSANext(?prev, ?next),
PhiChunkNext(?prev, ?next) :-
    PhiPseudoAssign(?chunk, _, _, ?block, ?prev),
    PhiPseudoAssign(?chunk, _, _, ?block, ?next),
    ord(?prev) < ord(?next),
    !ExistsPseudoAssignBetween(?prev, ?next).

.decl PhiChunkStart(?phi_chunk:symbol, ?start:symbol)

PhiChunkStart(?phi_chunk, ?start) :-
    PhiPseudoAssign(?phi_chunk, _, _, _, ?start),
    !PhiChunkNext(_, ?start).

.decl PhiChunkEnd(?phi_chunk:symbol, ?end:symbol)

PhiChunkEnd(?phi_chunk, ?end) :-
    PhiPseudoAssign(?phi_chunk, _, _, _, ?end),
    !PhiChunkNext(?end, _).

.decl PhiHeaderNext(?prev:symbol, ?next:symbol)

SSANext(?prev_end, ?next_start),
PhiHeaderNext(?prev, ?next) :-
    PhiPseudoAssign(?prev, _, _, ?phi_header, _),
    PhiPseudoAssign(?next, _, _, ?phi_header, _),
    PhiChunkEnd(?prev, ?prev_end),
    PhiChunkStart(?next, ?next_start),
    ord(?prev) < ord(?next),
    !ExistsPhiChunkBetween(?prev, ?next).
    
.decl PhiHeaderStart(?phi_chunk:symbol, ?start:symbol)

PhiHeaderStart(?phi_header, ?start) :-
    PhiPseudoAssign(?start_chunk, _, _, ?phi_header, _),
    PhiChunkStart(?start_chunk, ?start),
    !PhiHeaderNext(_, ?start_chunk).

.decl PhiHeaderEnd(?phi_chunk:symbol, ?end:symbol)

SSANext(?end, ?phi_header),
PhiHeaderEnd(?phi_header, ?end) :-
    PhiPseudoAssign(?end_chunk, _, _, ?phi_header, _),
    PhiChunkEnd(?end_chunk, ?end),
    !PhiHeaderNext(?end_chunk, _).

SSANext(?prev, ?next) :-
    Instruction_Next(?prev, ?old_next),
    PhiHeaderStart(?old_next, ?next).

SSANext(?prev, ?next) :-
    Instruction_Next(?prev, ?next),
    !PhiHeaderStart(?next, _).

.decl isInstr(?insn:symbol)

isInstruction(?insn) :-
    Instruction_Method(?insn, _).

isInstruction(?insn) :-
    PhiPseudoAssign(_, _, _, _, ?insn).

// Simple index calculation, based on the SSANext relation.
.decl SSA_InstructionIndex(?insn:symbol, ?index:number)

// Base case; If the insn has no previous instruction, then its index
// is one.
SSA_InstructionIndex(?insn, 1) :-
    isInstruction(?insn),
    !SSANext(_, ?insn).

// If the insn has a prev instruction and prev has index "index", then
// insn has index "index  + 1".
SSA_InstructionIndex(?insn, ?index + 1) :-
    SSANext(?prev, ?insn),
    SSA_InstructionIndex(?prev, ?index).

// If the phi header for the basic block where insn is in, contains an phi
// pseudo assignment on ssa_var, which is an ssa rename for origin.
.decl ExistsDefInPhiHeader(?insn:symbol, ?ssa_var:symbol, ?origin:symbol)

ExistsDefInPhiHeader(?insn, ?ssa_var, ?origin) :-
    BasicBlockHead(?insn, ?head),
    PhiPseudoAssign(?ssa_var, _, _, ?head, _),
    SSA_Alias(?ssa_var, ?origin).

// This is a simple calculation of the reaching SSA definitions (ssa_var),
// at a given instruction (insn), for a given origin variable (not ssa-renamed,
// as seen in the original program).
.decl ReachingDef(?insn:symbol, ?ssa_var:symbol, ?origin:symbol)

// If an instruction is the first instruction in a basic block, and a ssa defintion
// for origin exists in the Phi Header, then that def is the reaching def.
ReachingDef(?insn, ?ssa_var, ?origin) :-
    BasicBlockBegin(?insn),
    ExistsDefInPhiHeader(?insn, ?ssa_var, ?origin).

// If an instruction is the first instrution in a basic block, and there is no ssa
// definition for origin in the Phi Header, then the reaching definition is in the
// outwards defs of any of the predecessor basic blocks (the defs will all be the same,
// otherwise there would be a Phi Assignment in the Phi header).

// Old
//ReachingDef(?insn, ?ssa_var, ?origin) :-
//    BasicBlockBegin(?insn),
//    !ExistsDefInPhiHeader(?insn, _, ?origin),
//    SSA_Alias(?saa_var, ?origin),
//    MayPredecessorBBModuloThrow(?pred, ?insn),
//    SimilarOutDefs(?pred, _, ?ssa_var).

// Based on new
ReachingDef(?insn, ?ssa_var, ?origin) :-
    BasicBlockBegin(?insn),
    !ExistsDefInPhiHeader(?insn, _, ?origin),
    MayPredecessorBBModuloThrow(?pred, ?insn),
    BasicBlockOutDefs(?pred, ?ssa_var, ?origin).

// If an instruction is not the first instruction in a basic block, and the previous
// instuction is not an assignment with LHS an ssa rename of origin, then the reaching
// ssa definition for origin at insn is the same as the reaching ssa definition for origin
// at prev (recursive definition).
ReachingDef(?insn, ?ssa_var, ?origin) :-
    PrevInSameBasicBlock(?insn, ?prev),
    SSA_Alias(?ssa_var, ?origin),
    !SSA_AssignToOriginal(?prev, ?origin),
    ReachingDef(?prev, ?ssa_var, ?origin).

// If an instruction is not the first instruction in a basic block, and the previous
// instuction is an assignment with LHS an ssa rename of origin, the the reaching ssa defition
// for origin at insn is exactly that LHS ssa rename of origin.
ReachingDef(?insn, ?ssa_var, ?origin) :-
    PrevInSameBasicBlock(?insn, ?prev),
    SSA_Alias(?ssa_var, ?origin),
    SSA_AssignDetails(?prev, _, _, ?ssa_var, _).

// If an instruction is the first instruction in a method, then all formal paramters and
// the "this" register are reaching defs to that instruction.
ReachingDef(?insn, ?ssa_var, ?origin) :-
    SSA_InstructionIndex(?insn, 1),
    Instruction_Method(?insn, ?method),
    (SSA_FormalParam(_, ?method, ?ssa_var);
    SSA_ThisVar(?method, ?ssa_var)),
    SSA_Alias(?ssa_var, ?origin).

.decl NewIndexMapping(?old:number, ?new:number)
.output NewIndexMapping

NewIndexMapping(?old, ?new) :-
    Instruction_Index(?insn, ?old),
    SSA_InstructionIndex(?insn, ?new).

// Rule rewriting
.decl RewriteArrayInitialValueFromLocal(?insn:symbol, ?index:number, ?to:symbol, ?arrayIndex:number, ?from:symbol, ?baseHeap:symbol, ?inmethod:symbol)
.output RewriteArrayInitialValueFromLocal(filename="ArrayInitialValueFromLocal.facts")

RewriteArrayInitialValueFromLocal(?insn, ?index, ?to, ?arrayIndex, ?from, ?baseHeap, ?inmethod) :-
    ArrayInitialValueFromLocal(?insn, ?index, ?to_origin, ?arrayIndex, ?from_origin, ?baseHeap, ?inmethod),
    ReachingDef(?insn, ?from, ?from_origin),
    ReachingDef(?insn, ?to, ?to_origin).

// Rule rewriting
.decl RewriteArrayInitialValueFromConst(?insn:symbol, ?index:number, ?to:symbol, ?arrayIndex:number, ?const:symbol, ?baseHeap:symbol, ?inmethod:symbol)
.output RewriteArrayInitialValueFromConst(filename="ArrayInitialValueFromConst.facts")

RewriteArrayInitialValueFromConst(?insn, ?index, ?to, ?arrayIndex, ?const, ?baseHeap, ?inmethod) :-
    ArrayInitialValueFromConst(?insn, ?index, ?var_origin, ?arrayIndex, ?const, ?baseHeap, ?inmethod),
    ReachingDef(?insn, ?to, ?var_origin).

.decl RewriteArrayInsnIndex(?insn:symbol, ?index:symbol)
.output RewriteArrayInsnIndex(filename="ArrayInsnIndex.facts")

RewriteArrayInsnIndex(?insn, ?index) :-
    ArrayInsnIndex(?insn, ?index_origin),
    ReachingDef(?insn, ?index, ?index_origin).

.decl RewriteActualParam(?index:number, ?invocation:symbol, ?var:symbol)
.output RewriteActualParam(filename="ActualParam.facts")

RewriteActualParam(?index, ?invocation, ?var) :-
    ActualParam(?index, ?invocation, ?var_origin),
    ReachingDef(?invocation, ?var, ?var_origin).

.decl RewriteAssignBinop(?insn:symbol, ?index:number, ?to:symbol, ?inmethod:symbol)
.output RewriteAssignBinop(filename="AssignBinop.facts")

RewriteAssignBinop(?insn, ?index, ?to, ?inmethod) :-
    SSA_AssignBinop(?insn, _, ?to, ?inmethod),
    SSA_InstructionIndex(?insn, ?index).

.decl RewriteAssignCast(?insn:symbol, ?index:number, ?from:symbol, ?to:symbol, ?type:symbol, ?inmethod:symbol)
.output RewriteAssignCast(filename="AssignCast.facts")

RewriteAssignCast(?insn, ?index, ?from, ?to, ?type, ?inmethod) :-
    SSA_AssignCast(?insn, _, ?to, ?inmethod),
    AssignCast_Type(?insn, ?type),
    AssignCast_From(?insn, ?from_origin),
    SSA_InstructionIndex(?insn, ?index),
    ReachingDef(?insn, ?from, ?from_origin).

.decl RewriteAssignCastNull(?insn:symbol, ?index:number, ?to:symbol, ?type:symbol, ?inmethod:symbol)
.output RewriteAssignCastNull(filename="AssignCastNull.facts")

RewriteAssignCastNull(?insn, ?index, ?to, ?type, ?inmethod) :-
    SSA_AssignCastNull(?insn, _, ?to, ?inmethod),
    AssignCast_Type(?insn, ?type),
    SSA_InstructionIndex(?insn, ?index).

.decl RewriteAssignCastNumConstant(?insn:symbol, ?index:number, ?const:symbol, ?to:symbol, ?type:symbol, ?inmethod:symbol)
.output RewriteAssignCastNumConstant(filename="AssignCastNumConstant.facts")

RewriteAssignCastNumConstant(?insn, ?index, ?const, ?to, ?type, ?inmethod) :-
    SSA_AssignCastNumConstant(?insn, _, ?to, ?inmethod),
    AssignCast_Type(?insn, ?type),
    AssignCastNumConstant_Id(?insn, ?const),
    SSA_InstructionIndex(?insn, ?index).

.decl RewriteAssignHeapAllocation(?insn:symbol, ?index:number, ?heap:symbol, ?to:symbol, ?inmethod:symbol, ?linenumber:number)
.output RewriteAssignHeapAllocation(filename="AssignHeapAllocation.facts")

RewriteAssignHeapAllocation(?insn, ?index, ?heap, ?to, ?inmethod, ?linenumber) :-
    SSA_AssignHeapAllocation(?insn, _, ?to, ?inmethod),
    AssignHeapAllocation_Heap(?insn, ?heap),
    Instruction_Line(?insn, ?linenumber),
    SSA_InstructionIndex(?insn, ?index).

.decl RewriteAssignOperFrom(?insn:symbol, ?pos:number, ?from:symbol)
.output RewriteAssignOperFrom(filename="AssignOperFrom.facts")

RewriteAssignOperFrom(?insn, ?pos, ?from) :-
    AssignOper_From(?insn, ?pos, ?from_origin),
    ReachingDef(?insn, ?from, ?from_origin).

.decl RewriteAssignInstanceOf(?insn:symbol, ?index:number, ?from:symbol, ?to:symbol, ?type:symbol, ?inmethod:symbol)
.output RewriteAssignInstanceOf(filename="AssignInstanceOf.facts")

RewriteAssignInstanceOf(?insn, ?index, ?from, ?to, ?type, ?inmethod) :-
    SSA_AssignInstanceOf(?insn, _, ?to, ?inmethod),
    SSA_InstructionIndex(?insn, ?index),
    AssignInstanceOf_From(?insn, ?from_origin),
    AssignInstanceOf_Type(?insn, ?type),
    ReachingDef(?insn, ?from, ?from_origin).

.decl RewriteAssignLocal(?insn:symbol, ?index:number, ?to:symbol, ?from:symbol, ?inmethod:symbol)
.output RewriteAssignLocal(filename="AssignLocal.facts")

RewriteAssignLocal(?insn, ?index, ?to, ?from, ?inmethod) :-
    SSA_InstructionIndex(?insn, ?index),
    SSA_AssignLocal(?insn, _, ?to, ?inmethod),
    AssignLocal_From(?insn, ?from_origin),
    ReachingDef(?insn, ?from, ?from_origin).

.decl RewriteAssignNull(?insn:symbol, ?index:number, ?to:symbol, ?inmethod:symbol)
.output RewriteAssignNull(filename="AssignNull.facts")

RewriteAssignNull(?insn, ?index, ?to, ?inmethod) :-
    SSA_AssignNull(?insn, _, ?to, ?inmethod),
    SSA_InstructionIndex(?insn, ?index).

.decl RewriteBootstrapParam(?index:number, ?invocation:symbol, ?var:symbol)
.output RewriteBootstrapParam(filename="BootstrapParam.facts")

RewriteBootstrapParam(?index, ?invocation, ?var) :-
    SSA_InstructionIndex(?invocation, ?index),
    _BootstrapParam(_, ?invocation, ?var_origin),
    ReachingDef(?invocation, ?var, ?var_origin).

.decl RewriteDynamicMethodInvocation(?insn:symbol, ?index:number, ?bootSignature:symbol, ?dynName:symbol, ?dynRetType:symbol, ?dynArity:number, ?dynParamTypes:symbol, ?tag:number, ?method:symbol)
.output RewriteDynamicMethodInvocation(filename="DynamicMethodInvocation.facts")

RewriteDynamicMethodInvocation(?insn, ?index, ?bootSignature, ?dynName, ?dynRetType, ?dynArity, ?dynParamTypes, ?tag, ?method) :-
    SSA_InstructionIndex(?insn, ?index),
    _DynamicMethodInvocation(?insn, _, ?bootSignature, ?dynName, ?dynRetType, ?dynArity, ?dynParamTypes, ?tag, ?method).

.decl RewriteExceptionHandler(?handler:symbol, ?method:symbol, ?index:number, ?type:symbol, ?var:symbol, ?begin:number, ?end:number)
.output RewriteExceptionHandler(filename="ExceptionHandler.facts")

RewriteExceptionHandler(?handler, ?method, ?index, ?type, ?var, ?begin, ?end) :-
    SSA_InstructionIndex(?handler, ?index),
    _ExceptionHandler(?handler, ?method, _, ?type, ?var_origin, ?begin_old, ?end_old),
    NewIndexMapping(?begin_old, ?begin),
    NewIndexMapping(?end_old, ?end),
    SSA_AssignDetails(?handler, ?var_origin, _, ?var, _).

.decl RewriteAssignNumConstant(?insn:symbol, ?index:number, ?const:symbol, ?to:symbol, ?inmethod:symbol)
.output RewriteAssignNumConstant(filename="AssignNumConstant.facts")

RewriteAssignNumConstant(?insn, ?index, ?const, ?to, ?inmethod) :-
    SSA_AssignNumConstant(?insn, _, ?to, ?inmethod),
    SSA_InstructionIndex(?insn, ?index),
    AssignNumConstant_Id(?insn, ?const).

.decl RewriteAssignReturnValue(?invocation:symbol, ?to:symbol)
.output RewriteAssignReturnValue(filename="AssignReturnValue.facts")

RewriteAssignReturnValue(?invocation, ?to) :-
    SSA_AssignDetails(?invocation, ?to_origin, _, ?to, _),
    AssignReturnValue(?invocation, ?to_origin).

.decl RewriteAssignUnop(?insn:symbol, ?index:number, ?to:symbol, ?inmethod:symbol)
.output RewriteAssignUnop(filename="AssignUnop.facts")

RewriteAssignUnop(?insn, ?index, ?to, ?inmethod) :-
    SSA_AssignUnop(?insn, _, ?to, ?inmethod),
    SSA_InstructionIndex(?insn, ?index).

.decl RewriteEnterMonitor(?instruction:symbol, ?index:number, ?var:symbol, ?method:symbol)
.output RewriteEnterMonitor(filename="EnterMonitor.facts")

RewriteEnterMonitor(?insn, ?index, ?var, ?method) :-
    SSA_InstructionIndex(?insn, ?index),
    _EnterMonitor(?insn, _, ?var_origin, ?method),
    ReachingDef(?insn, ?var, ?var_origin).

.decl RewriteExitMonitor(?instruction:symbol, ?index:number, ?var:symbol, ?method:symbol)
.output RewriteExitMonitor(filename="ExitMonitor.facts")

RewriteExitMonitor(?insn, ?index, ?var, ?method) :-
    SSA_InstructionIndex(?insn, ?index),
    _ExitMonitor(?insn, _, ?var_origin, ?method),
    ReachingDef(?insn, ?var, ?var_origin).

.decl RewriteGoto(?insn:symbol, ?index:number, ?to:number, ?inmethod:symbol)
.output RewriteGoto(filename="Goto.facts")

RewriteGoto(?insn, ?index, ?to, ?inmethod) :-
    SSA_InstructionIndex(?insn, ?index),
    isGoto_Insn(?insn),
    Instruction_Method(?insn, ?inmethod),
    Goto_Target(?insn, ?old_to),
    NewIndexMapping(?old_to, ?to).

.decl RewriteIf(?insn:symbol, ?index:number, ?to:number, ?inmethod:symbol)
.output RewriteIf(filename="If.facts")

RewriteIf(?insn, ?index, ?to, ?inmethod) :-
    SSA_InstructionIndex(?insn, ?index),
    isIf_Insn(?insn),
    Instruction_Method(?insn, ?inmethod),
    If_Target(?insn, ?old_to),
    NewIndexMapping(?old_to, ?to).

.decl RewriteIfVar(?insn:symbol, ?pos:number, ?var:symbol)
.output RewriteIfVar(filename="IfVar.facts")

RewriteIfVar(?insn, ?pos, ?var) :- 
    If_Var(?insn, ?pos, ?var_origin),
    ReachingDef(?insn, ?var, ?var_origin).

.decl RewriteLoadArrayIndex(?insn:symbol, ?index:number, ?to:symbol, ?base:symbol, ?method:symbol)
.output RewriteLoadArrayIndex(filename="LoadArrayIndex.facts")

RewriteLoadArrayIndex(?insn, ?index, ?to, ?base, ?inmethod) :-
    SSA_LoadArrayIndex(?insn, _, ?to, ?inmethod),
    SSA_InstructionIndex(?insn, ?index),
    LoadArrayIndex_Base(?insn, ?base_origin),
    ReachingDef(?insn, ?base, ?base_origin).

.decl RewriteLoadInstanceField(?insn:symbol, ?index:number, ?to:symbol, ?base:symbol, ?signature:symbol, ?method:symbol)
.output RewriteLoadInstanceField(filename="LoadInstanceField.facts")

RewriteLoadInstanceField(?insn, ?index, ?to, ?base, ?signature, ?inmethod) :-
    SSA_LoadInstanceField(?insn, _, ?to, ?inmethod),
    SSA_InstructionIndex(?insn, ?index),
    LoadInstanceField_Base(?insn, ?base_origin),
    FieldInstruction_Signature(?insn, ?signature),
    ReachingDef(?insn, ?base, ?base_origin).

.decl RewriteLoadStaticField(?insn:symbol, ?index:number, ?to:symbol, ?signature:symbol, ?method:symbol)
.output RewriteLoadStaticField(filename="LoadStaticField.facts")

RewriteLoadStaticField(?insn, ?index, ?to, ?signature, ?inmethod) :-
    SSA_LoadStaticField(?insn, _, ?to, ?inmethod),
    SSA_InstructionIndex(?insn, ?index),
    FieldInstruction_Signature(?insn, ?signature).

.decl RewriteLookupSwitch(?insn:symbol, ?index:number, ?key:symbol, ?method:symbol)
.output RewriteLookupSwitch(filename="LookupSwitch.facts")

RewriteLookupSwitch(?insn, ?index, ?key, ?inmethod) :-
    SSA_InstructionIndex(?insn, ?index),
    _LookupSwitch(?insn, _, ?key_origin, ?inmethod),
    ReachingDef(?insn, ?key, ?key_origin).

.decl RewriteLookupSwitch_Target(?insn:symbol, ?value:number, ?target:number)
.output RewriteLookupSwitch_Target(filename="LookupSwitch-Target.facts")

RewriteLookupSwitch_Target(?insn, ?value, ?target) :-
    _LookupSwitch_Target(?insn, ?value, ?target_old),
    NewIndexMapping(?target_old, ?target).

.decl RewriteLookupSwitch_DefaultTarget(?insn:symbol, ?target:number)
.output RewriteLookupSwitch_DefaultTarget(filename="LookupSwitch-Default.facts")

RewriteLookupSwitch_DefaultTarget(?insn, ?target) :-
    _LookupSwitch_DefaultTarget(?insn, ?target_old),
    NewIndexMapping(?target_old, ?target).

.decl RewriteReturn(?insn:symbol, ?index:number, ?var:symbol, ?inmethod:symbol)
.output RewriteReturn(filename="Return.facts")

RewriteReturn(?insn, ?index, ?var, ?inmethod) :-
    SSA_InstructionIndex(?insn, ?index),
    Instruction_Method(?insn, ?inmethod),
    ReturnNonvoid_Var(?insn, ?var_origin),
    ReachingDef(?insn, ?var, ?var_origin).

.decl RewriteReturnVoid(?insn:symbol, ?index:number, ?inmethod:symbol)
.output RewriteReturnVoid(filename="ReturnVoid.facts")

RewriteReturnVoid(?insn, ?index, ?inmethod) :-
    SSA_InstructionIndex(?insn, ?index),
    Instruction_Method(?insn, ?inmethod),
    isReturnVoid_Insn(?insn).

.decl RewriteSpecialMethodInvocation(?insn:symbol, ?index:number, ?signature:symbol, ?base:symbol, ?method:symbol)
.output RewriteSpecialMethodInvocation(filename="SpecialMethodInvocation.facts")

RewriteSpecialMethodInvocation(?insn, ?index, ?signature, ?base, ?inmethod) :-
    SSA_InstructionIndex(?insn, ?index),
    _SpecialMethodInvocation(?insn, _, ?signature, ?base_origin, ?inmethod),
    ReachingDef(?insn, ?base, ?base_origin).

.decl RewriteStaticMethodInvocation(?insn:symbol, ?index:number, ?signature:symbol, ?method:symbol)
.output RewriteStaticMethodInvocation(filename="StaticMethodInvocation.facts")

RewriteStaticMethodInvocation(?insn, ?index, ?signature, ?inmethod) :-
    SSA_InstructionIndex(?insn, ?index),
    _StaticMethodInvocation(?insn, _, ?signature, ?inmethod).

.decl RewriteStoreArrayIndex(?insn:symbol, ?index:number, ?from:symbol, ?base:symbol, ?method:symbol)
.output RewriteStoreArrayIndex(filename="StoreArrayIndex.facts")

RewriteStoreArrayIndex(?insn, ?index, ?from, ?base, ?inmethod) :-
    SSA_InstructionIndex(?insn, ?index),
    _StoreArrayIndex(?insn, _, ?from_origin, ?base_origin, ?inmethod),
    ReachingDef(?insn, ?from, ?from_origin),
    ReachingDef(?insn, ?base, ?base_origin).

.decl RewriteStoreInstanceField(?insn:symbol, ?index:number, ?from:symbol, ?base:symbol, ?signature:symbol, ?method:symbol)
.output RewriteStoreInstanceField(filename="StoreInstanceField.facts")

RewriteStoreInstanceField(?insn, ?index, ?from, ?base, ?signature, ?inmethod) :-
    SSA_InstructionIndex(?insn, ?index),
    _StoreInstanceField(?insn, _, ?from_origin, ?base_origin, ?signature, ?inmethod),
    ReachingDef(?insn, ?from, ?from_origin),
    ReachingDef(?insn, ?base, ?base_origin).

.decl RewriteStoreStaticField(?insn:symbol, ?index:number, ?from:symbol, ?signature:symbol, ?method:symbol)
.output RewriteStoreStaticField(filename="StoreStaticField.facts")

RewriteStoreStaticField(?insn, ?index, ?from, ?signature, ?inmethod) :-
    SSA_InstructionIndex(?insn, ?index),
    _StoreStaticField(?insn, _, ?from_origin, ?signature, ?inmethod),
    ReachingDef(?insn, ?from, ?from_origin).

.decl RewriteSuperMethodInvocation(?insn:symbol, ?index:number, ?signature:symbol, ?base:symbol, ?method:symbol)
.output RewriteSuperMethodInvocation(filename="SuperMethodInvocation.facts")

RewriteSuperMethodInvocation(?insn, ?index, ?signature, ?base, ?inmethod) :-
    SSA_InstructionIndex(?insn, ?index),
    _SuperMethodInvocation(?insn, _, ?signature, ?base_origin, ?inmethod),
    ReachingDef(?insn, ?base, ?base_origin).

.decl RewriteTableSwitch(?insn:symbol, ?index:number, ?key:symbol, ?method:symbol)
.output RewriteTableSwitch(filename="TableSwitch.facts")

RewriteTableSwitch(?insn, ?index, ?key, ?inmethod) :-
    SSA_InstructionIndex(?insn, ?index),
    _TableSwitch(?insn, _, ?key_origin, ?inmethod),
    ReachingDef(?insn, ?key, ?key_origin).

.decl RewriteTableSwitch_Target(?insn:symbol, ?value:number, ?target:number)
.output RewriteTableSwitch_Target(filename="TableSwitch-Target.facts")

RewriteTableSwitch_Target(?insn, ?value, ?target) :-
    _TableSwitch_Target(?insn, ?value, ?target_old),
    NewIndexMapping(?target_old, ?target).

.decl RewriteTableSwitch_DefaultTarget(?insn:symbol, ?target:number)
.output RewriteTableSwitch_DefaultTarget(filename="TableSwitch-Default.facts")

RewriteTableSwitch_DefaultTarget(?insn, ?target) :-
    _TableSwitch_DefaultTarget(?insn, ?target_old),
    NewIndexMapping(?target_old, ?target).

.decl RewriteThrow(?insn:symbol, ?index:number, ?var:symbol, ?method:symbol)
.output RewriteThrow(filename="Throw.facts")

RewriteThrow(?insn, ?index, ?var, ?inmethod) :-
    SSA_InstructionIndex(?insn, ?index),
    _Throw(?insn, _, ?var_origin, ?inmethod),
    ReachingDef(?insn, ?var, ?var_origin).

.decl RewriteThrowNull(?insn:symbol, ?index:number, ?method:symbol)
.output RewriteThrowNull(filename="ThrowNull.facts")

RewriteThrowNull(?insn, ?index, ?inmethod) :-
    SSA_InstructionIndex(?insn, ?index),
    _ThrowNull(?insn, _, ?inmethod).

.decl RewriteVirtualMethodInvocation(?insn:symbol, ?index:number, ?signature:symbol, ?base:symbol, ?method:symbol)
.output RewriteVirtualMethodInvocation(filename="VirtualMethodInvocation.facts")

RewriteVirtualMethodInvocation(?insn, ?index, ?signature, ?base, ?inmethod) :-
    SSA_InstructionIndex(?insn, ?index),
    _VirtualMethodInvocation(?insn, _, ?signature, ?base_origin, ?inmethod),
    ReachingDef(?insn, ?base, ?base_origin).

.decl RewriteVarDeclaringMethod(?var:symbol, ?method:symbol)
.output RewriteVarDeclaringMethod(filename="Var-DeclaringMethod.facts")

RewriteVarDeclaringMethod(?var, ?method) :-
    Var_DeclaringMethod(?var_origin, ?method),
    SSA_Alias(?var, ?var_origin).

.output isInstruction
.output SSA_FormalParam(filename="FormalParam.facts")
.output SSA_ThisVar(filename="ThisVar.facts")
