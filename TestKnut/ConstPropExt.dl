
.type Var <: symbol
.type Method <: symbol
.type Operator <: symbol
.type Assignment <: symbol
.type MethodInv <: symbol

.decl VarDeclaringMethod(?var:Var,?method:Method)
.input VarDeclaringMethod(IO="file", filename="Var-DeclaringMethod.facts", delimiter="\t")

.decl AssignLocal(?inst:Assignment, ?nr:number,?var1:Var, ?var2:Var, ?method:Method)
.input AssignLocal(IO="file", filename="AssignLocal.facts", delimiter="\t")

.decl BasicBlockHead(?inst:Assignment, ?ins:Assignment)
.input BasicBlockHead(IO="file", filename="BasicBlockHead.csv", delimiter="\t")

.decl JumpTarget(?inst:Assignment, ?instr:Assignment)
.input JumpTarget(IO="file", filename="JumpTarget.csv", delimiter="\t")

.decl IsJumpTarget(?inst:Assignment)
.input IsJumpTarget(IO="file", filename="IsJumpTarget.csv", delimiter="\t")

.decl Instruction_Next(?inst:Assignment,?inst1:Assignment)
.input Instruction_Next(IO="file", filename="Instruction_Next.csv", delimiter="\t")

.decl MaySuccessorBBModuloThrow(?inst:Assignment, ?inst1:Assignment)
.input MaySuccessorBBModuloThrow(IO="file", filename="MaySuccessorBBModuloThrow.csv", delimiter="\t")

.decl MayPredecessorBBModuloThrow(?inst:Assignment, ?inst1:Assignment)
.input MayPredecessorBBModuloThrow(IO="file", filename="MayPredecessorBBModuloThrow.csv", delimiter="\t")


.decl NextInSamePhiNode(?inst:Assignment,?inst1:Assignment)
.input NextInSamePhiNode(IO="file", filename="NextInSamePhiNode.csv", delimiter="\t")


.decl OperatorAt(?assign:Assignment, ?op:Operator)
.input OperatorAt(IO="file", filename="OperatorAt.facts", delimter="\t")



.decl VarType(?var:Var, ?type:symbol)
.input VarType(IO="file", filename="Var-Type.facts", delimiter="\t")


.decl IntConstFolding(?instruction:Assignment, ?variable:Var, ?value:number, ?meth:symbol, ?use:number)
.input IntConstFolding(IO="file", filename="IntConstFolding.csv",delimiter="\t")

.decl BoolConstFolding(?instruction:Assignment, ?var:Var, ?value:number, ?meth:symbol)
.input BoolConstFolding(IO="file", filename="BoolConstFolding.csv",delimiter="\t")


.decl IfVar(?instr:Assignment, ?n: number, ?var:Var)
.input IfVar(IO="file", filename="IfVar.facts",delimiter="\t")

.decl IfConstant(?instr:Assignment, ?n:number, ?val:number)
.input IfConstant(IO="file", filename="IfConstant.facts", delimiter="\t")



.decl StaticCondition(?instr:Assignment, ?value:number)
.output StaticCondition


//Int Condition <=

StaticCondition(?ifAssign,?value) :- 
    IfVar(?ifAssign, ?pos1, ?var1), 
    IntConstFolding(_,?var1,?left,_, _),
    IfConstant(?ifAssign, ?pos2, ?right),
    ?pos1 < ?pos2,
    OperatorAt(?ifAssign,"<="),
    ((?value = 1, ?left <= ?right);
    (?value = 0, ?left > ?right)).

StaticCondition(?ifAssign,?value) :- 
    IfConstant(?ifAssign, ?pos1, ?left),
    IfVar(?ifAssign, ?pos2, ?var2), 
    IntConstFolding(_,?var2,?right,_, _),
    ?pos1 < ?pos2,
    OperatorAt(?ifAssign,"<="),
    ((?value = 1, ?left <= ?right);
    (?value = 0, ?left > ?right)).

StaticCondition(?ifAssign,?value) :- 
    IfVar(?ifAssign, ?pos1, ?var1), 
    IfVar(?ifAssign, ?pos2, ?var2), 
    IntConstFolding(_,?var1,?left,_, _),
    IntConstFolding(_,?var2,?right,_,_),
    ?pos1 < ?pos2,
    OperatorAt(?ifAssign,"<="),
    ((?value = 1, ?left <= ?right);
    (?value = 0, ?left > ?right)).


//Boolean Condition ==
StaticCondition(?ifAssign,?value) :- 
    IfVar(?ifAssign, ?pos1, ?var1), 
    BoolConstFolding(_,?var1,?left,_),
    IfConstant(?ifAssign, ?pos2, ?right),
    ?pos1 < ?pos2,
    OperatorAt(?ifAssign,"=="),
    ((?value = 1 , ?left = ?right);
    (?value = 0 , ?left != ?right)).

StaticCondition(?ifAssign,?value) :- 
    IfConstant(?ifAssign, ?pos1, ?left),
    IfVar(?ifAssign, ?pos2, ?var2), 
    BoolConstFolding(_,?var2,?right,_),
    ?pos1 < ?pos2,
    OperatorAt(?ifAssign,"=="),
    ((?value = 1 , ?left = ?right);
    (?value = 0 , ?left != ?right)).

StaticCondition(?ifAssign,?value) :- 
    IfVar(?ifAssign, ?pos1, ?var1),
    IfVar(?ifAssign, ?pos2, ?var2),  
    BoolConstFolding(_,?var1,?left,_),
    BoolConstFolding(_,?var2,?right,_),
    ?pos1 < ?pos2,
    OperatorAt(?ifAssign,"=="),
    ((?value = 1 , ?left = ?right);
    (?value = 0 , ?left != ?right)).


    
//Boolean Condition !=
StaticCondition(?ifAssign,?value) :- 
    IfVar(?ifAssign, ?pos1, ?var1), 
    BoolConstFolding(_,?var1,?left,_),
    IfConstant(?ifAssign, ?pos2, ?right),
    ?pos1 < ?pos2,
    OperatorAt(?ifAssign,"!="),
    ((?value = 1 , ?left != ?right);
    (?value = 0 , ?left = ?right)).

StaticCondition(?ifAssign,?value) :- 
    IfConstant(?ifAssign, ?pos1, ?left),
    IfVar(?ifAssign, ?pos2, ?var2), 
    BoolConstFolding(_,?var2,?right,_),
    ?pos1 < ?pos2,
    OperatorAt(?ifAssign,"!="),
    ((?value = 1 , ?left != ?right);
    (?value = 0 , ?left = ?right)).

StaticCondition(?ifAssign,?value) :- 
    IfVar(?ifAssign, ?pos1, ?var1), 
    IfVar(?ifAssign, ?pos2, ?var2), 
    BoolConstFolding(_,?var1,?left,_),
    BoolConstFolding(_,?var2,?right,_),
    ?pos1 < ?pos2,
    OperatorAt(?ifAssign,"!="),
    ((?value = 1 , ?left != ?right);
    (?value = 0 , ?left = ?right)).

.decl Exist_CFGPath(?BB1 : Assignment, ?BB2: Assignment)
.output Exist_CFGPath

Exist_CFGPath(?BB1,?BB1),
Exist_CFGPath(?BB2,?BB2),
Exist_CFGPath(?BB1, ?BB2):-
    MayPredecessorBBModuloThrow(?BB1, ?BB2).

Exist_CFGPath(?BB1, ?BB3):-
    Exist_CFGPath(?BB1, ?BB2), 
    Exist_CFGPath(?BB2, ?BB3).



.decl AllReachablePhiNodes(?BB1:Assignment, ?BB2:Assignment)
.output AllReachablePhiNodes

AllReachablePhiNodes(?BB1, ?phiAssign):-
    MayPredecessorBBModuloThrow(?BB1, ?phiAssign),
    AllPhiAssigns(?phiAssign,_),
    !NextInSamePhiNode(?phiAssign,?BB1). //avoid phi-assign/1 -> phi-assign/0 edges


AllReachablePhiNodes(?BB1, ?phiAssign):-
    Exist_CFGPath(?BB1, ?BB2),
    AllReachablePhiNodes(?BB2, ?phiAssign),
    !NextInSamePhiNode(?phiAssign,?BB1). //avoid phi-assign/1 -> phi-assign/0 edges
    

.decl AllPhiAssigns(?phiAssign:Assignment,?lineNr:number)
.output AllPhiAssigns

AllPhiAssigns(?phiAssign,?lineNr):-
    AssignLocal(?phiAssign, ?lineNr,_,_,_),
    (NextInSamePhiNode(?phiAssign, _);
    NextInSamePhiNode(_,?phiAssign)).

.decl AllIfAssign(?ifAssign:Assignment)
AllIfAssign(?ifAssign):-
    IfVar(?ifAssign,_,_).

.decl StaticIfBranchesJoined(?ifAssign:Assignment, ?then:Assignment, ?else:Assignment,?phiAssign:Assignment,?lineNr:number)
.decl StaticIfBranchesMeetAt(?ifAssign:Assignment, ?then:Assignment, ?else:Assignment,?phiAssign:Assignment,?lineNr:number)

//see, where then-else branches join

StaticIfBranchesJoined(?ifAssign,?thenBegin, ?elseBegin, ?phiAssign,?lineNr):-
    AllIfAssign(?ifAssign),
    JumpTarget(?elseBegin,?ifAssign),
    Instruction_Next(?ifAssign, ?thenBegin),
    AllReachablePhiNodes(?elseBegin, ?phiAssign),    //enforce that only the joining of both branches
    AllReachablePhiNodes(?thenBegin, ?phiAssign),                 // is met and no further ?phiAssign are included, once branches join
    AllPhiAssigns(?phiAssign,?lineNr).

StaticIfBranchesMeetAt(?ifAssign,?thenBegin, ?elseBegin, ?phiAssign,?z):-
    ?z = min ?lineNr : StaticIfBranchesJoined(?ifAssign,_, _, _,?lineNr),
    StaticIfBranchesJoined(?ifAssign,?thenBegin, ?elseBegin, ?phiAssign,?z).

.decl ConditionalConstFoldingOutput(?phiAssign:Assignment, ?to:Var, ?val:number)

ConditionalConstFoldingOutput(?phiAssign2, ?to , ?val),
IntConstFolding(?phiAssign2, ?to, ?val,?method, ?c + 1):-
    StaticCondition(?ifAssign,1),
    StaticIfBranchesMeetAt(?ifAssign, _, ?elseBegin,?phiAssign1,_),
    NextInSamePhiNode(?phiAssign1, ?phiAssign2),
    AssignLocal(?phiAssign2,_, ?from, ?to,_),
    IntConstFolding(?varAssign, ?from, ?val, _,?c),
    BasicBlockHead(?varHead,?varAssign),
    Exist_CFGPath(?elseBegin, ?varHead),
    VarDeclaringMethod(?to, ?method).

ConditionalConstFoldingOutput(?phiAssign2, ?to , ?val),
BoolConstFolding(?phiAssign2, ?to, ?val,?method):-
    StaticCondition(?ifAssign,1),
    StaticIfBranchesMeetAt(?ifAssign, _, ?elseBegin,?phiAssign1,_),
    NextInSamePhiNode(?phiAssign1, ?phiAssign2),
    AssignLocal(?phiAssign2,_, ?from, ?to,_),
    BoolConstFolding(?varAssign, ?from, ?val, _),
    BasicBlockHead(?varHead,?varAssign),
    Exist_CFGPath(?elseBegin, ?varHead),
    VarDeclaringMethod(?to, ?method).


ConditionalConstFoldingOutput(?phiAssign, ?to , ?val),
IntConstFolding(?phiAssign, ?to, ?val,?method, ?c + 1):-
    StaticCondition(?ifAssign,0),
    StaticIfBranchesMeetAt(?ifAssign, ?thenBegin, _,?phiAssign,?lineNr),
    AssignLocal(?phiAssign,?lineNr, ?from, ?to,_),
    IntConstFolding(?varAssign, ?from, ?val, _,?c),
    BasicBlockHead(?varHead,?varAssign),
    Exist_CFGPath(?thenBegin, ?varHead),
    VarDeclaringMethod(?to, ?method).

ConditionalConstFoldingOutput(?phiAssign, ?to , ?val),
BoolConstFolding(?phiAssign, ?to, ?val,?method):-
    StaticCondition(?ifAssign,0),
    StaticIfBranchesMeetAt(?ifAssign, ?thenBegin, _,?phiAssign,?lineNr),
    AssignLocal(?phiAssign,?lineNr, ?from, ?to,_),
    BoolConstFolding(?varAssign, ?from, ?val, _),
    BasicBlockHead(?varHead,?varAssign),
    Exist_CFGPath(?thenBegin, ?varHead),
    VarDeclaringMethod(?to, ?method).

.output AllIfAssign
.output ConditionalConstFoldingOutput
.output StaticIfBranchesMeetAt
.output StaticIfBranchesJoined
.output IntConstFolding
.output BoolConstFolding