
.type Var <: symbol
.type Method <: symbol
.type Operator <: symbol
.type Assignment <: symbol
.type MethodInv <: symbol

.decl MultiplePhiAssignsInBB(?phi1:Assignment, ?phi2:Assignment)
.output MultiplePhiAssignsInBB

.decl AllPhiAssigns(?phiAssign:Assignment,?lineNr:number)
.output AllPhiAssigns


.decl OptInstructionFromMethodIndex(?method:Method, ?insNr:number, ?varAssign:Assignment)
.input OptInstructionFromMethodIndex(IO="file", filename="OptInstructionFromMethodIndex.csv", delimiter="\t")

.decl VarDeclaringMethod(?var:Var,?method:Method)
.input VarDeclaringMethod(IO="file", filename="Var-DeclaringMethod.facts", delimiter="\t")

.decl AssignLocal(?inst:Assignment, ?nr:number,?var1:Var, ?var2:Var, ?method:Method)
.input AssignLocal(IO="file", filename="AssignLocal.facts", delimiter="\t")

.decl BasicBlockHead(?inst:Assignment, ?ins:Assignment)
.input BasicBlockHead(IO="file", filename="BasicBlockHead.csv", delimiter="\t")

.decl JumpTarget(?inst:Assignment, ?instr:Assignment)
.input JumpTarget(IO="file", filename="JumpTarget.csv", delimiter="\t")

.decl IsJumpTarget(?inst:Assignment)
.input IsJumpTarget(IO="file", filename="IsJumpTarget.csv", delimiter="\t")

.decl Instruction_Next(?inst:Assignment,?inst1:Assignment)
.input Instruction_Next(IO="file", filename="Instruction_Next.csv", delimiter="\t")

.decl Instruction_Prev(?inst:Assignment,?inst1:Assignment)
.input Instruction_Prev(IO="file", filename="Instruction_Prev.csv", delimiter="\t")

.decl MaySuccessorBBModuloThrow(?inst:Assignment, ?inst1:Assignment)
.input MaySuccessorBBModuloThrow(IO="file", filename="MaySuccessorBBModuloThrow.csv", delimiter="\t")

.decl MayPredecessorBBModuloThrow(?inst:Assignment, ?inst1:Assignment)
.input MayPredecessorBBModuloThrow(IO="file", filename="MayPredecessorBBModuloThrow.csv", delimiter="\t")


.decl NextInSamePhiNode(?inst:Assignment,?inst1:Assignment)
.input NextInSamePhiNode(IO="file", filename="NextInSamePhiNode.csv", delimiter="\t")


.decl OperatorAt(?assign:Assignment, ?op:Operator)
.input OperatorAt(IO="file", filename="OperatorAt.facts", delimter="\t")



.decl VarType(?var:Var, ?type:symbol)
.input VarType(IO="file", filename="Var-Type.facts", delimiter="\t")


.decl IntConstFolding(?instruction:Assignment, ?variable:Var, ?value:number, ?meth:symbol, ?use:number)
.input IntConstFolding(IO="file", filename="IntConstFolding.csv",delimiter="\t")

.decl BoolConstFolding(?instruction:Assignment, ?var:Var, ?value:number, ?meth:symbol)
.input BoolConstFolding(IO="file", filename="BoolConstFolding.csv",delimiter="\t")


.decl IfVar(?instr:Assignment, ?n: number, ?var:Var)
.input IfVar(IO="file", filename="IfVar.facts",delimiter="\t")

.decl IfConstant(?instr:Assignment, ?n:number, ?val:number)
.input IfConstant(IO="file", filename="IfConstant.facts", delimiter="\t")



.decl StaticCondition(?instr:Assignment, ?value:number)
.output StaticCondition


//Int Condition <=

StaticCondition(?ifAssign,?value) :- 
    IfVar(?ifAssign, ?pos1, ?var1), 
    IntConstFolding(_,?var1,?left,_, _),
    IfConstant(?ifAssign, ?pos2, ?right),
    ?pos1 < ?pos2,
    OperatorAt(?ifAssign,"<="),
    ((?value = 1, ?left <= ?right);
    (?value = 0, ?left > ?right)).

StaticCondition(?ifAssign,?value) :- 
    IfConstant(?ifAssign, ?pos1, ?left),
    IfVar(?ifAssign, ?pos2, ?var2), 
    IntConstFolding(_,?var2,?right,_, _),
    ?pos1 < ?pos2,
    OperatorAt(?ifAssign,"<="),
    ((?value = 1, ?left <= ?right);
    (?value = 0, ?left > ?right)).

StaticCondition(?ifAssign,?value) :- 
    IfVar(?ifAssign, ?pos1, ?var1), 
    IfVar(?ifAssign, ?pos2, ?var2), 
    IntConstFolding(_,?var1,?left,_, _),
    IntConstFolding(_,?var2,?right,_,_),
    ?pos1 < ?pos2,
    OperatorAt(?ifAssign,"<="),
    ((?value = 1, ?left <= ?right);
    (?value = 0, ?left > ?right)).

//Int Condition >=

StaticCondition(?ifAssign,?value) :- 
    IfVar(?ifAssign, ?pos1, ?var1), 
    IntConstFolding(_,?var1,?left,_, _),
    IfConstant(?ifAssign, ?pos2, ?right),
    ?pos1 < ?pos2,
    OperatorAt(?ifAssign,">="),
    ((?value = 1, ?left >= ?right);
    (?value = 0, ?left < ?right)).

StaticCondition(?ifAssign,?value) :- 
    IfConstant(?ifAssign, ?pos1, ?left),
    IfVar(?ifAssign, ?pos2, ?var2), 
    IntConstFolding(_,?var2,?right,_, _),
    ?pos1 < ?pos2,
    OperatorAt(?ifAssign,">="),
    ((?value = 1, ?left >= ?right);
    (?value = 0, ?left < ?right)).

StaticCondition(?ifAssign,?value) :- 
    IfVar(?ifAssign, ?pos1, ?var1), 
    IfVar(?ifAssign, ?pos2, ?var2), 
    IntConstFolding(_,?var1,?left,_, _),
    IntConstFolding(_,?var2,?right,_,_),
    ?pos1 < ?pos2,
    OperatorAt(?ifAssign,">="),
    ((?value = 1, ?left >= ?right);
    (?value = 0, ?left < ?right)).

//Int Condition ==
StaticCondition(?ifAssign,?value) :- 
    IfVar(?ifAssign, ?pos1, ?var1), 
    IntConstFolding(_,?var1,?left,_, _),
    IfConstant(?ifAssign, ?pos2, ?right),
    ?pos1 < ?pos2,
    OperatorAt(?ifAssign,"=="),
    ((?value = 1, ?left = ?right);
    (?value = 0, ?left != ?right)).

StaticCondition(?ifAssign,?value) :- 
    IfConstant(?ifAssign, ?pos1, ?left),
    IfVar(?ifAssign, ?pos2, ?var2), 
    IntConstFolding(_,?var2,?right,_, _),
    ?pos1 < ?pos2,
    OperatorAt(?ifAssign,"=="),
    ((?value = 1, ?left = ?right);
    (?value = 0, ?left != ?right)).

StaticCondition(?ifAssign,?value) :- 
    IfVar(?ifAssign, ?pos1, ?var1), 
    IfVar(?ifAssign, ?pos2, ?var2), 
    IntConstFolding(_,?var1,?left,_, _),
    IntConstFolding(_,?var2,?right,_,_),
    ?pos1 < ?pos2,
    OperatorAt(?ifAssign,"=="),
    ((?value = 1, ?left = ?right);
    (?value = 0, ?left != ?right)).


//Int Condition !=
StaticCondition(?ifAssign,?value) :- 
    IfVar(?ifAssign, ?pos1, ?var1), 
    IntConstFolding(_,?var1,?left,_, _),
    IfConstant(?ifAssign, ?pos2, ?right),
    ?pos1 < ?pos2,
    OperatorAt(?ifAssign,"!="),
    ((?value = 1, ?left != ?right);
    (?value = 0, ?left = ?right)).

StaticCondition(?ifAssign,?value) :- 
    IfConstant(?ifAssign, ?pos1, ?left),
    IfVar(?ifAssign, ?pos2, ?var2), 
    IntConstFolding(_,?var2,?right,_, _),
    ?pos1 < ?pos2,
    OperatorAt(?ifAssign,"!="),
    ((?value = 1, ?left != ?right);
    (?value = 0, ?left = ?right)).

StaticCondition(?ifAssign,?value) :- 
    IfVar(?ifAssign, ?pos1, ?var1), 
    IfVar(?ifAssign, ?pos2, ?var2), 
    IntConstFolding(_,?var1,?left,_, _),
    IntConstFolding(_,?var2,?right,_,_),
    ?pos1 < ?pos2,
    OperatorAt(?ifAssign,"!="),
    ((?value = 1, ?left != ?right);
    (?value = 0, ?left = ?right)).


//Boolean Condition ==
StaticCondition(?ifAssign,?value) :- 
    IfVar(?ifAssign, ?pos1, ?var1), 
    BoolConstFolding(_,?var1,?left,_),
    IfConstant(?ifAssign, ?pos2, ?right),
    ?pos1 < ?pos2,
    OperatorAt(?ifAssign,"=="),
    ((?value = 1 , ?left = ?right);
    (?value = 0 , ?left != ?right)).

StaticCondition(?ifAssign,?value) :- 
    IfConstant(?ifAssign, ?pos1, ?left),
    IfVar(?ifAssign, ?pos2, ?var2), 
    BoolConstFolding(_,?var2,?right,_),
    ?pos1 < ?pos2,
    OperatorAt(?ifAssign,"=="),
    ((?value = 1 , ?left = ?right);
    (?value = 0 , ?left != ?right)).

StaticCondition(?ifAssign,?value) :- 
    IfVar(?ifAssign, ?pos1, ?var1),
    IfVar(?ifAssign, ?pos2, ?var2),  
    BoolConstFolding(_,?var1,?left,_),
    BoolConstFolding(_,?var2,?right,_),
    ?pos1 < ?pos2,
    OperatorAt(?ifAssign,"=="),
    ((?value = 1 , ?left = ?right);
    (?value = 0 , ?left != ?right)).


    
//Boolean Condition !=
StaticCondition(?ifAssign,?value) :- 
    IfVar(?ifAssign, ?pos1, ?var1), 
    BoolConstFolding(_,?var1,?left,_),
    IfConstant(?ifAssign, ?pos2, ?right),
    ?pos1 < ?pos2,
    OperatorAt(?ifAssign,"!="),
    ((?value = 1 , ?left != ?right);
    (?value = 0 , ?left = ?right)).

StaticCondition(?ifAssign,?value) :- 
    IfConstant(?ifAssign, ?pos1, ?left),
    IfVar(?ifAssign, ?pos2, ?var2), 
    BoolConstFolding(_,?var2,?right,_),
    ?pos1 < ?pos2,
    OperatorAt(?ifAssign,"!="),
    ((?value = 1 , ?left != ?right);
    (?value = 0 , ?left = ?right)).

StaticCondition(?ifAssign,?value) :- 
    IfVar(?ifAssign, ?pos1, ?var1), 
    IfVar(?ifAssign, ?pos2, ?var2), 
    BoolConstFolding(_,?var1,?left,_),
    BoolConstFolding(_,?var2,?right,_),
    ?pos1 < ?pos2,
    OperatorAt(?ifAssign,"!="),
    ((?value = 1 , ?left != ?right);
    (?value = 0 , ?left = ?right)).

.decl Exist_CFGPath(?BB1 : Assignment, ?BB2: Assignment)
.output Exist_CFGPath

Exist_CFGPath(?BB1,?BB1),
Exist_CFGPath(?BB2,?BB2),
Exist_CFGPath(?BB1, ?BB2):-
    MayPredecessorBBModuloThrow(?BB1, ?BB2).

Exist_CFGPath(?BB1, ?BB3):-
    Exist_CFGPath(?BB1, ?BB2), 
    Exist_CFGPath(?BB2, ?BB3).



.decl AllReachablePhiNodes(?BB1:Assignment, ?BB2:Assignment)
.output AllReachablePhiNodes

AllReachablePhiNodes(?BB1, ?phiAssign):-
    MayPredecessorBBModuloThrow(?BB1, ?phiAssign),
    AllPhiAssigns(?phiAssign,_),
    !NextInSamePhiNode(?phiAssign,?BB1). //avoid phi-assign/1 -> phi-assign/0 edges


AllReachablePhiNodes(?BB1, ?phiAssign):-
    Exist_CFGPath(?BB1, ?BB2),
    AllReachablePhiNodes(?BB2, ?phiAssign),
    !NextInSamePhiNode(?phiAssign,?BB1). //avoid phi-assign/1 -> phi-assign/0 edges



MultiplePhiAssignsInBB(?phiAssign1, ?phiAssign2):-
    AllPhiAssigns(?phiAssign2, _),
    AllPhiAssigns(?phiAssign1, _),
    BasicBlockHead(?phiAssign2,?phiAssign1).


MultiplePhiAssignsInBB(?phiAssign1, ?phiAssign3):-
    NextInSamePhiNode(?phiAssign1, ?phiAssign2),
    MultiplePhiAssignsInBB(?phiAssign2, ?phiAssign3).




AllPhiAssigns(?phiAssign,?lineNr):-
    AssignLocal(?phiAssign, ?lineNr,_,_,_),
    (NextInSamePhiNode(?phiAssign, _);
    NextInSamePhiNode(_,?phiAssign)).

.decl AllIfAssign(?ifAssign:Assignment)

AllIfAssign(?ifAssign):-
    IfVar(?ifAssign,_,_).

.decl StaticIfBranchesJoined(?ifAssign:Assignment, ?firstBranch:Assignment, ?secondBranch:Assignment, ?phiAssign:Assignment,?lineNr:number)
.decl StaticIfBranchesMeetAt(?ifAssign:Assignment, ?firstBranch:Assignment, ?secondBranch:Assignment, ?phiAssign:Assignment,?phiAssgin2:Assignment)

// 1. see, where then-else branches join
// 2. find the order of then & else branch going into phi-Nodes
// then-branch means the BB following the if-condition, else is the conditional jump BB
StaticIfBranchesJoined(?ifAssign,?firstBranch, ?secondBranch,?phiAssign,?lineNr):-
    AllIfAssign(?ifAssign),
    JumpTarget(?elseBegin,?ifAssign),
    Instruction_Next(?ifAssign, ?thenBegin),
    AllReachablePhiNodes(?elseBegin, ?phiAssign),    //enforce that only the joining of both branches
    AllReachablePhiNodes(?thenBegin, ?phiAssign),                 // is met and no further ?phiAssign are included, once branches join
    AllPhiAssigns(?phiAssign,?lineNr),
    MayPredecessorBBModuloThrow(?pos1, ?phiAssign),
    MayPredecessorBBModuloThrow(?pos2, ?phiAssign),
    OptInstructionFromMethodIndex(_,?insNr1,?pos1),
    OptInstructionFromMethodIndex(_,?insNr2,?pos2),
    ?insNr1 < ?insNr2,
    ((?firstBranch = ?thenBegin,
    ?secondBranch = ?elseBegin,
    Exist_CFGPath(?thenBegin,?pos1),
    Exist_CFGPath(?elseBegin,?pos2));
    (?firstBranch = ?elseBegin,
    ?secondBranch = ?thenBegin,
    Exist_CFGPath(?elseBegin,?pos1),
    Exist_CFGPath(?thenBegin,?pos2))).

// extract the first phi-assignment, where both branches are joining
StaticIfBranchesMeetAt(?ifAssign,?firstBranch, ?secondBranch, ?phiAssign1, ?phiAssign2):-
    ?z = min ?lineNr : StaticIfBranchesJoined(?ifAssign,_,  _,_,?lineNr),
    StaticIfBranchesJoined(?ifAssign,?firstBranch, ?secondBranch, ?phiAssign1,?z),
    NextInSamePhiNode(?phiAssign1, ?phiAssign2).

StaticIfBranchesMeetAt(?ifAssign,?firstBranch, ?secondBranch, ?phiAssign3, ?phiAssign4):-
    StaticIfBranchesMeetAt(?ifAssign,?firstBranch, ?secondBranch, ?phiAssign1, _),
    MultiplePhiAssignsInBB(?phiAssign1, ?phiAssign3),
    NextInSamePhiNode(?phiAssign3, ?phiAssign4).



//iterieren durch aktuellen Phi-Block ob andere Blöcke existieren
.decl ConditionalConstFoldingOutput(?phiAssign:Assignment, ?to:Var, ?val:number)

//IntConstfolding:

ConditionalConstFoldingOutput(?phiAssign, ?to , ?val),
IntConstFolding(?phiAssign, ?to, ?val,?method,?use + 1):-
    StaticCondition(?ifAssign,0),
    Instruction_Next(?ifAssign,?thenBB),
    !AllIfAssign(?thenBB),
    ((AllIfAssign(?prevIfAssign),    //check if if-assign comes before or after current if-assignment
    Instruction_Prev(?ifAssign,?prevIfAssign), 
    StaticCondition(?prevIfAssign,0));
    (!AllIfAssign(?prevIfAssign),
    Instruction_Prev(?ifAssign,?prevIfAssign))),

    // ignore this if-assignment if one is following (because we didnt jump, we go into it directly)
    !AllIfAssign(?thenBB),
    (StaticIfBranchesMeetAt(?ifAssign, ?thenBB, _ ,?phiAssign,_);
    StaticIfBranchesMeetAt(?ifAssign, _, ?thenBB, _, ?phiAssign)),
    AssignLocal(?phiAssign,_, ?from, ?to,_),
    IntConstFolding(_, ?from, ?val, _,?use),
    VarDeclaringMethod(?to, ?method).


ConditionalConstFoldingOutput(?phiAssign, ?to , ?val),
IntConstFolding(?phiAssign, ?to, ?val,?method,?use + 1):-
    StaticCondition(?ifAssign,1),
    JumpTarget(?elseBB,?ifAssign),
    ((AllIfAssign(?prevIfAssign),    //check if if-assign comes before or after current if-assignment
    Instruction_Prev(?ifAssign,?prevIfAssign), 
    StaticCondition(?prevIfAssign,0));
    (!AllIfAssign(?prevIfAssign),
    Instruction_Prev(?ifAssign,?prevIfAssign))),

    // ignore this if-assignment if one is following (because we didnt jump, we go into it directly)
    !AllIfAssign(?elseBB),
    (StaticIfBranchesMeetAt(?ifAssign, ?elseBB, _ ,?phiAssign,_);
    StaticIfBranchesMeetAt(?ifAssign, _, ?elseBB, _, ?phiAssign)),
    AssignLocal(?phiAssign,_, ?from, ?to,_),
    IntConstFolding(_, ?from, ?val, _,?use),
    VarDeclaringMethod(?to, ?method).



//BoolConstantFolding

ConditionalConstFoldingOutput(?phiAssign, ?to , ?val),
BoolConstFolding(?phiAssign, ?to, ?val,?method):-
    StaticCondition(?ifAssign,0),
    Instruction_Next(?ifAssign,?thenBB),
    !AllIfAssign(?thenBB),
    ((AllIfAssign(?prevIfAssign),    //check if if-assign comes before or after current if-assignment
    Instruction_Prev(?ifAssign,?prevIfAssign), 
    StaticCondition(?prevIfAssign,0));
    (!AllIfAssign(?prevIfAssign),
    Instruction_Prev(?ifAssign,?prevIfAssign))),

    // ignore this if-assignment if one is following (because we didnt jump, we go into it directly)
    !AllIfAssign(?thenBB),
    (StaticIfBranchesMeetAt(?ifAssign, ?thenBB, _ ,?phiAssign,_);
    StaticIfBranchesMeetAt(?ifAssign, _, ?thenBB, _, ?phiAssign)),
    AssignLocal(?phiAssign,_, ?from, ?to,_),
    BoolConstFolding(_, ?from, ?val, _),
    VarDeclaringMethod(?to, ?method).

ConditionalConstFoldingOutput(?phiAssign, ?to , ?val),
BoolConstFolding(?phiAssign, ?to, ?val,?method):-
    StaticCondition(?ifAssign,1),
    JumpTarget(?elseBB,?ifAssign),
    ((AllIfAssign(?prevIfAssign),    //check if if-assign comes before or after current if-assignment
    Instruction_Prev(?ifAssign,?prevIfAssign), 
    StaticCondition(?prevIfAssign,0));
    (!AllIfAssign(?prevIfAssign),
    Instruction_Prev(?ifAssign,?prevIfAssign))),

    // ignore this if-assignment if one is following (because we didnt jump, we go into it directly)
    !AllIfAssign(?elseBB),
    (StaticIfBranchesMeetAt(?ifAssign, ?elseBB, _ ,?phiAssign,_);
    StaticIfBranchesMeetAt(?ifAssign, _, ?elseBB, _, ?phiAssign)),
    AssignLocal(?phiAssign,_, ?from, ?to,_),
    BoolConstFolding(_, ?from, ?val, _),
    VarDeclaringMethod(?to, ?method).





//aktueller Fehler first & secondBranch geben an, welche branch in welchen Phi-Node
// eingeht, aber es gibt noch keine Verbindung zu den tatsächlichen Then & else Branches



.output AllIfAssign
.output ConditionalConstFoldingOutput
.output StaticIfBranchesMeetAt
.output StaticIfBranchesJoined
.output IntConstFolding
.output BoolConstFolding


