.type Var <: symbol
.type Method <: symbol
.type Operator <: symbol
.type Instruction <: symbol
.type MethodInv <: symbol
.type BinExp = [?left : Var, ?op:Operator, ?right:Var]
.type NodeList = [n:Instruction, next:NodeList]

.decl OptInstructionFromMethodIndex(?method:Method, ?insNr:number, ?varAssign:Instruction)
.input OptInstructionFromMethodIndex(IO="file", filename="OptInstructionFromMethodIndex.csv", delimiter="\t")

.decl NextNonDomPredecessorIndexToSameBB(?ass:Instruction, ?ass1:Instruction, ?ass2:Instruction)
.input NextNonDomPredecessorIndexToSameBB(IO="file", filename="NextNonDomPredecessorIndexToSameBB.csv", delimiter="\t")

.decl BasicBlockHead(?inst:Instruction, ?ins:Instruction)
.input BasicBlockHead(IO="file", filename="BasicBlockHead.csv", delimiter="\t")

.decl AssignUnop(?Instruction:Instruction, ?index:number, ?to:Var, ?inmethod:Method)
.input AssignUnop(IO="file", filename="AssignUnop.facts", delimiter="\t")

.decl AssignBinop(?Instruction:Instruction, ?index:number, ?to:Var, ?inmethod:Method)
.input AssignBinop(IO="file", filename="AssignBinop.facts", delimiter="\t")

.decl OperatorAt(?assign:Instruction, ?op:Operator)
.input OperatorAt(IO="file", filename="OperatorAt.facts", delimter="\t")

.decl If(?ifNode:Instruction, ?lineNr:number, ?jump:number, ?method:Method)
.input If(IO="file", filename="If.facts", delimiter="\t")

.decl MayPredecessorBBModuloThrow(?inst:Instruction, ?inst1:Instruction)
.input MayPredecessorBBModuloThrow(IO="file", filename="MayPredecessorBBModuloThrow.csv", delimiter="\t")

.decl AssignOperFrom(?Instruction:Instruction, ?pos: number, ?from:Var)
.input AssignOperFrom(IO="file", filename="AssignOperFrom.facts", delimiter="\t")

.decl AssignOperFromConstant(?Instruction:Instruction, ?pos: number, ?from:Instruction)
.input AssignOperFromConstant(IO="file", filename="AssignOperFromConstant.facts", delimiter="\t")

.decl PhiNodeHead(?insn:Instruction, ?headInsn:Instruction)
.input PhiNodeHead(IO="file", filename="PhiNodeHead.csv", delimiter="\t")

.decl Dominates(?dominator:Instruction, ?insn:Instruction)
.input Dominates(IO="file", filename="Dominates.csv", delimiter="\t")

//use hat keine Positionen
.decl Use(?ins:Instruction, ?var:Var)
.input Use(IO="file", filename="Use.csv", delimiter="\t")

.decl BasicBlockBegin(?ass:Instruction)
.input BasicBlockBegin(IO="file", filename="BasicBlockBegin.csv", delimiter="\t")

.decl BinaryExpression(?assign:Instruction, ?b:BinExp, ?to:Var)
.output BinaryExpression

.decl BinaryExpressionBB(?assign:Instruction, ?exp:BinExp,?to:Var)
.output BinaryExpressionBB


.decl CommonSubExpression(?BB:Instruction, ?exp:BinExp,?nrJoinedBr:number, ?BBcat:Var, ?cse:number)
.output CommonSubExpression

.decl NrOfPredBB(?BB2:Instruction, ?n:number)
.output NrOfPredBB

.decl AllBB(?BB:Instruction)


//without annoying Phi-assigns that are part of a block
.decl NewMayPredecessorBBModuloThrow(?inst:Instruction, ?inst1:Instruction)
.output NewMayPredecessorBBModuloThrow

NewMayPredecessorBBModuloThrow(?BB1, ?BB2):-
    MayPredecessorBBModuloThrow(?BB1, ?BB2),
    !PhiNodeHead(?BB2,_),
    !PhiNodeHead(?BB1, _).

NewMayPredecessorBBModuloThrow(?BB1, ?BB3):-
    MayPredecessorBBModuloThrow(?BB2, ?BB4),
    PhiNodeHead(?BB2,?BB1),
    PhiNodeHead(?BB4,?BB3),
    ?BB3 != ?BB1.
    
NewMayPredecessorBBModuloThrow(?BB1, ?BB4):-
    MayPredecessorBBModuloThrow(?BB2, ?BB4),
    PhiNodeHead(?BB2,?BB1),
    !PhiNodeHead(?BB4,_).

NewMayPredecessorBBModuloThrow(?BB2, ?BB3):-
    MayPredecessorBBModuloThrow(?BB2, ?BB4),
    !PhiNodeHead(?BB2,_),
    PhiNodeHead(?BB4,?BB3).

AllBB(?BB1),
NrOfPredBB(?BB1,?b):-
    NewMayPredecessorBBModuloThrow(_,?BB1),
    ?b = count : {NewMayPredecessorBBModuloThrow(_, ?BB1)}.

BinaryExpression(?assign,[?left, ?op, ?right], ?to):-
    OperatorAt(?assign, ?op),
    !If(?assign, _, _ ,_ ),
    AssignBinop(?assign, _ , ?to,_),
    AssignOperFrom(?assign, ?pos1, ?left),
    AssignOperFrom(?assign, ?pos2, ?right),
    ?pos1 < ?pos2.

BinaryExpression(?assign,[?left, ?op, to_string(?right)], ?to):-
    OperatorAt(?assign, ?op),
    !If(?assign, _, _ ,_ ),
    AssignBinop(?assign, _ , ?to, _),
    AssignOperFrom(?assign, ?pos1, ?left),
    AssignOperFromConstant(?assign, ?pos2, ?right),
    ?pos1 < ?pos2.

BinaryExpression(?assign, [to_string(?left), ?op, ?right], ?to):-
    OperatorAt(?assign, ?op),
    !If(?assign, _, _ ,_ ),
    AssignBinop(?assign, _ , ?to,_),
    AssignOperFromConstant(?assign, ?pos1, ?left),
    AssignOperFrom(?assign, ?pos2, ?right),
    ?pos1 < ?pos2.

BinaryExpressionBB(?phiHead,?exp,?to):-
    BinaryExpression(?assign, ?exp, ?to),
    BasicBlockHead(?assign, ?head),
    PhiNodeHead(?head, ?phiHead).

BinaryExpressionBB(?head,?exp,?to):-
    BinaryExpression(?assign, ?exp, ?to),
    BasicBlockHead(?assign, ?head),
    !PhiNodeHead(?head,_).

.decl PredecessorBranches(?BB1:Instruction, ?BB2:Instruction, ?l:number)
.decl OrderPredecessorBranches(?BB1:Instruction, ?BB2:Instruction, ?order:number)
.decl RecursiveExpressions(?BB:Instruction,?exp:BinExp, ?n:number,?to:Var, ?cse:number)
.decl BBLoop(?BB:Instruction)
.output BBLoop
.output PredecessorBranches
.output OrderPredecessorBranches
.output RecursiveExpressions

BBLoop(?headBB):-
    PhiNodeHead(?BB,?headBB),
    Dominates(?BB, ?preBB),
    NewMayPredecessorBBModuloThrow(?preBB, ?headBB).

PredecessorBranches(?BB, ?preBB,?lineNr):-
    NrOfPredBB(?BB, ?d),
    ?d > 1,
    NewMayPredecessorBBModuloThrow(?preBB,?BB),
    OptInstructionFromMethodIndex(_, ?lineNr,?preBB).

OrderPredecessorBranches(?BB, ?preBB, ?order +1):-
    PredecessorBranches(?BB , ?preBB, ?lineNr1),
    ?order = count : {PredecessorBranches(?BB, _ , ?lineNrBB), ?lineNr1 < ?lineNrBB}.

BinaryExpressionBB(?BB, ?exp, ?to):-
    BBLoop(?BB),
    Dominates(?dom, ?BB),
    PhiNodeHead(?dom, ?domHead),
    NewMayPredecessorBBModuloThrow(?domHead, ?BB),
    BinaryExpressionBB(?domHead, ?exp, ?to).

BinaryExpressionBB(?BB, ?exp, ?to):-
    BBLoop(?BB),
    Dominates(?dom, ?BB),
    !PhiNodeHead(?dom, _),
    NewMayPredecessorBBModuloThrow(?dom, ?BB),
    BinaryExpressionBB(?dom, ?exp, ?to).

RecursiveExpressions(?BB, ?exp, 2, ?to, ?cse):-
    OrderPredecessorBranches(?BB, ?preBB1, 1),
    OrderPredecessorBranches(?BB, ?preBB2, 2),
    BinaryExpressionBB(?preBB1, ?exp,?to1),
    BinaryExpressionBB(?preBB2, ?exp,?to2),
    ((!contains(?to1,?to2),
    !contains(?to2, ?to1),
    ?cse = 1,
    ?to = cat(?to1,?to2));
    (contains(?to1, ?to2), 
    ?to = ?to2, 
    ?cse = 0);
    (contains(?to2, ?to1),
    ?to = ?to1, 
    ?cse = 0)).

RecursiveExpressions(?BB, ?exp, ?joinedBrNew, ?to, ?cse):-
    RecursiveExpressions(?BB, ?exp,?joinedBr,?to1, ?cse1),
    ?joinedBrNew = ?joinedBr +1,
    OrderPredecessorBranches(?BB, ?preBB2,?joinedBrNew),
    BinaryExpressionBB(?preBB2, ?exp,?to2),
    ((contains(?to2, ?to1),
    ?to = ?to1,
    ?cse = ?cse1);
    (!contains(?to2,?to1),
    ?to = cat(?to1, ?to2),
    ?cse = ?cse1 +1)).

BinaryExpressionBB(?BB2, ?exp,?to):-
    BinaryExpressionBB(?BB1,?exp,?to),
    NewMayPredecessorBBModuloThrow(?BB1, ?BB2),
    NrOfPredBB(?BB2,1),
    !BinaryExpression(?BB2, ?exp,_).

BinaryExpressionBB(?BB, ?exp,?to):-
    RecursiveExpressions(?BB, ?exp, ?joinedBr, ?to, ?cse),
    NrOfPredBB(?BB, ?joinedBr),
    !BinaryExpression(?BB, ?exp,_),
    ?cse = 0.


CommonSubExpression(?BB, ?exp, ?joinedBr, ?to, ?cse),
BinaryExpressionBB(?BB, ?exp,?to):-
    RecursiveExpressions(?BB, ?exp, ?joinedBr, ?to, ?cse),
    NrOfPredBB(?BB, ?joinedBr),
    !BinaryExpression(?BB, ?exp,_),
    ?cse >= 1.

CommonSubExpression(?BB2, ?exp, 2, ?to, 1):-
    BinaryExpressionBB(?BB1,?exp,?to),
    NewMayPredecessorBBModuloThrow(?BB1, ?BB2),
    NrOfPredBB(?BB2,1),
    BinaryExpression(?BB2, ?exp,_).

CommonSubExpression(?BB, ?exp, ?joinedBr, ?to, ?cse):-
    RecursiveExpressions(?BB, ?exp, ?joinedBr, ?to, ?cse),
    NrOfPredBB(?BB, ?joinedBr),
    BinaryExpression(?BB, ?exp,_).

