.type Var <: symbol
.type Method <: symbol
.type Operator <: symbol
.type Instruction <: symbol
.type MethodInv <: symbol

.decl MayPredecessorBBModuloThrow(?inst:Instruction, ?inst1:Instruction)
.input MayPredecessorBBModuloThrow(IO="file", filename="MayPredecessorBBModuloThrow.csv", delimiter="\t")

.decl AssignInstanceOf(?ins:Instruction, ?l:number, ?from:Var,?to:Var,?s:symbol, ?meth:MethodInv)
.input AssignInstanceOf(IO="file", filename="AssignInstanceOf.facts", delimiter="\t")

.decl OptReturnInsn(?ins:Instruction,?meth:Method)
.input OptReturnInsn(IO="file", filename="OptReturnInsn.csv", delimiter="\t")

.decl BasicBlockHead(?inst:Instruction, ?ins:Instruction)
.input BasicBlockHead(IO="file", filename="BasicBlockHead.csv", delimiter="\t")

.decl AssignBinop(?instruction:Instruction, ?index:number, ?to:Var, ?inmethod:Method)
.input AssignBinop(IO="file", filename="AssignBinop.facts", delimiter="\t")

.decl AssignCast(?instruction:Instruction, ?index:number, ?from:Var, ?to:Var, ?type:symbol, ?inmethod:Method)
.input AssignCast(IO="file", filename="AssignCast.facts", delimiter="\t")

.decl AssignCastNull(?instruction:Instruction, ?index:number, ?to:Var, ?type:symbol, ?method:Method)
.input AssignCastNull(IO="file", filename="AssignCastNull.facts", delimiter="\t")

.decl AssignCastNumConstant(?instruction:Instruction, ?index:number, ?const:symbol, ?to:Var, ?type:symbol, ?inmethod:Method)
.input AssignCastNumConstant(IO="file", filename="AssignCastNumConstant.facts", delimiter="\t")


.decl AssignHeapAllocation(?instruction:Instruction, ?index:number, ?heap:symbol, ?to:Var, ?inmethod:Method, ?linenumber:number)
.input AssignHeapAllocation(IO="file", filename="AssignHeapAllocation.facts", delimiter="\t")


//.decl AssignInstanceOf(?instruction:Instruction, ?index:number, ?from:Var, ?to:Var, ?type:symbol, ?inmethod:Method)

.decl AssignLocal(?instruction:Instruction, ?index:number, ?from:Var, ?to:Var, ?inmethod:Method)
.input AssignLocal(IO="file", filename="AssignLocal.facts", delimiter="\t")

.decl ArrayAllocation(?ins:Instruction, ?n:number, ?var:Var)
.input ArrayAllocation(IO="file", filename="ArrayAllocation.facts", delimiter="\t")

.decl AssignNull(?instruction:Instruction, ?index:number, ?to:Var, ?method:Method)
.input AssignNull(IO="file", filename="AssignNull.facts", delimiter="\t")

.decl AssignNumConstant(?instruction:Instruction, ?index:number, ?const:symbol, ?to:Var, ?inmethod:Method)
.input AssignNumConstant(IO="file", filename="AssignNumConstant.facts", delimiter="\t")

.decl AssignOperFrom(?instruction:Instruction, ?pos: number, ?from:Var)
.input AssignOperFrom(IO="file", filename="AssignOperFrom.facts", delimiter="\t")

.decl AssignOperFromConstant(?instruction:Instruction, ?pos: number, ?from:symbol)
.input AssignOperFromConstant(IO="file", filename="AssignOperFromConstant.facts", delimiter="\t")

.decl AssignPhantomInvoke(?instruction:Instruction, ?index:number, ?method:Method)
.input AssignPhantomInvoke(IO="file", filename="AssignPhantomInvoke.facts", delimiter="\t")

.decl AssignUnop(?instruction:Instruction, ?index:number, ?to:Var, ?inmethod:Method)
.input AssignUnop(IO="file", filename="AssignUnop.facts", delimiter="\t")

.decl LoadArrayIndex(?instruction:Instruction, ?index:number, ?to:Var, ?base:Var, ?method:Method)
.input LoadArrayIndex(IO="file", filename="LoadArrayIndex.facts", delimiter="\t")

.decl LoadInstanceField(?instruction:Instruction, ?index:number, ?to:Var, ?base:Var, ?signature:symbol, ?method:Method)
.input LoadInstanceField(IO="file", filename="LoadInstanceField.facts", delimiter="\t")

.decl LoadStaticField(?instruction:Instruction, ?index:number, ?to:Var, ?signature:symbol, ?method:Method)
.input LoadStaticField(IO="file", filename="LoadStaticField.facts", delimiter="\t")

.decl Method_FirstInstruction(?method:Method, ?insn:Instruction)
.input Method_FirstInstruction(IO="file", filename="Method_FirstInstruction.csv", delimiter="\t")

.decl ActualParam(?argPos:number, ?ass:Instruction, ?var:Var)
.input ActualParam(IO="file", filename="ActualParam.facts", delimiter="\t")

//auch base -> Use m√∂glich, aber da static field ex. vmtl keine echte Variable
.decl AssignReturnValue(?assign:Instruction, ?var:Var)
.input AssignReturnValue(IO="file", filename="AssignReturnValue.facts", delimiter="\t")

.decl VirtualMethodInvocation(?assign:Instruction, ?nr:number, ?method:Method, ?var:Var, ?m:Method)
.input VirtualMethodInvocation(IO="file", filename="VirtualMethodInvocation.facts", delimiter="\t")

.decl IfVar(?instr:Instruction, ?n: number, ?var:Var)
.input IfVar(IO="file", filename="IfVar.facts", delimiter="\t")

.decl Return(?assign:Instruction, ?n:number, ?var:Var, ?m:Method)
.input Return(IO="file", filename="Return.facts", delimiter="\t")

.decl StoreInstanceField(?instruction:Instruction, ?index:number, ?from:Var, ?base:Var, ?signature:symbol, ?method:symbol)
.input StoreInstanceField(IO="file",filename="StoreInstanceField.facts", delimiter="\t")

.decl ArrayInsnIndex(?ins:Instruction, ?var:Var)
.input ArrayInsnIndex(IO="file",filename="ArrayInsnIndex.facts", delimiter="\t")

.decl ExceptionHandlerFormalParam(?handler:Instruction, ?var:Var)
.input ExceptionHandlerFormalParam(IO="file", filename="ExceptionHandler-FormalParam.facts", delimiter="\t")

.decl StoreStaticField(?assign:Instruction, ?l:number, ?var:Var, ?to:Var, ?meth:MethodInv)
.input StoreStaticField(IO="file", filename="StoreStaticField.facts", delimiter="\t")

.decl StoreArrayIndex(?assign:Instruction, ?n:number, ?var:Var, ?to:Var, ?m:MethodInv)
.input StoreArrayIndex(IO="file", filename="StoreArrayIndex.facts", delimiter="\t")

.decl SpecialMethodInvocation(?ins:Instruction, ?l:number, ?s:symbol, ?var:Var,?m:MethodInv)
.input SpecialMethodInvocation(IO="file", filename="SpecialMethodInvocation.facts", delimiter="\t")

.decl Throw(?ins:Instruction, ?l:number, ?var:Var,?m:MethodInv)
.input Throw(IO="file", filename="Throw.facts", delimiter="\t")

.decl ExitMonitor(?ins:Instruction, ?l:number,?var:Var, ?m:MethodInv)
.input ExitMonitor(IO="file", filename="ExitMonitor.facts", delimiter="\t")

.decl TableSwitch(?ins:Instruction, ?n:number, ?var:Var, ?meth:Method)
.input TableSwitch(IO="file", filename="TableSwitch.facts", delimiter="\t")

.decl LookupSwitch(?ins:Instruction, ?n:number, ?var:Var, ?meth:Method)
.input LookupSwitch(IO="file", filename="LookupSwitch.facts", delimiter="\t")
.decl Use(?assign:Instruction, ?var:Var)
.decl Def(?assign:Instruction, ?var:Var)

.output Use
.output Def
.output LiveVarInBB
.decl UseBB(?assign:Instruction, ?var:Var)
.decl DefBB(?assign:Instruction, ?var:Var)

.output UseBB
.output DefBB
//ExceptionHandler

Use(?assign,?var):-
    LookupSwitch(?assign,_, ?var,_).

Use(?assign,?var):-
    TableSwitch(?assign,_,?var,_).

Use(?assign,?var):-
    ExitMonitor(?assign,_,?var,_).
Use(?assign,?var):-
    Throw(?assign,_,?var,_).

Use(?assign,?var):- 
    SpecialMethodInvocation(?assign,_,_,?var,_).

Def(?assign, ?to),
Use(?assign,?from):-
    StoreArrayIndex(?assign,_, ?from, ?to, _).


Use(?assign,?from):-
    StoreStaticField(?assign,_,?from, _, _).

Def(?assign,?var):-
    ExceptionHandlerFormalParam(?assign,?var).
Use(?assign,?from),
Def(?assign,?to):-
    AssignInstanceOf(?assign, _,?from, ?to,_, _).

Use(?assign,?var):-
    ArrayInsnIndex(?assign,?var).

Use(?assign,?var):-
    ArrayAllocation(?assign,_,?var).

Def(?assign, ?to):-
    AssignBinop(?assign, _, ?to, _).

Use(?assign, ?right_oper):-
    AssignOperFrom(?assign,_ ,?right_oper).

Def(?assign, ?to):-
    AssignBinop(?assign, _, ?to, _),
    AssignOperFromConstant(?assign,_ ,_).

Use(?assign, ?from),
Def(?assign, ?to):-
    AssignCast(?assign, _, ?from, ?to, _ ,_).

Def(?assign, ?to):-
    AssignCastNull(?assign, _, ?to, _ ,_).

Def(?assign, ?to):-
    AssignCastNumConstant(?assign,_, _,?to,_,_).

Def(?assign, ?to):-
    AssignHeapAllocation(?assign, _,_,?to, _, _ ).
    
//InstanceOf

Use(?assign, ?from),
Def(?assign, ?to):-
    AssignLocal(?assign, _, ?from, ?to, _).


Use(?assign, ?from),
Def(?assign, ?to):-
    AssignLocal(?assign, _, ?from, ?to, _).

Def(?assign, ?to):-
    AssignNull(?assign, _ ,?to, _).

Def(?assign, ?to):-
    AssignNumConstant(?assign,_,_,?to,_).

Use(?assign, ?base),
Def(?assign,?to):-
    LoadArrayIndex(?assign,_, ?to, ?base, _).

Use(?assign, ?base),
Def(?assign, ?to):-
    LoadInstanceField(?assign, _, ?to, ?base,_ , _).

Def(?assign, ?to):-
    AssignUnop(?assign,_, ?to,_).

UseBB(?BB,?var):-
    Use(?assign,?var),
    BasicBlockHead(?assign, ?BB).

UseBB(?assign,?var):-
    Use(?assign,?var),
    Method_FirstInstruction(_, ?assign).

DefBB(?BB,?var):-
    Def(?assign,?var),
    BasicBlockHead(?assign, ?BB).

DefBB(?assign,?var):-
    Def(?assign,?var),
    Method_FirstInstruction(_, ?assign).

Def(?assign, ?to):-
    LoadStaticField(?assign, _, ?to, _, _).

Use(?assign,?from):-
    ActualParam(_,?assign, ?from).

Def(?assign, ?to):-
    AssignReturnValue(?assign, ?to).

Use(?assign,?from):-
    VirtualMethodInvocation(?assign, _ ,_, ?from, _).

Use(?assign,?from):-
    IfVar(?assign,_,?from).

Use(?assign,?from):-
    Return(?assign,_,?from,_).

Use(?assign,?to),
Def(?assign,?to),
Use(?assign,?from):-
    StoreInstanceField(?assign,_,?from,?to,_,_).

.decl LiveVarInBB(?BB:Instruction, ?var:Var)
//.decl BBHasNoVar(?ins:Instruction)
.decl AllBB(?BB:Instruction)
.output AllBB

AllBB(?BB):-
    MayPredecessorBBModuloThrow(?BB, _);
    MayPredecessorBBModuloThrow(_,?BB).

LiveVarInBB(?BB, ?var):-
    UseBB(?BB, ?var).

LiveVarInBB(?BB, "eps"):-
    AllBB(?BB),
    !UseBB(?BB, _).

LiveVarInBB(?BB1, ?var2):-
    LiveVarInBB(?BB2, ?var2),
    !DefBB(?BB2, ?var2),
    MayPredecessorBBModuloThrow(?BB1, ?BB2).


.decl OutRel(?BB:Instruction, ?n:number)

OutRel(?BB, ?n -1):-
    AllBB(?BB),
    ?n = count : {LiveVarInBB(?BB, _)}.
.decl DeadVar(?var:Var)

DeadVar(?var):-
    !Use(_, ?var),
    Def(_,?var).
.output DeadVar

.decl NonInit(?var:Var)
NonInit(?var):-
    Use(_,?var),
    !Def(_,?var).
.output NonInit

//LiveVarInBB(?BB, ?var):-
//    OptReturnInsn(?return,_),
//    BasicBlockHead(?return, ?BB),
//    UseBB(?BB, ?var).
//BBHasNoVar(?BB):-
    //MayPredecessorBBModuloThrow(?BB,_),
    //!UseBB(?BB, _).